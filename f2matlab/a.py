# Autogenerated with SMOP version 0.20
import numpy,sys
from copy import copy as _copy
from smop.runtime import *
numpy.random.seed(0)
def addVars(localVar,modLocalVar,usedMods,modUsedMods,**kwargs):
    localVar=_copy(localVar)
    originalLocaVar=localVar
    for i in arange(1,length(usedMods)+1).reshape(1,-1).flat:
        localVar[size(localVar,1)+1-1:size(localVar,1)+size(modLocalVar[usedMods[int(i-1)]-1,2-1],1)+1-1,:]=deal(modLocalVar[usedMods[int(i-1)]-1,2-1][:,:],nargout=1)
        temp=find(strcmp([modUsedMods[:,1-1]],modLocalVar[usedMods[int(i-1)]-1,1-1]))
        if  not isempty(temp):
            for j in arange(1,length(modUsedMods[temp-1,2-1])+1).reshape(1,-1).flat:
                temp2=find(strcmp(modUsedMods[temp-1,2-1][j-1],[modLocalVar[:,1-1]]))
                if  not isempty(temp2):
                    localVar=addVars(localVar,modLocalVar,temp2,modUsedMods)
    a,b=unique([localVar[:,1-1]],nargout=2)
    localVar=localVar[b-1,:]
    return localVar,originalLocaVar
def aftercomment(funstr,row,column,**kwargs):
    out=0
    if  not any(funstr[row-1]=='!'):
        return out
    else:
        temp=findstr(funstr[row-1],'!')
        temp=temp[int(1-1)]
        if temp<=column:
            out=1
    return out
def breakOffFirstFormat(in,**kwargs):
    in=strtrim(in)
    legit=find( not isspace(in))
    out=[in]
    if in[int(1-1)]=="'":
        nQ=nnz(in=="'")-1
        for ii in arange(1,length(nQ)+1).reshape(1,-1).flat:
            nextQ=findNext(1,"'",in)
            nextNonSpace=legit[int(legit>nextQ-1)]
            if  not isempty(nextNonSpace):
                nextNonSpace=nextNonSpace[int(1-1)]
                if nextNonSpace!="'":
                    if  not inastring_f(in,nextNonSpace):
                        out[1-1]=in[1-1:nextNonSpace-1+1-1]
                        out[2-1]=in[nextNonSpace-1:in.shape[0]+1-1]
                        break
    else:
        if any(in=="'"):
            nextQ=findNext(1,"'",in)
            goon=1
            temp=find(in=='(')
            if  not isempty(temp):
                temp2=find(in=="'")
                if  not isempty(temp2):
                    if min(temp)<min(temp2):
                        goon=0
            if goon:
                out[1-1]=in[1-1:nextQ-1+1-1]
                out[2-1]=in[nextQ-1:in.shape[0]+1-1]
    if length(out)<2&length(in)>1:
        if any(in=='/'):
            temp=find(in=='/')
            temp1=find( not inastring_f(in,temp))
            temp2=find(in=='(')
            if  not isempty(temp1):
                goon=1
                if  not isempty(temp2) and temp2[int(1-1)]<temp[int(temp1[int(1-1)]-1)]:
                    goon=0
                if goon:
                    temp1=temp1[int(1-1)]
                    if temp[int(temp1-1)]==1:
                        out[1-1]='/'
                        out[2-1]=in[2-1:in.shape[0]+1-1]
                    else:
                        out[1-1]=in[1-1:temp[int(temp1-1)]-1+1-1]
                        out[2-1]=in[temp[int(temp1-1)]-1:in.shape[0]+1-1]
    return out
def buildTypeDefLine(typeDefs,i,var_words,want_row,funwords,fortranVarOrRes,MLapp,**kwargs):
    typeDefs=_copy(typeDefs)
    out='struct('
    r=char(10)
    for j in arange(size(typeDefs[i-1,2-1],1),2+1,-1).reshape(1,-1).flat:
        temp=find(strcmp([typeDefs[:,1-1]],typeDefs[i-1,2-1][j-1,3-1]))
        if  not isempty(temp):
            out=m_array([out,"'",typeDefs[i-1,2-1][j-1,1-1],"',",typeDefs[i-1,2-1][j-1,3-1]]).reshape(1,-1)
            if  not isempty(typeDefs[i-1,2-1][j-1,5-1]):
                out=m_array([out,'(ones(']).reshape(1,-1)
                if length(typeDefs[i-1,2-1][j-1,5-1])==1:
                    if want_row:
                        out=m_array([out,'1,',aftC(typeDefs[i-1,2-1][j-1,5-1][1-1])]).reshape(1,-1)
                    else:
                        out=m_array([out,typeDefs[i-1,2-1][j-1,5-1][1-1],',1']).reshape(1,-1)
                else:
                    for k in arange(1,length(typeDefs[i-1,2-1][j-1,5-1])+1).reshape(1,-1).flat:
                        if k==length(typeDefs[i-1,2-1][j-1,5-1]):
                            out=m_array([out,aftC(typeDefs[i-1,2-1][j-1,5-1][k-1])]).reshape(1,-1)
                        else:
                            out=m_array([out,aftC(typeDefs[i-1,2-1][j-1,5-1][k-1]),',']).reshape(1,-1)
                out=m_array([out,'))']).reshape(1,-1)
        else:
            howmany=length(typeDefs[i-1,2-1][j-1,5-1])
            localVar=typeDefs[i-1,2-1]
            temp6=j
            outZ=''
            if  not isempty(typeDefs[i-1,2-1][j-1,11-1]):
                if strcmp(typeDefs[i-1,2-1][j-1,3-1],'character'):
                    outZ=m_array(["''"]).reshape(1,-1)
                else:
                    outZ=m_array(['[]']).reshape(1,-1)
            else:
                if howmany==0:
                    goon=1
                    if  not any(strcmp(localVar[temp6-1,3-1],var_words)):
                        outZ=m_array([localVar[temp6-1,3-1]]).reshape(1,-1)
                        goon=0
                    if strcmp(localVar[temp6-1,3-1],'character'):
                        if ischar(localVar[temp6-1,2-1]):
                            outZ=m_array(["repmat(' ',1,",localVar[temp6-1,2-1],')']).reshape(1,-1)
                        else:
                            outZ=m_array(["''"]).reshape(1,-1)
                        goon=0
                    if strcmp(localVar[temp6-1,3-1],'logical'):
                        outZ=m_array(['false']).reshape(1,-1)
                        goon=0
                    if goon and  not strcmp(localVar[temp6-1,3-1],'character'):
                        outZ=m_array(['0']).reshape(1,-1)
                else:
                    if howmany==1:
                        if  not any(strcmp(localVar[temp6-1,3-1],var_words)):
                            if want_row:
                                outZ=m_array([localVar[temp6-1,3-1],'(ones(1,',aftC(localVar[temp6-1,5-1][1-1]),'))']).reshape(1,-1)
                            else:
                                outZ=m_array([localVar[temp6-1,3-1],'(ones(',aftC(localVar[temp6-1,5-1][1-1]),',1))']).reshape(1,-1)
                        else:
                            if strcmp(localVar[temp6-1,3-1],'character'):
                                outZ=m_array(['{cell(1,',char(aftC(localVar[temp6-1,5-1][1-1])),')}']).reshape(1,-1)
                            else:
                                if want_row:
                                    outZ=m_array(['zeros(1,',aftC(localVar[temp6-1,5-1][1-1]),')']).reshape(1,-1)
                                else:
                                    outZ=m_array(['zeros(',aftC(localVar[temp6-1,5-1][1-1]),',1)']).reshape(1,-1)
                    else:
                        if  not any(strcmp(localVar[temp6-1,3-1],var_words)):
                            subscripts2=m_array([localVar[temp6-1,3-1],'(ones(']).reshape(1,-1)
                        else:
                            subscripts2='zeros('
                        for k in arange(1,howmany+1).reshape(1,-1).flat:
                            if k!=howmany:
                                subscripts2=m_array([subscripts2,aftC(localVar[temp6-1,5-1][k-1]),',']).reshape(1,-1)
                            else:
                                subscripts2=m_array([subscripts2,aftC(localVar[temp6-1,5-1][k-1]),')']).reshape(1,-1)
                        if  not any(strcmp(localVar[temp6-1,3-1],var_words)):
                            subscripts2=m_array([subscripts2[1-1:subscripts2.shape[0]-1+1-1],')']).reshape(1,-1)
                        outZ=m_array([subscripts2]).reshape(1,-1)
            temp5=''
            if any(strcmp(typeDefs[i-1,2-1][j-1,1-1],[funwords[:],[fortranVarOrRes[:]]])):
                temp5=MLapp
                typeDefs[i-1,2-1][j-1,1-1]=m_array([typeDefs[i-1,2-1][j-1,1-1],MLapp]).reshape(1,-1)
            out=m_array([out,"'",typeDefs[i-1,2-1][j-1,1-1],"',",outZ]).reshape(1,-1)
        if j>2:
            out=m_array([out,',...',r]).reshape(1,-1)
    out=m_array([out,')']).reshape(1,-1)
    return out,typeDefs
def aftC(str,**kwargs):
    lastsemi=find(str==':',1,'last')
    if isempty(lastsemi):
        out=str
    else:
        out=str[lastsemi+1-1:str.shape[0]+1-1]
    return out
def caseProtectedML(**kwargs):
    casePML=cell(221,1)
    casePML[1-1]='abs'
    casePML[2-1]='accumarray'
    casePML[3-1]='acos'
    casePML[4-1]='acosd'
    casePML[5-1]='acosh'
    casePML[6-1]='acot'
    casePML[7-1]='acotd'
    casePML[8-1]='acoth'
    casePML[9-1]='acsc'
    casePML[10-1]='acscd'
    casePML[11-1]='acsch'
    casePML[12-1]='addpath'
    casePML[13-1]='angle'
    casePML[14-1]='ans'
    casePML[15-1]='asec'
    casePML[16-1]='asecd'
    casePML[17-1]='asech'
    casePML[18-1]='asin'
    casePML[19-1]='asind'
    casePML[20-1]='asinh'
    casePML[21-1]='atan'
    casePML[22-1]='atan2'
    casePML[23-1]='atand'
    casePML[24-1]='atanh'
    casePML[25-1]='beep'
    casePML[26-1]='binpatch'
    casePML[27-1]='blkdiag'
    casePML[28-1]='calllib'
    casePML[29-1]='cat'
    casePML[30-1]='cd'
    casePML[31-1]='ceil'
    casePML[32-1]='circshift'
    casePML[33-1]='ckdepfun'
    casePML[34-1]='clear'
    casePML[35-1]='compan'
    casePML[36-1]='complex'
    casePML[37-1]='computer'
    casePML[38-1]='conj'
    casePML[39-1]='copyfile'
    casePML[40-1]='cos'
    casePML[41-1]='cosd'
    casePML[42-1]='cosh'
    casePML[43-1]='cot'
    casePML[44-1]='cotd'
    casePML[45-1]='coth'
    casePML[46-1]='cplxpair'
    casePML[47-1]='csc'
    casePML[48-1]='cscd'
    casePML[49-1]='csch'
    casePML[50-1]='delete'
    casePML[51-1]='depdir'
    casePML[52-1]='depfun'
    casePML[53-1]='depfunprophelper'
    casePML[54-1]='desktop'
    casePML[55-1]='diag'
    casePML[56-1]='diary'
    casePML[57-1]='dir'
    casePML[58-1]='dos'
    casePML[59-1]='echo'
    casePML[60-1]='eps'
    casePML[61-1]='exit'
    casePML[62-1]='exp'
    casePML[63-1]='expm1'
    casePML[64-1]='eye'
    casePML[65-1]='false'
    casePML[66-1]='fileattrib'
    casePML[67-1]='find'
    casePML[68-1]='finfo'
    casePML[69-1]='fix'
    casePML[70-1]='flipdim'
    casePML[71-1]='fliplr'
    casePML[72-1]='flipud'
    casePML[73-1]='floor'
    casePML[74-1]='flops'
    casePML[75-1]='format'
    casePML[76-1]='freqspace'
    casePML[77-1]='gallery'
    casePML[78-1]='genpath'
    casePML[79-1]='getenv'
    casePML[80-1]='hadamard'
    casePML[81-1]='hankel'
    casePML[82-1]='hilb'
    casePML[83-1]='hypot'
    casePML[84-1]='i'
    casePML[85-1]='imag'
    casePML[86-1]='import'
    casePML[87-1]='ind2sub'
    casePML[88-1]='inf'
    casePML[89-1]='inmem'
    casePML[90-1]='intmax'
    casePML[91-1]='intmin'
    casePML[92-1]='invhilb'
    casePML[93-1]='ipermute'
    casePML[94-1]='isdeployed'
    casePML[95-1]='isdir'
    casePML[96-1]='isempty'
    casePML[97-1]='isequal'
    casePML[98-1]='isequalwithequalnans'
    casePML[99-1]='isfinite'
    casePML[100-1]='isinf'
    casePML[101-1]='isnan'
    casePML[102-1]='ispc'
    casePML[103-1]='ispuma'
    casePML[104-1]='isreal'
    casePML[105-1]='isscalar'
    casePML[106-1]='isstudent'
    casePML[107-1]='isunix'
    casePML[108-1]='isvector'
    casePML[109-1]='j'
    casePML[110-1]='java'
    casePML[111-1]='javaaddpath'
    casePML[112-1]='javaclasspath'
    casePML[113-1]='javarmpath'
    casePML[114-1]='length'
    casePML[115-1]='libfunctions'
    casePML[116-1]='libfunctionsview'
    casePML[117-1]='libisloaded'
    casePML[118-1]='libpointer'
    casePML[119-1]='libstruct'
    casePML[120-1]='linspace'
    casePML[121-1]='load'
    casePML[122-1]='loadlibrary'
    casePML[123-1]='log'
    casePML[124-1]='log10'
    casePML[125-1]='log1p'
    casePML[126-1]='log2'
    casePML[127-1]='logspace'
    casePML[128-1]='ls'
    casePML[129-1]='magic'
    casePML[130-1]='matlabpath'
    casePML[131-1]='memory'
    casePML[132-1]='meshgrid'
    casePML[133-1]='mex'
    casePML[134-1]='mex_helper'
    casePML[135-1]='mexdebug'
    casePML[136-1]='mkdir'
    casePML[137-1]='mod'
    casePML[138-1]='more'
    casePML[139-1]='movefile'
    casePML[140-1]='namelengthmax'
    casePML[141-1]='nan'
    casePML[142-1]='ndgrid'
    casePML[143-1]='ndims'
    casePML[144-1]='nextpow2'
    casePML[145-1]='nthroot'
    casePML[146-1]='numel'
    casePML[147-1]='ones'
    casePML[148-1]='open'
    casePML[149-1]='pack'
    casePML[150-1]='pascal'
    casePML[151-1]='path'
    casePML[152-1]='path2rc'
    casePML[153-1]='pcode'
    casePML[154-1]='perl'
    casePML[155-1]='permute'
    casePML[156-1]='pi'
    casePML[157-1]='pow2'
    casePML[158-1]='preferences'
    casePML[159-1]='prepender'
    casePML[160-1]='pwd'
    casePML[161-1]='quit'
    casePML[162-1]='rand'
    casePML[163-1]='randn'
    casePML[164-1]='real'
    casePML[165-1]='reallog'
    casePML[166-1]='realmax'
    casePML[167-1]='realmin'
    casePML[168-1]='realpow'
    casePML[169-1]='realsqrt'
    casePML[170-1]='recycle'
    casePML[171-1]='rehash'
    casePML[172-1]='rem'
    casePML[173-1]='repmat'
    casePML[174-1]='reshape'
    casePML[175-1]='rmdir'
    casePML[176-1]='rmpath'
    casePML[177-1]='rosser'
    casePML[178-1]='rot90'
    casePML[179-1]='round'
    casePML[180-1]='save'
    casePML[181-1]='saveas'
    casePML[182-1]='savepath'
    casePML[183-1]='sec'
    casePML[184-1]='secd'
    casePML[185-1]='sech'
    casePML[186-1]='setenv'
    casePML[187-1]='shiftdim'
    casePML[188-1]='sign'
    casePML[189-1]='sin'
    casePML[190-1]='sind'
    casePML[191-1]='sinh'
    casePML[192-1]='size'
    casePML[193-1]='sqrt'
    casePML[194-1]='squeeze'
    casePML[195-1]='sub2ind'
    casePML[196-1]='syntax'
    casePML[197-1]='system'
    casePML[198-1]='tan'
    casePML[199-1]='tand'
    casePML[200-1]='tanh'
    casePML[201-1]='toeplitz'
    casePML[202-1]='toolboxdir'
    casePML[203-1]='tril'
    casePML[204-1]='triu'
    casePML[205-1]='true'
    casePML[206-1]='type'
    casePML[207-1]='unix'
    casePML[208-1]='unloadlibrary'
    casePML[209-1]='unwrap'
    casePML[210-1]='usejava'
    casePML[211-1]='vander'
    casePML[212-1]='ver'
    casePML[213-1]='what'
    casePML[214-1]='which'
    casePML[215-1]='who'
    casePML[216-1]='whos'
    casePML[217-1]='why'
    casePML[218-1]='wilkinson'
    casePML[219-1]='xgetselection'
    casePML[220-1]='xsetselection'
    casePML[221-1]='zeros'
    return casePML
def changeoperator_f(i,operator,loc,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,fortranfunwords,formats,localVar,typeDefs,var_words,**kwargs):
    funstr=_copy(funstr)
    nif=cell(2,1)
    neednif=0
    r=char(10)
    changedflag=0
    argDelin=zeros(1,4)
    temp=find( not isspace(funstr[i-1])&funstr[i-1]!='-'&funstr[i-1]!='+')
    temp=temp[int(temp>(loc+length(operator)-1)-1)]
    temp=temp[int(1-1)]
    temp1=strcmp("'",operator[int(length(operator)-1)])
    leftarg_b=0
    leftarg_e=0
    rightarg_b=0
    rightarg_e=0
    if  not temp1:
        if isnameletter(funstr[i-1][int(temp-1)])|length(find(temp==funstrwords_b[i-1]))>0:
            temp2=find(funstrwords_b[i-1]==temp)
            howmany,subscripts,centercomma,parens=hassubscript_f(i,temp2,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,nargout=4)
            if  not isempty(parens):
                rightarg_b=temp
                rightarg_e=parens[int(2-1)]
                temp7=nextNonSpace(funstr[i-1],rightarg_e)
                if funstr[i-1][int(temp7-1)]=='(':
                    rightarg_e=findrights_f(temp7,funstr[i-1])
            else:
                rightarg_b=temp
                rightarg_e=funstrwords_e[i-1][int(temp2-1)]
            for iii in arange(1,10+1).reshape(1,-1).flat:
                if length(funstr[i-1])>rightarg_e and funstr[i-1][int(rightarg_e+1-1)]=='.' and isnameletter(funstr[i-1][int(rightarg_e+2-1)]):
                    temp=rightarg_e+2
                    temp2=find(funstrwords_b[i-1]==temp)
                    if  not strcmp(funstrwords[i-1][temp2-1],'not'):
                        howmany,subscripts,centercomma,parens=hassubscript_f(i,temp2,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,nargout=4)
                        if  not isempty(parens):
                            rightarg_e=parens[int(2-1)]
                        else:
                            rightarg_e=funstrwords_e[i-1][int(temp2-1)]
        else:
            if isnumber(funstr[i-1][int(temp-1)])|any(funstrnumbers_b[i-1]==temp):
                temp2=find(funstrnumbers_b[i-1]>=temp)
                temp2=temp2[int(1-1)]
                rightarg_b=temp
                rightarg_e=funstrnumbers_e[i-1][int(temp2-1)]
            else:
                if ((strcmp(funstr[i-1][int(temp-1)],'('))|(strcmp(funstr[i-1][int(temp-1)],'['))|(strcmp(funstr[i-1][int(temp-1)],'{'))):
                    rightarg_b=temp
                    rightarg_e=findrights_f(temp,funstr[i-1],1)
                else:
                    if ((strcmp(funstr[i-1][int(temp-1)],"'"))):
                        rightarg_b=temp
                        temp2=find(funstr[i-1]=="'")
                        temp2=temp2[int(temp2>temp-1)]
                        rightarg_e=temp2[int(1-1)]
                    else:
                        rightarg_b=temp+1
                        rightarg_e=temp
    temp=find( not isspace(funstr[i-1]))
    temp=temp[int(temp<loc-1)]
    temp=temp[int(length(temp)-1)]
    if length(find(temp==funstrnumbers_e[i-1]))>0:
        temp2=find(funstrnumbers_e[i-1]==temp)
        leftarg_e=temp
        leftarg_b=funstrnumbers_b[i-1][int(temp2-1)]
    else:
        if length(find(temp==funstrwords_e[i-1]))>0:
            temp2=find(funstrwords_e[i-1]==temp)
            leftarg_e=temp
            leftarg_b=funstrwords_b[i-1][int(temp2-1)]
            for iii in arange(1,10+1).reshape(1,-1).flat:
                if leftarg_b>1 and funstr[i-1][int(leftarg_b-1-1)]=='.':
                    temp=find( not isspace(funstr[i-1]))
                    temp=temp[int(temp<(leftarg_b-1)-1)]
                    temp=temp[int(length(temp)-1)]
                    if strcmp(funstr[i-1][int(temp-1)],')'):
                        leftparen=findlefts_f(temp,funstr[i-1])
                        if length(find(funstrwords_e[i-1]==(leftparen-1)))>0:
                            temp2=find(funstrwords_e[i-1]==(leftparen-1))
                            leftarg_b=funstrwords_b[i-1][int(temp2-1)]
                        else:
                            leftarg_b=leftparen
                    else:
                        if length(find(temp==funstrwords_e[i-1]))>0:
                            temp2=find(funstrwords_e[i-1]==temp)
                            if  not strcmp(funstrwords[i-1][temp2-1],'not'):
                                leftarg_b=funstrwords_b[i-1][int(temp2-1)]
        else:
            if ((strcmp(funstr[i-1][int(temp-1)],')'))|(strcmp(funstr[i-1][int(temp-1)],']'))|(strcmp(funstr[i-1][int(temp-1)],'}'))):
                leftarg_e=temp
                leftparen=findlefts_f(temp,funstr[i-1])
                if funstr[i-1][int(leftparen-1-1)]==')':
                    leftparen=findlefts_f(leftparen-1,funstr[i-1])
                if length(find(funstrwords_e[i-1]==(leftparen-1)))>0:
                    temp2=find(funstrwords_e[i-1]==(leftparen-1))
                    leftarg_b=funstrwords_b[i-1][int(temp2-1)]
                    for iii in arange(1,10+1).reshape(1,-1).flat:
                        if leftarg_b>1 and funstr[i-1][int(leftarg_b-1-1)]=='.':
                            temp=find( not isspace(funstr[i-1]))
                            temp=temp[int(temp<(leftarg_b-1)-1)]
                            temp=temp[int(length(temp)-1)]
                            if strcmp(funstr[i-1][int(temp-1)],')'):
                                leftparen=findlefts_f(temp,funstr[i-1])
                                if length(find(funstrwords_e[i-1]==(leftparen-1)))>0:
                                    temp2=find(funstrwords_e[i-1]==(leftparen-1))
                                    leftarg_b=funstrwords_b[i-1][int(temp2-1)]
                                else:
                                    leftarg_b=leftparen
                            else:
                                if length(find(temp==funstrwords_e[i-1]))>0:
                                    temp2=find(funstrwords_e[i-1]==temp)
                                    if  not strcmp(funstrwords[i-1][temp2-1],'not'):
                                        leftarg_b=funstrwords_b[i-1][int(temp2-1)]
                else:
                    leftarg_b=leftparen
            else:
                if ((strcmp(funstr[i-1][int(temp-1)],"'"))):
                    leftarg_e=temp
                    temp2=find(funstr[i-1]=="'")
                    temp2=temp2[int(temp2<temp-1)]
                    leftarg_b=temp2[int(temp2.shape[0]-1)]
                else:
                    leftarg_b=temp+1
                    leftarg_e=temp
    argDelin=m_array([leftarg_b,leftarg_e,rightarg_b,rightarg_e]).reshape(1,-1)
    if  not temp1:
        goon=0
        temp4=find(funstrwords_b[i-1]>=leftarg_b&funstrwords_b[i-1]<=leftarg_e)
        if  not isempty(temp4):
            temp4=temp4[int(1-1)]
            temp5=varType(i,temp4,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,localVar,typeDefs,var_words)
            if strcmp(temp5,'character'):
                goon=1
        temp4=find(funstrwords_b[i-1]>=rightarg_b&funstrwords_b[i-1]<=rightarg_e)
        if  not isempty(temp4):
            temp4=temp4[int(1-1)]
            temp5=varType(i,temp4,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,localVar,typeDefs,var_words)
            if strcmp(temp5,'character'):
                goon=1
        if ['==','~=']==operator:
            if funstr[i-1][int(leftarg_b-1)]=="'"|funstr[i-1][int(rightarg_b-1)]=="'"|goon:
                temp6=''
                if operator[int(1-1)]=='~':
                    temp6='~'
                if (all(isspace(funstr[i-1][rightarg_b+1-1:rightarg_e-1+1-1]))&length(arange(rightarg_b+1,rightarg_e-1+1).reshape(1,-1))>0)|strcmpi(funstr[i-1][rightarg_b-1:rightarg_e+1-1],"''"):
                    funstr[i-1]=m_array([funstr[i-1][1-1:(leftarg_b-1)+1-1],temp6,'isempty(strtrim(',funstr[i-1][leftarg_b-1:leftarg_e+1-1],'))',funstr[i-1][(rightarg_e+1)-1:funstr[i-1].shape[0]+1-1]]).reshape(1,-1)
                else:
                    funstr[i-1]=m_array([funstr[i-1][1-1:(leftarg_b-1)+1-1],temp6,'strcmp(deblank(',funstr[i-1][leftarg_b-1:leftarg_e+1-1],'),deblank(',funstr[i-1][rightarg_b-1:rightarg_e+1-1],'))',funstr[i-1][(rightarg_e+1)-1:funstr[i-1].shape[0]+1-1]]).reshape(1,-1)
                changedflag=1
        else:
            if ['<','>','<=','>=']==operator:
                if funstr[i-1][int(loc-1-1)]!='=' and length(funstrwords[i-1])>0 and any(strcmp(funstrwords[i-1][1-1],['if','elseif'])):
                    if funstr[i-1][int(leftarg_b-1)]=="'"|funstr[i-1][int(rightarg_b-1)]=="'"|goon:
                        funstr[i-1]=m_array([funstr[i-1][1-1:(leftarg_b-1)+1-1],'strrel(',funstr[i-1][leftarg_b-1:leftarg_e+1-1],',',funstr[i-1][rightarg_b-1:rightarg_e+1-1],",'",funstr[i-1][loc-1:loc+length(operator)-1+1-1],"')",funstr[i-1][(rightarg_e+1)-1:funstr[i-1].shape[0]+1-1]]).reshape(1,-1)
                        changedflag=1
    return changedflag,funstr,argDelin
def dispback(str,**kwargs):
    fprintf(1,m_array([str,repmat(char(8),1,length(str))]).reshape(1,-1))
    return 
def empt0(in,**kwargs):
    out=in
    if isempty(out):
        out=0
    return out
def f2mWarning(str,funstr,nLine,loc,**kwargs):
    disp(str)
    disp(funstr[nLine-1])
    disp(m_array([repmat(' ',1,loc-1),'^']).reshape(1,-1))
    return 
def findNext(loc,str,funstr,direction,**kwargs):
    if nargin()<4:
        direction=1
    if direction==1:
        found=strfind(funstr,str)
        if isempty(found):
            out=-1
            return out
        found=found[int(found>loc-1)]
        if isempty(found):
            out=-1
            return out
        out=found[int(1-1)]
    else:
        found=strfind(funstr,str)
        if isempty(found):
            out=-1
            return out
        found=found[int(found<loc-1)]
        if isempty(found):
            out=-1
            return out
        out=found[int(found.shape[0]-1)]
    return out
def findNextWord(linenum,str,linenumStop,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,**kwargs):
    if isempty(linenumStop):
        linenumStop=length(funstr)
    linOut=0
    wordOut=0
    goon=1
    direct=1
    if linenumStop<linenum:
        direct=-1
    for i in arange(linenum,linenumStop+1,direct).reshape(1,-1).flat:
        if goon:
            for j in arange(1,length(funstrwords[i-1])+1).reshape(1,-1).flat:
                if strcmp(funstrwords[i-1][j-1],str):
                    if  not inastring_f(funstr[i-1],funstrwords_b[i-1][int(j-1)])& not incomment(funstr[i-1],funstrwords_b[i-1][int(j-1)]):
                        linOut=i
                        wordOut=j
                        goon=0
                        break
    return linOut,wordOut
def fix_concats(str,loc,funstr,funstrwords,funstrwords_b,funstrwords_e,funstrnumbers,funstrnumbers_b,funstrnumbers_e,fs_good,i,funwords,fortranfunwords,formats,localVar,typeDefs,var_words,**kwargs):
    temp=find( not isspace(str))
    beforeloc=temp[int(temp<loc-1)]
    beforeloc=beforeloc[int(beforeloc.shape[0]-1)]
    afterloc=temp[int(temp>(loc+1)-1)]
    afterloc=afterloc[int(1-1)]
    leftedge=m_array()
    rightedge=m_array()
    funstr[i-1]
    funstr[i-1][1-1:loc+1+1-1]
    changedflag,tempstr,argDelin=changeoperator_f(i,'//',loc,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,fortranfunwords,formats,localVar,typeDefs,var_words,nargout=3)
    funstr[i-1][argDelin[int(1-1)]-1:argDelin[int(2-1)]+1-1]
    funstr[i-1][argDelin[int(3-1)]-1:argDelin[int(4-1)]+1-1]
    'cccccccccccc'
    kb()
    if "'"==str[int(beforeloc-1-1-1)]:
        found=0
        numfound=0
        for ii in arange(beforeloc-1,1+1,-1).reshape(1,-1).flat:
            if  not found:
                if str[int(ii-1)]=="'":
                    numfound=numfound+1
                    if ii==1:
                        leftedge=1
                        found=1
                    if str[int(ii-1-1)]!="'"&mod(numfound,2)==1:
                        leftedge=ii
                        found=1
    else:
        if ']'==str[int(beforeloc-1-1-1)]:
            leftedge=findlefts_f(beforeloc,str)
        else:
            if ')'==str[int(beforeloc-1-1-1)]:
                leftedge=findlefts_f(beforeloc,str)
                beforeLE=temp[int(temp<leftedge-1)]
                temp1=find(funstrwords_e[i-1]==beforeLE[int(beforeLE.shape[0]-1)])
                if  not isempty(temp1):
                    changedflag,tempstr,argDelin=changeoperator_f(i,'//',loc,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,fortranfunwords,formats,localVar,typeDefs,var_words,nargout=3)
                    leftedge=argDelin[int(1-1)]
            else:
                changedflag,tempstr,argDelin=changeoperator_f(i,'//',loc,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,fortranfunwords,formats,localVar,typeDefs,var_words,nargout=3)
                leftedge=argDelin[int(1-1)]
    if "'"==str[int(afterloc-1-1-1)]:
        found=0
        numfound=0
        for ii in arange(afterloc+1,length(str)+1).reshape(1,-1).flat:
            if  not found:
                if str[int(ii-1)]=="'":
                    numfound=numfound+1
                    if ii==length(str):
                        rightedge=1
                        found=1
                    if str[int(ii+1-1)]!="'"&mod(numfound,2)==1:
                        rightedge=ii
                        found=1
    else:
        if '['==str[int(afterloc-1-1-1)]:
            rightedge=findrights_f(afterloc,str)
        else:
            if '('==str[int(afterloc-1-1-1)]:
                rightedge=findrights_f(afterloc,str)
            else:
                changedflag,tempstr,argDelin=changeoperator_f(i,'//',loc,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,fortranfunwords,formats,localVar,typeDefs,var_words,nargout=3)
                rightedge=argDelin[int(4-1)]
    str=m_array([str[1-1:leftedge-1+1-1],'[',str[leftedge-1:beforeloc+1-1],',',str[afterloc-1:rightedge+1-1],']',str[rightedge+1-1:str.shape[0]+1-1]]).reshape(1,-1)
    return str
def fixMultiStatementLines(funstr,funstrwords,funstrwords_b,funstrwords_e,funstrnumbers,funstrnumbers_b,funstrnumbers_e,fs_good,funwords,filename,varPrefix,shapeVar,origVar,**kwargs):
    funstr=_copy(funstr)
    for i in fliplr(fs_good).flat:
        temp=strfind(funstr[i-1],';')
        if length(temp>1):
            for j in arange(length(temp),1+1,-1).reshape(1,-1).flat:
                if length(funstrwords[i-1])>0 and isempty(strfind(funstr[i-1],varPrefix)) and isempty(regexp(funstr[i-1],m_array([shapeVar,'\\>']).reshape(1,-1))) and isempty(regexp(funstr[i-1],m_array([origVar,'\\>']).reshape(1,-1))) and validSpot(funstr[i-1],temp[int(j-1)]) and inwhichlast_f(i,temp[int(j-1)],funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,filename)==0:
                    temp1=find( not isspace(funstr[i-1]))
                    if temp[int(j-1)]!=temp1[int(temp1.shape[0]-1)]:
                        funstr[i+1-1:funstr.shape[0]+1+1-1]=deal(funstr[i-1:funstr.shape[0]+1-1],nargout=1)
                        funstr[i-1]=funstr[i-1][1-1:temp[int(j-1)]+1-1]
                        funstr[i+1-1]=funstr[i+1-1][temp[int(j-1)]+1-1:funstr[i+1-1].shape[0]+1-1]
    return funstr
def fixNotOperator(i,loc,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,fortranfunwords,formats,localVar,logicalops,typeDefs,var_words,**kwargs):
    funstr=_copy(funstr)
    logicalops=logicalops[m_array([1,arange(4,10+1).reshape(1,-1)]).reshape(1,-1)-1,:]
    changedflag=1
    goonimag=0
    goon=1
    temp=nextNonSpace(funstr[i-1],loc+4)
    if  not isempty(temp):
        temp1=find(funstrwords_b[i-1]==temp[int(1-1)])
        if  not isempty(temp1):
            temp2=find(strcmp([localVar[:,1-1]],funstrwords[i-1][temp1[int(1-1)]-1]))
            if  not isempty(temp2):
                if strcmp(localVar[temp2[int(1-1)]-1,3-1],'logical'):
                    funstr[i-1]=m_array([funstr[i-1][1-1:loc-1+1-1],'~',funstr[i-1][loc+5-1:funstr[i-1].shape[0]+1-1]]).reshape(1,-1)
                    goonimag=1
                    goon=0
    if goon:
        l_p=funstr[i-1]=='('
        r_p=funstr[i-1]==')'
        c_p=cumsum(l_p-r_p)
        a,b=regexp(funstr[i-1],[logicalops[:,2-1]],'start','end',nargout=2)
        if any( not cellfun('isempty',a)):
            for j in arange(1,length(a)+1).reshape(1,-1).flat:
                if  not isempty(a[j-1]):
                    if c_p[int(loc-1)]==c_p[int(a[j-1][int(1-1)]-1)]:
                        tempflag,dummy,delims=changeoperator_f(i,logicalops[j-1,2-1],a[j-1][int(1-1)],funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,fortranfunwords,formats,localVar,typeDefs,var_words,nargout=3)
                        if all(delims):
                            if delims[int(1-1)]==temp:
                                goonimag=1
                                funstr[i-1]=m_array([funstr[i-1][1-1:loc-1+1-1],'~',funstr[i-1][loc+5-1:delims[int(1-1)]-1+1-1],'(',funstr[i-1][delims[int(1-1)]-1:delims[int(4-1)]+1-1],')',funstr[i-1][delims[int(4-1)]+1-1:funstr[i-1].shape[0]+1-1]]).reshape(1,-1)
                        break
    if  not goonimag:
        tempflag,dummy,delims=changeoperator_f(i,'.not.',loc,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,fortranfunwords,formats,localVar,typeDefs,var_words,nargout=3)
        if delims[int(1-1)]==0 and delims[int(2-1)]==0 and delims[int(3-1)]!=0 and delims[int(4-1)]!=0:
            funstr[i-1]=m_array([funstr[i-1][1-1:loc-1+1-1],'~',funstr[i-1][loc+5-1:delims[int(3-1)]-1+1-1],'(',funstr[i-1][delims[int(3-1)]-1:delims[int(4-1)]+1-1],')',funstr[i-1][delims[int(4-1)]+1-1:funstr[i-1].shape[0]+1-1]]).reshape(1,-1)
        else:
            funstr[i-1]=m_array([funstr[i-1][1-1:loc-1+1-1],'~',funstr[i-1][loc+5-1:funstr[i-1].shape[0]+1-1]]).reshape(1,-1)
    return changedflag,funstr
def getarg(n,argStr,status,**kwargs):
    global GlobInArgs,nargs
    if n<0 or n>nargs:
        argStr=''
        status=-1
    else:
        argStr=GlobInArgs[n+1-1]
        status=length(argStr)
    return argStr,status
def getCaseProtectedML(**kwargs):
    casePML=cell(221,1)
    casePML[1-1]='abs'
    casePML[2-1]='accumarray'
    casePML[3-1]='acos'
    casePML[4-1]='acosd'
    casePML[5-1]='acosh'
    casePML[6-1]='acot'
    casePML[7-1]='acotd'
    casePML[8-1]='acoth'
    casePML[9-1]='acsc'
    casePML[10-1]='acscd'
    casePML[11-1]='acsch'
    casePML[12-1]='addpath'
    casePML[13-1]='angle'
    casePML[14-1]='ans'
    casePML[15-1]='asec'
    casePML[16-1]='asecd'
    casePML[17-1]='asech'
    casePML[18-1]='asin'
    casePML[19-1]='asind'
    casePML[20-1]='asinh'
    casePML[21-1]='atan'
    casePML[22-1]='atan2'
    casePML[23-1]='atand'
    casePML[24-1]='atanh'
    casePML[25-1]='beep'
    casePML[26-1]='binpatch'
    casePML[27-1]='blkdiag'
    casePML[28-1]='calllib'
    casePML[29-1]='cat'
    casePML[30-1]='cd'
    casePML[31-1]='ceil'
    casePML[32-1]='circshift'
    casePML[33-1]='ckdepfun'
    casePML[34-1]='clear'
    casePML[35-1]='compan'
    casePML[36-1]='complex'
    casePML[37-1]='computer'
    casePML[38-1]='conj'
    casePML[39-1]='copyfile'
    casePML[40-1]='cos'
    casePML[41-1]='cosd'
    casePML[42-1]='cosh'
    casePML[43-1]='cot'
    casePML[44-1]='cotd'
    casePML[45-1]='coth'
    casePML[46-1]='cplxpair'
    casePML[47-1]='csc'
    casePML[48-1]='cscd'
    casePML[49-1]='csch'
    casePML[50-1]='delete'
    casePML[51-1]='depdir'
    casePML[52-1]='depfun'
    casePML[53-1]='depfunprophelper'
    casePML[54-1]='desktop'
    casePML[55-1]='diag'
    casePML[56-1]='diary'
    casePML[57-1]='dir'
    casePML[58-1]='dos'
    casePML[59-1]='echo'
    casePML[60-1]='eps'
    casePML[61-1]='exit'
    casePML[62-1]='exp'
    casePML[63-1]='expm1'
    casePML[64-1]='eye'
    casePML[65-1]='false'
    casePML[66-1]='fileattrib'
    casePML[67-1]='find'
    casePML[68-1]='finfo'
    casePML[69-1]='fix'
    casePML[70-1]='flipdim'
    casePML[71-1]='fliplr'
    casePML[72-1]='flipud'
    casePML[73-1]='floor'
    casePML[74-1]='flops'
    casePML[75-1]='format'
    casePML[76-1]='freqspace'
    casePML[77-1]='gallery'
    casePML[78-1]='genpath'
    casePML[79-1]='getenv'
    casePML[80-1]='hadamard'
    casePML[81-1]='hankel'
    casePML[82-1]='hilb'
    casePML[83-1]='hypot'
    casePML[84-1]='i'
    casePML[85-1]='imag'
    casePML[86-1]='import'
    casePML[87-1]='ind2sub'
    casePML[88-1]='inf'
    casePML[89-1]='inmem'
    casePML[90-1]='intmax'
    casePML[91-1]='intmin'
    casePML[92-1]='invhilb'
    casePML[93-1]='ipermute'
    casePML[94-1]='isdeployed'
    casePML[95-1]='isdir'
    casePML[96-1]='isempty'
    casePML[97-1]='isequal'
    casePML[98-1]='isequalwithequalnans'
    casePML[99-1]='isfinite'
    casePML[100-1]='isinf'
    casePML[101-1]='isnan'
    casePML[102-1]='ispc'
    casePML[103-1]='ispuma'
    casePML[104-1]='isreal'
    casePML[105-1]='isscalar'
    casePML[106-1]='isstudent'
    casePML[107-1]='isunix'
    casePML[108-1]='isvector'
    casePML[109-1]='j'
    casePML[110-1]='java'
    casePML[111-1]='javaaddpath'
    casePML[112-1]='javaclasspath'
    casePML[113-1]='javarmpath'
    casePML[114-1]='length'
    casePML[115-1]='libfunctions'
    casePML[116-1]='libfunctionsview'
    casePML[117-1]='libisloaded'
    casePML[118-1]='libpointer'
    casePML[119-1]='libstruct'
    casePML[120-1]='linspace'
    casePML[121-1]='load'
    casePML[122-1]='loadlibrary'
    casePML[123-1]='log'
    casePML[124-1]='log10'
    casePML[125-1]='log1p'
    casePML[126-1]='log2'
    casePML[127-1]='logspace'
    casePML[128-1]='ls'
    casePML[129-1]='magic'
    casePML[130-1]='matlabpath'
    casePML[131-1]='memory'
    casePML[132-1]='meshgrid'
    casePML[133-1]='mex'
    casePML[134-1]='mex_helper'
    casePML[135-1]='mexdebug'
    casePML[136-1]='mkdir'
    casePML[137-1]='mod'
    casePML[138-1]='more'
    casePML[139-1]='movefile'
    casePML[140-1]='namelengthmax'
    casePML[141-1]='nan'
    casePML[142-1]='ndgrid'
    casePML[143-1]='ndims'
    casePML[144-1]='nextpow2'
    casePML[145-1]='nthroot'
    casePML[146-1]='numel'
    casePML[147-1]='ones'
    casePML[148-1]='open'
    casePML[149-1]='pack'
    casePML[150-1]='pascal'
    casePML[151-1]='path'
    casePML[152-1]='path2rc'
    casePML[153-1]='pcode'
    casePML[154-1]='perl'
    casePML[155-1]='permute'
    casePML[156-1]='pi'
    casePML[157-1]='pow2'
    casePML[158-1]='preferences'
    casePML[159-1]='prepender'
    casePML[160-1]='pwd'
    casePML[161-1]='quit'
    casePML[162-1]='rand'
    casePML[163-1]='randn'
    casePML[164-1]='real'
    casePML[165-1]='reallog'
    casePML[166-1]='realmax'
    casePML[167-1]='realmin'
    casePML[168-1]='realpow'
    casePML[169-1]='realsqrt'
    casePML[170-1]='recycle'
    casePML[171-1]='rehash'
    casePML[172-1]='rem'
    casePML[173-1]='repmat'
    casePML[174-1]='reshape'
    casePML[175-1]='rmdir'
    casePML[176-1]='rmpath'
    casePML[177-1]='rosser'
    casePML[178-1]='rot90'
    casePML[179-1]='round'
    casePML[180-1]='save'
    casePML[181-1]='saveas'
    casePML[182-1]='savepath'
    casePML[183-1]='sec'
    casePML[184-1]='secd'
    casePML[185-1]='sech'
    casePML[186-1]='setenv'
    casePML[187-1]='shiftdim'
    casePML[188-1]='sign'
    casePML[189-1]='sin'
    casePML[190-1]='sind'
    casePML[191-1]='sinh'
    casePML[192-1]='size'
    casePML[193-1]='sqrt'
    casePML[194-1]='squeeze'
    casePML[195-1]='sub2ind'
    casePML[196-1]='syntax'
    casePML[197-1]='system'
    casePML[198-1]='tan'
    casePML[199-1]='tand'
    casePML[200-1]='tanh'
    casePML[201-1]='toeplitz'
    casePML[202-1]='toolboxdir'
    casePML[203-1]='tril'
    casePML[204-1]='triu'
    casePML[205-1]='true'
    casePML[206-1]='type'
    casePML[207-1]='unix'
    casePML[208-1]='unloadlibrary'
    casePML[209-1]='unwrap'
    casePML[210-1]='usejava'
    casePML[211-1]='vander'
    casePML[212-1]='ver'
    casePML[213-1]='what'
    casePML[214-1]='which'
    casePML[215-1]='who'
    casePML[216-1]='whos'
    casePML[217-1]='why'
    casePML[218-1]='wilkinson'
    casePML[219-1]='xgetselection'
    casePML[220-1]='xsetselection'
    casePML[221-1]='zeros'
    funwordsML=getfunwordsonlyML()
    casePML=[casePML[:],funwordsML[:]]
    return casePML
def getExtraFunctions(extraFunctions,**kwargs):
    out=''
    r=char(10)
    if any(extraFunctions==1):
        out=m_array([out,' function tf = strlexcmp(a, b)',r]).reshape(1,-1)
        out=m_array([out,'%STRLEXCMP Lexicographic comparison of two strings.',r]).reshape(1,-1)
        out=m_array([out,'%',r]).reshape(1,-1)
        out=m_array([out,'%   STRLEXCMP(A, B) returns -1, 0, or 1 depending on whether the left argument',r]).reshape(1,-1)
        out=m_array([out,'%   is stringwise less than, equal to, or greater than the right argument.',r]).reshape(1,-1)
        out=m_array([out,'%',r]).reshape(1,-1)
        out=m_array([out,"%   This is a MATLAB version of the Perl `cmp' operator.",r]).reshape(1,-1)
        out=m_array([out,'%',r]).reshape(1,-1)
        out=m_array([out,'%   See also EQ, ISEQUAL.',r]).reshape(1,-1)
        out=m_array([out,'',r]).reshape(1,-1)
        out=m_array([out,'%   Author:      Peter J. Acklam',r]).reshape(1,-1)
        out=m_array([out,'%   Time-stamp:  2004-09-22 19:49:47 +0200',r]).reshape(1,-1)
        out=m_array([out,'%   E-mail:      pjacklam@online.no',r]).reshape(1,-1)
        out=m_array([out,'%   URL:         http://home.online.no/~pjacklam',r]).reshape(1,-1)
        out=m_array([out,'',r]).reshape(1,-1)
        out=m_array([out,'   % check arguments',r]).reshape(1,-1)
        out=m_array([out,'   error(nargchk(2, 2, nargin));',r]).reshape(1,-1)
        out=m_array([out,'   if ~ischar(a) || ~ischar(b)',r]).reshape(1,-1)
        out=m_array([out,"      error('Both arguments must be char arrays (strings).');",r]).reshape(1,-1)
        out=m_array([out,'   end',r]).reshape(1,-1)
        out=m_array([out,'',r]).reshape(1,-1)
        out=m_array([out,'   % get lengths of strings',r]).reshape(1,-1)
        out=m_array([out,'   na = length(a);',r]).reshape(1,-1)
        out=m_array([out,'   nb = length(b);',r]).reshape(1,-1)
        out=m_array([out,'   n = min(na, nb);',r]).reshape(1,-1)
        out=m_array([out,'',r]).reshape(1,-1)
        out=m_array([out,'   % find characters that differ',r]).reshape(1,-1)
        out=m_array([out,'   k = find(a(1:n) ~= b(1:n));',r]).reshape(1,-1)
        out=m_array([out,'   if isempty(k)',r]).reshape(1,-1)
        out=m_array([out,'      % all characters are identical -- compare lengths',r]).reshape(1,-1)
        out=m_array([out,'      tf = sign(na - nb);',r]).reshape(1,-1)
        out=m_array([out,'   else',r]).reshape(1,-1)
        out=m_array([out,'      % compare first character that is different',r]).reshape(1,-1)
        out=m_array([out,'      k = k(1);',r]).reshape(1,-1)
        out=m_array([out,'      tf = sign(a(k) - b(k));',r]).reshape(1,-1)
        out=m_array([out,'   end',r]).reshape(1,-1)
        out=m_array([out,' end',r]).reshape(1,-1)
    return out
def getfunwordsonly(**kwargs):
    funwords=cell(315,1)
    funwords[1-1]='abs'
    funwords[2-1]='iabs'
    funwords[3-1]='jiabs'
    funwords[4-1]='habs'
    funwords[5-1]='iiabs'
    funwords[6-1]='babs1'
    funwords[7-1]='dabs'
    funwords[8-1]='cabs'
    funwords[9-1]='zabs'
    funwords[10-1]='cdabs'
    funwords[11-1]='qabs'
    funwords[12-1]='achar'
    funwords[13-1]='acos'
    funwords[14-1]='dacos'
    funwords[15-1]='qacos'
    funwords[16-1]='acosd'
    funwords[17-1]='dacosd'
    funwords[18-1]='qacosd'
    funwords[19-1]='adjustl'
    funwords[20-1]='adjustr'
    funwords[21-1]='acosh'
    funwords[22-1]='dacosh'
    funwords[23-1]='qacosh'
    funwords[24-1]='imag'
    funwords[25-1]='aimag'
    funwords[26-1]='dimag'
    funwords[27-1]='qimag'
    funwords[28-1]='aint'
    funwords[29-1]='dint'
    funwords[30-1]='ddint'
    funwords[31-1]='qint'
    funwords[32-1]='all'
    funwords[33-1]='allocated'
    funwords[34-1]='anint'
    funwords[35-1]='dnint'
    funwords[36-1]='qnint'
    funwords[37-1]='any'
    funwords[38-1]='asin'
    funwords[39-1]='dasin'
    funwords[40-1]='qasin'
    funwords[41-1]='asinh'
    funwords[42-1]='dasinh'
    funwords[43-1]='qasinh'
    funwords[44-1]='asind'
    funwords[45-1]='dasind'
    funwords[46-1]='qasind'
    funwords[47-1]='asm'
    funwords[48-1]='associated'
    funwords[49-1]='atan'
    funwords[50-1]='datan'
    funwords[51-1]='qatan'
    funwords[52-1]='atand'
    funwords[53-1]='datand'
    funwords[54-1]='qatand'
    funwords[55-1]='atanh'
    funwords[56-1]='datanh'
    funwords[57-1]='qatanh'
    funwords[58-1]='atan2'
    funwords[59-1]='datan2'
    funwords[60-1]='qatan2'
    funwords[61-1]='atan2d'
    funwords[62-1]='datan2d'
    funwords[63-1]='qatan2d'
    funwords[64-1]='bit'
    funwords[65-1]='btest'
    funwords[66-1]='ceiling'
    funwords[67-1]='char'
    funwords[68-1]='cmplx'
    funwords[69-1]='conjg'
    funwords[70-1]='dconjg'
    funwords[71-1]='cos'
    funwords[72-1]='dcos'
    funwords[73-1]='ccos'
    funwords[74-1]='zcos'
    funwords[75-1]='cdcos'
    funwords[76-1]='qcos'
    funwords[77-1]='cosd'
    funwords[78-1]='dcosd'
    funwords[79-1]='qcosd'
    funwords[80-1]='cosh'
    funwords[81-1]='dcosh'
    funwords[82-1]='qcosh'
    funwords[83-1]='cotan'
    funwords[84-1]='dcotan'
    funwords[85-1]='qcotan'
    funwords[86-1]='cotand'
    funwords[87-1]='dcotand'
    funwords[88-1]='qcotand'
    funwords[89-1]='count'
    funwords[90-1]='cpu_time'
    funwords[91-1]='cshift'
    funwords[92-1]='date'
    funwords[93-1]='dble'
    funwords[94-1]='dcmplx'
    funwords[95-1]='dfloat'
    funwords[96-1]='digits'
    funwords[97-1]='dim'
    funwords[98-1]='idim'
    funwords[99-1]='jidim'
    funwords[100-1]='hdim'
    funwords[101-1]='iidim'
    funwords[102-1]='bdim1'
    funwords[103-1]='ddim'
    funwords[104-1]='qdim'
    funwords[105-1]='dot_product'
    funwords[106-1]='dprod'
    funwords[107-1]='qprod'
    funwords[108-1]='eof'
    funwords[109-1]='eoshift'
    funwords[110-1]='epsilon'
    funwords[111-1]='errsns'
    funwords[112-1]='exit'
    funwords[113-1]='exp'
    funwords[114-1]='dexp'
    funwords[115-1]='cexp'
    funwords[116-1]='zexp'
    funwords[117-1]='cdexp'
    funwords[118-1]='qexp'
    funwords[119-1]='exponent'
    funwords[120-1]='floor'
    funwords[121-1]='fp_class'
    funwords[122-1]='fraction'
    funwords[123-1]='free'
    funwords[124-1]='huge'
    funwords[125-1]='ichar'
    funwords[126-1]='iachar'
    funwords[127-1]='iand'
    funwords[128-1]='iargcount'
    funwords[129-1]='iargptr'
    funwords[130-1]='ibchng'
    funwords[131-1]='ibclr'
    funwords[132-1]='ibits'
    funwords[133-1]='ibset'
    funwords[134-1]='idate'
    funwords[135-1]='ieor'
    funwords[136-1]='ilen'
    funwords[137-1]='index'
    funwords[138-1]='int'
    funwords[139-1]='ior'
    funwords[140-1]='isha'
    funwords[141-1]='ishc'
    funwords[142-1]='ishft'
    funwords[143-1]='ishftc'
    funwords[144-1]='ishl'
    funwords[145-1]='isnan'
    funwords[146-1]='kind'
    funwords[147-1]='lbound'
    funwords[148-1]='leadz'
    funwords[149-1]='len'
    funwords[150-1]='lge'
    funwords[151-1]='lgt'
    funwords[152-1]='lle'
    funwords[153-1]='llt'
    funwords[154-1]='loc'
    funwords[155-1]='log'
    funwords[156-1]='alog'
    funwords[157-1]='dlog'
    funwords[158-1]='clog'
    funwords[159-1]='zlog'
    funwords[160-1]='cdlog'
    funwords[161-1]='qlog'
    funwords[162-1]='log10'
    funwords[163-1]='alog10'
    funwords[164-1]='dlog10'
    funwords[165-1]='qlog10'
    funwords[166-1]='logical'
    funwords[167-1]='malloc'
    funwords[168-1]='matmul'
    funwords[169-1]='max'
    funwords[170-1]='max0'
    funwords[171-1]='imax0'
    funwords[172-1]='jmax0'
    funwords[173-1]='amax1'
    funwords[174-1]='dmax1'
    funwords[175-1]='amax0'
    funwords[176-1]='aimax0'
    funwords[177-1]='ajmax0'
    funwords[178-1]='max1'
    funwords[179-1]='imax1'
    funwords[180-1]='jmax1'
    funwords[181-1]='qmax1'
    funwords[182-1]='maxexponent'
    funwords[183-1]='maxloc'
    funwords[184-1]='maxval'
    funwords[185-1]='merge'
    funwords[186-1]='min'
    funwords[187-1]='min0'
    funwords[188-1]='imin0'
    funwords[189-1]='jmin0'
    funwords[190-1]='amin1'
    funwords[191-1]='dmin1'
    funwords[192-1]='amin0'
    funwords[193-1]='aimin0'
    funwords[194-1]='ajmin0'
    funwords[195-1]='min1'
    funwords[196-1]='imin1'
    funwords[197-1]='jmin1'
    funwords[198-1]='qmin1'
    funwords[199-1]='minexponent'
    funwords[200-1]='minloc'
    funwords[201-1]='minval'
    funwords[202-1]='mod'
    funwords[203-1]='jmod'
    funwords[204-1]='hmod'
    funwords[205-1]='imod'
    funwords[206-1]='bmod1'
    funwords[207-1]='amod'
    funwords[208-1]='dmod'
    funwords[209-1]='qmod'
    funwords[210-1]='modulo'
    funwords[211-1]='mult'
    funwords[212-1]='mvbits'
    funwords[213-1]='nearest'
    funwords[214-1]='nint'
    funwords[215-1]='inint'
    funwords[216-1]='jnint'
    funwords[217-1]='idnint'
    funwords[218-1]='iidnnt'
    funwords[219-1]='jidnnt'
    funwords[220-1]='iqnint'
    funwords[221-1]='iiqnnt'
    funwords[222-1]='jiqnnt'
    funwords[223-1]='not'
    funwords[224-1]='null'
    funwords[225-1]='number'
    funwords[226-1]='nworkers'
    funwords[227-1]='pack'
    funwords[228-1]='popcnt'
    funwords[229-1]='poppar'
    funwords[230-1]='precision'
    funwords[231-1]='present'
    funwords[232-1]='processors'
    funwords[233-1]='product'
    funwords[234-1]='qcmplx'
    funwords[235-1]='qext'
    funwords[236-1]='qfloat'
    funwords[237-1]='radix'
    funwords[238-1]='ran'
    funwords[239-1]='random'
    funwords[240-1]='random'
    funwords[241-1]='randu'
    funwords[242-1]='range'
    funwords[243-1]='real'
    funwords[244-1]='dreal'
    funwords[245-1]='qreal'
    funwords[246-1]='repeat'
    funwords[247-1]='reshape'
    funwords[248-1]='rrspacing'
    funwords[249-1]='scale'
    funwords[250-1]='scan'
    funwords[251-1]='secnds'
    funwords[252-1]='selected'
    funwords[253-1]='selected'
    funwords[254-1]='set'
    funwords[255-1]='shape'
    funwords[256-1]='sign'
    funwords[257-1]='sin'
    funwords[258-1]='dsin'
    funwords[259-1]='csin'
    funwords[260-1]='zsin'
    funwords[261-1]='cdsin'
    funwords[262-1]='qsin'
    funwords[263-1]='sind'
    funwords[264-1]='dsind'
    funwords[265-1]='qsind'
    funwords[266-1]='sinh'
    funwords[267-1]='dsinh'
    funwords[268-1]='qsinh'
    funwords[269-1]='size'
    funwords[270-1]='sizeof'
    funwords[271-1]='spacing'
    funwords[272-1]='spread'
    funwords[273-1]='sqrt'
    funwords[274-1]='dsqrt'
    funwords[275-1]='csqrt'
    funwords[276-1]='zsqrt'
    funwords[277-1]='cdsqrt'
    funwords[278-1]='qsqrt'
    funwords[279-1]='sum'
    funwords[280-1]='system'
    funwords[281-1]='tan'
    funwords[282-1]='dtan'
    funwords[283-1]='ctan'
    funwords[284-1]='ztan'
    funwords[285-1]='qtan'
    funwords[286-1]='tand'
    funwords[287-1]='dtand'
    funwords[288-1]='qtand'
    funwords[289-1]='tanh'
    funwords[290-1]='dtanh'
    funwords[291-1]='qtanh'
    funwords[292-1]='time'
    funwords[293-1]='tiny'
    funwords[294-1]='trailz'
    funwords[295-1]='transfer'
    funwords[296-1]='transpose'
    funwords[297-1]='trim'
    funwords[298-1]='ubound'
    funwords[299-1]='unpack'
    funwords[300-1]='verify'
    funwords[301-1]='zext'
    funwords[302-1]='isign'
    funwords[303-1]='jisign'
    funwords[304-1]='hsign'
    funwords[305-1]='iisign'
    funwords[306-1]='bsign1'
    funwords[307-1]='sign'
    funwords[308-1]='dsign'
    funwords[309-1]='qsign'
    funwords[310-1]='date_and_time'
    funwords[311-1]='format'
    funwords[312-1]='write'
    funwords[313-1]='print'
    funwords[314-1]='random_seed'
    funwords[315-1]='random_number'
    funwords[316-1]='open'
    funwords[317-1]='allocate'
    funwords[318-1]='false'
    funwords[319-1]='true'
    funwords[320-1]='inquire'
    funwords[321-1]='deallocate'
    return funwords
def getfunwordsonlyML(**kwargs):
    funwords=cell(7,1)
    funwords[1-1]='abs'
    funwords[2-1]='conj'
    funwords[3-1]='fix'
    funwords[4-1]='size'
    funwords[5-1]='deblank'
    funwords[6-1]='upper'
    funwords[7-1]='lower'
    funwords[length(funwords)+1-1]='imag'
    funwords[length(funwords)+1-1]='ans'
    return funwords
def getTopGroupsAfterLoc(str,loc,delim,**kwargs):
    if nargin()<3:
        delim=''
    topCommas=find(str==',')
    topCommas=topCommas[int(topCommas>loc-1)]
    tl=str=='('|str=='['
    tl[int(find(tl)-1)]= not inastring_f(str,find(tl))
    tl[int(find(tl)-1)]= not inastring2_f(str,find(tl))
    tl[int(find(tl)-1)]= not inaDQstring_f(str,find(tl))
    tr=str==')'|str==']'
    tr[int(find(tr)-1)]= not inastring_f(str,find(tr))
    tr[int(find(tr)-1)]= not inastring2_f(str,find(tr))
    tr[int(find(tr)-1)]= not inaDQstring_f(str,find(tr))
    tb=tl-tr
    tlevel=m_array([0,cumsum(tb)]).reshape(1,-1)
    topCommas=topCommas[int(tlevel[int(topCommas+1-1)]==tlevel[int(loc+1-1)])]
    tt=find(tlevel<tlevel[int(loc+1-1)])
    tt=tt[int(tt>loc-1)]
    if  not isempty(tt):
        topCommas=topCommas[int(topCommas<tt[int(1-1)]-1)]
    if  not isempty(delim):
        dl=str==delim
        dl[1-1:loc+1-1]=false()
        dlc=cumsum(dl)
        topCommas=topCommas[int(dlc[int(topCommas-1)]/2==floor(dlc[int(topCommas-1)]/2))]
    good=zeros(1,length(topCommas))
    for ii in arange(1,length(topCommas)+1).reshape(1,-1).flat:
        good[int(ii-1)]= not inastring_f(str,topCommas[int(ii-1)])& not inaDQstring_f(str,topCommas[int(ii-1)])
    topCommas=topCommas[int(find(good)-1)]
    groups=cell(0)
    howmany=length(topCommas)+1
    for ii in arange(1,length(topCommas)+1+1).reshape(1,-1).flat:
        if ii==1:
            if  not isempty(topCommas):
                groups[ii-1]=str[loc+1-1:topCommas[int(1-1)]-1+1-1]
            else:
                groups[1-1]=str[loc+1-1:str.shape[0]+1-1]
        else:
            if ii==length(topCommas)+1:
                groups[ii-1]=str[topCommas[int(topCommas.shape[0]-1)]+1-1:str.shape[0]+1-1]
            else:
                groups[ii-1]=str[topCommas[int(ii-1-1)]+1-1:topCommas[int(ii-1)]-1+1-1]
        temp=find( not isspace(groups[ii-1]))
        if groups[ii-1][int(temp[int(temp.shape[0]-1)]-1)]==';':
            groups[ii-1]=m_array([groups[ii-1][1-1:temp[int(temp.shape[0]-1)]-1+1-1],groups[ii-1][temp[int(temp.shape[0]-1)]+1-1:groups[ii-1].shape[0]+1-1]]).reshape(1,-1)
    return groups,topCommas
def getTopLevelStrings(str,loc,tofind,i,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,filename,**kwargs):
    out=m_array()
    temp=findstr(funstr[i-1],tofind)
    for ii in arange(1,length(temp)+1).reshape(1,-1).flat:
        if temp[int(ii-1)]==length(funstr[i-1]):
            out=m_array([out,temp[int(ii-1)]]).reshape(1,-1)
        else:
            outflag,howmany,subscripts,centercomma,parens=inwhichlast_f(i,temp[int(ii-1)],funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,filename,nargout=5)
            if outflag==0:
                out=m_array([out,temp[int(ii-1)]]).reshape(1,-1)
    outbefore=out[int(out<loc-1)]
    if  not isempty(outbefore):
        outbefore=outbefore[int(outbefore.shape[0]-1)]
    else:
        outbefore=0
    outafter=out[int(out>loc-1)]
    if  not isempty(outafter):
        outafter=outafter[int(1-1)]
    else:
        outafter=length(funstr[i-1])
    return out,outbefore,outafter
def getVarSpecs(varName,localVar,typeDefs,**kwargs):
    return out()
def implicitParse(implicit,i,j,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,var_words,**kwargs):
    for jj in arange(j,length(funstrwords[i-1])+1).reshape(1,-1).flat:
        temp=strcmp(funstrwords[i-1][jj-1],var_words)
        if any(temp):
            temp1=find(funstr[i-1]=='(')
            found=0
            if  not isempty(temp1):
                for ii in arange(1,length(temp1)+1).reshape(1,-1).flat:
                    temp2=findrights_f(temp1[int(ii-1)],funstr[i-1])
                    if temp1[int(ii-1)]>funstrwords_e[i-1][int(jj-1)] and any(isletter(funstr[i-1][temp1[int(ii-1)]-1:temp2+1-1])):
                        found=temp1[int(ii-1)]
                        break
                if found:
                    in=funstr[i-1][temp1[int(ii-1)]-1:temp2+1-1]
                    commas=find(in==',')
                    temp3=m_array([1,commas,length(in)]).reshape(1,-1)
                    for k in arange(1,length(temp3)-1+1).reshape(1,-1).flat:
                        group=in[temp3[int(k-1)]+1-1:temp3[int(k+1-1)]-1+1-1]
                        if any(group=='-'):
                            start=group[int(find(isletter(group),1,'first')-1)]
                            finish=group[int(find(isletter(group),1,'last')-1)]
                            for kk in arange(double(start),double(finish)+1).reshape(1,-1).flat:
                                implicit=assignImplicit(implicit,char(kk),funstrwords[i-1][jj-1])
                        else:
                            if length(strtrim(group))==1 and isletter(strtrim(group)):
                                implicit=assignImplicit(implicit,strtrim(group),funstrwords[i-1][jj-1])
            else:
                break
    return implicit
def assignImplicit(implicit,in,varType,**kwargs):
    implicit=_copy(implicit)
    if any(strcmp(varType,['real','complex','integer','logical','character'])):
        implicit[double(in)-96-1,2-1]=varType
    else:
        implicit[double(in)-96-1,2-1]='real'
    return implicit
def implicitRules(**kwargs):
    implicit=cell(26,2)
    for i in arange(97,122+1).reshape(1,-1).flat:
        ii=i-96
        implicit[ii-1,1-1]=char(i)
        if i>=105&i<=110:
            implicit[ii-1,2-1]='integer'
        else:
            implicit[ii-1,2-1]='real'
    return implicit
def inaDQstring_f(str,loc,**kwargs):
    str=_copy(str)
    out=m_array()
    str[int(loc-1)]='='
    temp=str=='"'
    ftemp=find(temp)
    good= not inastring_f(str,ftemp)
    temp[int(ftemp-1)]=good
    ftemp=ftemp[int(good-1)]
    temp1=cumsum(temp)
    for ii in arange(1,length(loc)+1).reshape(1,-1).flat:
        if (temp1[int(loc[int(ii-1)]-1)]/2!=round(temp1[int(loc[int(ii-1)]-1)]/2)) and length(ftemp)>1:
            out[int(ii-1)]=1
        else:
            out[int(ii-1)]=0
    return out
def inastring2_f(str,loc,**kwargs):
    out=m_array()
    temp=strfind(str,"''")
    for ii in arange(1,length(loc)+1).reshape(1,-1).flat:
        temp1=find(temp<loc[int(ii-1)])
        if length(temp1)/2!=floor(length(temp1)/2):
            out[int(ii-1)]=1
        else:
            out[int(ii-1)]=0
    return out
def inastring_f(str,loc,**kwargs):
    str=_copy(str)
    str[int(loc-1)]='='
    temp=str=="'"
    temp1=cumsum(temp)
    out=temp1[int(loc-1)]/2!=round(temp1[int(loc-1)]/2)
    return out
def inbracket2(str,spot,**kwargs):
    outflag=0
    temp=findstr(str,'[')
    temp1=findstr(str,']')
    if length(temp[int(temp<spot-1)])>length(temp1[int(temp1<spot-1)]):
        outflag=1
    howmany=0
    subscripts=m_array()
    centercomma=m_array()
    parens=zeros(1,2)
    if outflag:
        if str[int(spot-1)]=='[':
            temp3=1
        else:
            temp3=0
        found=0
        leftbracket=str=='['
        rightbracket=str==']'
        both_b=leftbracket-rightbracket
        c_b=cumsum(both_b)
        poss=leftbracket&(c_b==(c_b[int(spot-1)]-temp3))
        poss_loc=find(poss)
        poss_loc=poss_loc[int(poss_loc<spot-1)]
        try: 
            parens[int(1-1)]=poss_loc[int(poss_loc.shape[0]-1)]
        except: 
            poss_loc
            kb()
        parens[int(2-1)]=findrights_f(parens[int(1-1)],str)
        tempstr=_copy(str)
        tempstr[1-1:parens[int(1-1)]+1-1]='0'
        tempstr[parens[int(2-1)]-1:tempstr.shape[0]+1-1]='0'
        leftp=tempstr=='('
        rightp=tempstr==')'
        both_p=leftp-rightp
        c_p=cumsum(both_p)
        temp=length(findstr(',',str[parens[int(1-1)]-1:parens[int(2-1)]+1-1]))
        if temp==0:
            howmany=1
            subscripts[1-1]=str[parens[int(1-1)]+1-1:parens[int(2-1)]-1+1-1]
        else:
            if temp>0:
                centercomma=findstr(',',str)
                centercomma=centercomma[int(((centercomma<parens[int(2-1)])&(centercomma>parens[int(1-1)]))-1)]
                found=1
                cc2=m_array()
                for k in arange(1,length(centercomma)+1).reshape(1,-1).flat:
                    if ((c_b[int(centercomma[int(k-1)]-1)]==c_b[int(parens[int(1-1)]-1)])&(c_p[int(centercomma[int(k-1)]-1)]==0)):
                        cc2[int(found-1)]=centercomma[int(k-1)]
                        found=found+1
                centercomma=cc2
                howmany=length(centercomma)+1
                tempcc=m_array([parens[int(1-1)],centercomma,parens[int(2-1)]]).reshape(1,-1)
                for i in arange(1,length(tempcc)-1+1).reshape(1,-1).flat:
                    subscripts[i-1]=str[tempcc[int(i-1)]+1-1:tempcc[int(i+1-1)]-1+1-1]
    return outflag,howmany,subscripts,centercomma,parens
def inbracket_f(i,spot,funstr,**kwargs):
    outflag=0
    temp=findstr(funstr[i-1],'[')
    temp1=findstr(funstr[i-1],']')
    if length(temp[int(temp<spot-1)])>length(temp1[int(temp1<spot-1)]):
        outflag=1
    howmany=0
    subscripts=m_array()
    centercomma=m_array()
    parens=zeros(1,2)
    if outflag:
        if funstr[i-1][int(spot-1)]=='[':
            temp3=1
        else:
            temp3=0
        found=0
        leftbracket=funstr[i-1]=='['
        rightbracket=funstr[i-1]==']'
        both_b=leftbracket-rightbracket
        c_b=cumsum(both_b)
        poss=leftbracket&(c_b==(c_b[int(spot-1)]-temp3))
        poss_loc=find(poss)
        poss_loc=poss_loc[int(poss_loc<spot-1)]
        try: 
            parens[int(1-1)]=poss_loc[int(poss_loc.shape[0]-1)]
        except: 
            poss_loc
            kb()
        parens[int(2-1)]=findrights_f(parens[int(1-1)],funstr[i-1])
        tempstr=funstr[i-1]
        tempstr[1-1:parens[int(1-1)]+1-1]='0'
        tempstr[parens[int(2-1)]-1:tempstr.shape[0]+1-1]='0'
        leftp=tempstr=='('
        rightp=tempstr==')'
        both_p=leftp-rightp
        c_p=cumsum(both_p)
        temp=length(findstr(':',funstr[i-1][parens[int(1-1)]-1:parens[int(2-1)]+1-1]))
        if temp==0:
            howmany=1
            subscripts[1-1]=funstr[i-1][parens[int(1-1)]+1-1:parens[int(2-1)]-1+1-1]
        else:
            if temp>0:
                centercomma=findstr(':',funstr[i-1])
                centercomma=centercomma[int(((centercomma<parens[int(2-1)])&(centercomma>parens[int(1-1)]))-1)]
                found=1
                cc2=m_array()
                for k in arange(1,length(centercomma)+1).reshape(1,-1).flat:
                    if ((c_b[int(centercomma[int(k-1)]-1)]==c_b[int(parens[int(1-1)]-1)])&(c_p[int(centercomma[int(k-1)]-1)]==0)):
                        cc2[int(found-1)]=centercomma[int(k-1)]
                        found=found+1
                centercomma=cc2
                howmany=length(centercomma)+1
                if howmany==1:
                    subscripts[1-1]=funstr[i-1][parens[int(1-1)]+1-1:parens[int(2-1)]-1+1-1]
                else:
                    if howmany==2:
                        subscripts[1-1]=funstr[i-1][parens[int(1-1)]+1-1:centercomma[int(1-1)]-1+1-1]
                        subscripts[2-1]=funstr[i-1][centercomma[int(1-1)]+1-1:parens[int(2-1)]-1+1-1]
                    else:
                        if howmany==3:
                            subscripts[1-1]=funstr[i-1][parens[int(1-1)]+1-1:centercomma[int(1-1)]-1+1-1]
                            subscripts[2-1]=funstr[i-1][centercomma[int(1-1)]+1-1:centercomma[int(2-1)]-1+1-1]
                            subscripts[3-1]=funstr[i-1][centercomma[int(2-1)]+1-1:parens[int(2-1)]-1+1-1]
    return outflag,howmany,subscripts,centercomma,parens
def incomment(str,locs,**kwargs):
    out=false(1,length(locs))
    temp=find(str=='%')
    for jj in arange(1,length(temp)+1).reshape(1,-1).flat:
        if jj==1 and temp[int(1-1)]==1:
            out[:]=true()
            break
        else:
            temp1=inastring_f(str,temp[int(jj-1)]) or inaDQstring_f(str,temp[int(jj-1)])
            if  not temp1:
                out[int(locs>=temp[int(jj-1)]-1)]=true()
                break
    return out
def insertLocalVar(localVar,name,varargin,**kwargs):
    localVar=_copy(localVar)
    if iscell(name):
        if  not any(strcmp(name[1-1,1-1],[localVar[:,1-1]])):
            localVar[localVar.shape[0]+1-1,:]=name[1-1,:]
            thisLV=size(localVar,1)
        else:
            thisLV=find(strcmp(name[1-1,1-1],[localVar[:,1-1]]))
            localVar[thisLV-1,:]=name[1-1,:]
    else:
        if  not any(strcmp(name,[localVar[:,1-1]])):
            localVar[localVar.shape[0]+1-1,1-1]=name
            thisLV=size(localVar,1)
        else:
            thisLV=find(strcmp(name,[localVar[:,1-1]]))
    attrib=['nDim','type','common','extents','data','save','protect','param','intent','alloc','external','input','optional','result','handle']
    if length(varargin)>0:
        for ii in arange(1,length(varargin)+1,2).reshape(1,-1).flat:
            whichAtt=find(strcmp(varargin[ii-1],attrib))
            if  not isempty(whichAtt):
                localVar[thisLV-1,whichAtt+1-1]=varargin[ii+1-1]
    return localVar,thisLV
def insubscript_f(i,spot,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,**kwargs):
    needparentest=1
    outflag=0
    needtest=0
    whichword=m_array()
    whichsub=m_array()
    howmany=0
    subscripts=[]
    centercomma=m_array()
    parens=m_array()
    leftpp=funstr[i-1][1-1:spot+1-1]=='('
    rightpp=funstr[i-1][1-1:spot+1-1]==')'
    if needparentest:
        leftp=length(find(leftpp))
        rightp=length(find(rightpp))
        if leftp>rightp:
            needtest=1
    else:
        needtest=1
    if needtest:
        for j in find(funstrwords_b[i-1]<spot).flat:
            howmany,subscripts,centercomma,parens=hassubscript_f(i,j,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,nargout=4)
            if howmany>0 and ((parens[int(1-1)]<spot)&(parens[int(2-1)]>spot)):
                outflag=1
                whichword=j
                break
    return outflag,whichword,whichsub,howmany,subscripts,centercomma,parens
def inwhichlast_f(i,spot,funstr,varargin,**kwargs):
    testcon=1
    outflag=0
    howmany=0
    subscripts=m_array()
    centercomma=m_array()
    parens=m_array()
    whichword=m_array()
    temp5=funstr[i-1]=="'"
    temp6=cumsum(temp5)
    temp7=temp6/2!=round(temp6/2)
    left=funstr[i-1]=='('& not temp7
    right=funstr[i-1]==')'& not temp7
    both_p=left-right
    c_p=cumsum(both_p)
    leftbracket=funstr[i-1]=='['& not temp7
    rightbracket=funstr[i-1]==']'& not temp7
    both_b=leftbracket-rightbracket
    c_b=cumsum(both_b)
    goon=0
    if c_p[int(spot-1)]>0 or c_b[int(spot-1)]>0:
        goon=1
        if length(find(spot==find(left)))>0:
            temp=1
        else:
            temp=0
        poss_p=find(left&(c_p==(c_p[int(spot-1)]-temp)))
        poss_p=poss_p[int(poss_p<spot-1)]
        poss_p=m_array([0,poss_p]).reshape(1,-1)
        poss_p=poss_p[int(poss_p.shape[0]-1)]
        temp=0
        if  not isempty(find(leftbracket)):
            if length(find(spot==find(leftbracket)))>0:
                temp=1
        poss_b=find(leftbracket&(c_b==(c_b[int(spot-1)]-temp)))
        poss_b=poss_b[int(poss_b<spot-1)]
        poss_b=m_array([0,poss_b]).reshape(1,-1)
        poss_b=poss_b[int(poss_b.shape[0]-1)]
        j=max(m_array([poss_p,poss_b]).reshape(1,-1))
        if j==poss_b:
            outflag=2
        else:
            outflag=1
        parens[int(1-1)]=j
        if j!=0:
            parens[int(2-1)]=findrights_f(j,funstr[i-1],1)
        else:
            parens[int(2-1)]=0
            outflag=0
    return outflag,howmany,subscripts,centercomma,parens,whichword
def iscomplexf(i,whichopenparen,temp,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,**kwargs):
    howmany=0
    subscripts=m_array()
    centercomma=m_array()
    parens=m_array()
    out=0
    goon=0
    temp1=find( not isspace(funstr[i-1]))
    temp1=temp1[int(temp1<temp[int(whichopenparen-1)]-1)]
    if  not isempty(temp1):
        temp1=temp1[int(temp1.shape[0]-1)]
        if  not any(funstrwords_e[i-1]==temp1):
            parens[int(1-1)]=temp[int(whichopenparen-1)]
            rightparen=findrights_f(temp[int(whichopenparen-1)],funstr[i-1])
            parens[int(2-1)]=rightparen
            left=funstr[i-1]=='('
            right=funstr[i-1]==')'
            both_p=left-right
            c_p=cumsum(both_p)
            leftbracket=funstr[i-1]=='['
            rightbracket=funstr[i-1]==']'
            both_b=leftbracket-rightbracket
            c_b=cumsum(both_b)
            commas=find(funstr[i-1]==',')
            commas=commas[int(((commas>parens[int(1-1)])&(commas<parens[int(2-1)]))-1)]
            if  not isempty(commas):
                centercomma=commas[int(((c_p[int(commas-1)]==c_p[int(parens[int(1-1)]-1)])&(c_b[int(commas-1)]==c_b[int(parens[int(1-1)]-1)]))-1)]
            else:
                centercomma=m_array()
            howmany=length(centercomma)+1
    if howmany==2:
        out=1
    return out,howmany,subscripts,centercomma,parens
def isInteger(i,range,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,fortranfunwords,formats,localVar,**kwargs):
    localVar=_copy(localVar)
    str=funstr[i-1]
    tl=str=='('
    tl[int(find(tl)-1)]= not inastring_f(str,find(tl))
    tl[int(find(tl)-1)]= not inastring2_f(str,find(tl))
    tr=str==')'
    tr[int(find(tr)-1)]= not inastring_f(str,find(tr))
    tr[int(find(tr)-1)]= not inastring2_f(str,find(tr))
    tb=tl-tr
    tlevel=m_array([0,cumsum(tb)]).reshape(1,-1)
    if str[int(range[int(1-1)]-1)]=='(':
        loc=range[int(1-1)]+1
    else:
        loc=range[int(1-1)]
    possW=find(funstrwords_b[i-1]>=range[int(1-1)]&funstrwords_b[i-1]<=range[int(2-1)]&tlevel[int(funstrwords_b[i-1]-1)]==tlevel[int(loc-1)])
    possN=find(funstrnumbers_b[i-1]>=range[int(1-1)]&funstrnumbers_b[i-1]<=range[int(2-1)]&tlevel[int(funstrnumbers_b[i-1]-1)]==tlevel[int(loc-1)])
    outW=false(1,length(possW))
    outN=false(1,length(possN))
    localVar[size(localVar,1)+1-1,1-1]='fix'
    localVar[size(localVar,1)-1,3-1]='integer'
    for ii in arange(1,length(possW)+1).reshape(1,-1).flat:
        temp=find(strcmp(funstrwords[i-1][possW[int(ii-1)]-1],[localVar[:,1-1]]))
        if  not isempty(temp):
            if strcmp(localVar[temp-1,3-1],'integer'):
                outW[int(ii-1)]=true()
    for ii in arange(1,length(possN)+1).reshape(1,-1).flat:
        if isempty(regexpi(funstrnumbers[i-1][possN[int(ii-1)]-1],'[\\.edq]')):
            outN[int(ii-1)]=true()
    if all(outW) and all(outN):
        out=1
    else:
        out=0
    return out
def iskeep_f(str,**kwargs):
    if  not isempty(str):
        out=((isletter(str))|(str=='_')|(str=='.')|((str>47)&(str<58)))
    else:
        out=m_array()
    return out
def isnameletter(str,**kwargs):
    out=((isletter(str))|(str=='_'))
    return out
def isnumber(str,**kwargs):
    out=((str>47)&(str<58))
    return out
def lastNonSpace(str,locs,**kwargs):
    temp=find( not isspace(str))
    out=zeros(size(locs))
    for ii in arange(1,length(locs)+1).reshape(1,-1).flat:
        temp1=temp[int(temp<locs[int(ii-1)]-1)]
        if  not isempty(temp1):
            out[int(ii-1)]=temp1[int(temp1.shape[0]-1)]
        else:
            out[int(ii-1)]=0
    return out
def maxloc(x,dim,**kwargs):
    if nargin()<2:
        dim=0
    xdim=length(size(x))
    if dim==0:
        dumvar,tempOut=max(x[:],nargout=2)
        out=cell(1,xdim)
        out[:]=ind2sub(size(x),tempOut,nargout=1)
        out=m_array([out[:]]).reshape(1,-1)
    else:
        if  not isnumeric(dim):
            error('dim must be anumber in maxloc')
        if dim!=round(dim):
            error('dim must be an integer in maxloc')
        if dim>xdim or dim<1:
            error('dim must be 0<dim<=length(size(x))')
        dumvar,out=max(x,m_array(),dim,nargout=2)
    return out
def nextNonSpace(str,locs,**kwargs):
    temp=find( not isspace(str))
    out=zeros(size(locs))
    for ii in arange(1,length(locs)+1).reshape(1,-1).flat:
        temp1=temp[int(temp>locs[int(ii-1)]-1)]
        if  not isempty(temp1):
            out[int(ii-1)]=temp1[int(1-1)]
        else:
            out[int(ii-1)]=length(str)+1
    return out
def remLocalVar(localVar,name,**kwargs):
    t1=strcmp(name,[localVar[:,1-1]])
    thisLV=find(t1)
    notThisLV=find( not t1)
    if  not isempty(thisLV):
        if isempty(localVar[thisLV-1,8-1]):
            localVar=localVar[notThisLV-1,:]
    return localVar
def replaceword(i,j,funstr,funstrwords,funstrwords_b,funstrwords_e,repstr,**kwargs):
    funstr=_copy(funstr)
    funstr[i-1]=m_array([funstr[i-1][1-1:(funstrwords_b[i-1][int(j-1)]-1)+1-1],repstr,funstr[i-1][(funstrwords_e[i-1][int(j-1)]+1)-1:length(funstr[i-1])+1-1]]).reshape(1,-1)
    return funstr
def showall(funstr,indented,**kwargs):
    if nargin()==0:
        for i in arange(1,size(funstr,1)+1).reshape(1,-1).flat:
            disp(funstr[i-1])
    else:
        for i in arange(1,size(funstr,1)+1).reshape(1,-1).flat:
            disp(m_array(['  ',funstr[i-1]]).reshape(1,-1))
    return 
def strrel(in1,in2,relop,**kwargs):
    out=m_array()
    if isempty(in1) or isempty(in2):
        return out
    if isnumeric(in1) or isnumeric(in2):
        error('arguments to strrel must be char arrays or cell arrays of strings')
    if ischar(in1):
        in1=[in1]
    if ischar(in2):
        in2=[in2]
    if  not all(size(in1)==size(in2)):
        if prod(size(in1))==1:
            in1=repmat(in1,size(in2))
        else:
            if prod(size(in2))==1:
                in2=repmat(in2,size(in1))
            else:
                error('cell array size mismatch in strrel')
    out=false(size(in1))
    for i in arange(1,numel(in1)+1).reshape(1,-1).flat:
        isEqual=strcmp(in1[i-1],in2[i-1])
        isSorted=issorted([in1[i-1],in2[i-1]])
        if ['<','lt']==lower(relop):
            out[int(i-1)]=isSorted& not isEqual
        else:
            if ['<=','le']==lower(relop):
                out[int(i-1)]=isSorted|isEqual
            else:
                if ['==','eq']==lower(relop):
                    out[int(i-1)]=isEqual
                else:
                    if ['~=','ne']==lower(relop):
                        out[int(i-1)]= not isEqual
                    else:
                        if ['>','gt']==lower(relop):
                            out[int(i-1)]= not isSorted& not isEqual
                        else:
                            if ['>=','gt']==lower(relop):
                                out[int(i-1)]= not isSorted|isEqual
                            else:
                                error(m_array(['Relational operator, ',relop,', not recognized in strrel.']).reshape(1,-1))
    return out
def updatefunstr_1line_f(funstr,fs_good,oneline,**kwargs):
    s=length(funstr)
    global numstr,wordstr
    lo=oneline
    hi=oneline
    ind=oneline
    empty=isempty(funstr[ind-1])
    bad1=strncmp(funstr[ind-1],'!',1)
    bad2=strncmp(funstr[ind-1],'%',1)
    good= not (empty|bad1|bad2)
    if  not good:
        fs_good=fs_good[int(fs_good<lo|fs_good>hi-1)]
    else:
        if  not any(fs_good==ind):
            fs_good=m_array([fs_good[int(fs_good<lo-1)],ind,fs_good[int(fs_good>hi-1)]]).reshape(1,-1)
        goodind=ind
        funnum1,funnum2,funnum3=regexp(funstr[goodind-1],numstr,'match','start','end',nargout=3)
        assignin('caller','goodind',goodind)
        assignin('caller','funpart',funnum1)
        evalin('caller','funstrnumbers{goodind}=funpart;')
        assignin('caller','funpart',funnum2)
        evalin('caller','funstrnumbers_b{goodind}=funpart;')
        assignin('caller','funpart',funnum3)
        evalin('caller','funstrnumbers_e{goodind}=funpart;')
        funword1,funword2,funword3=regexp(funstr[goodind-1],wordstr,'match','start','end',nargout=3)
        assignin('caller','funpart',funword1)
        evalin('caller','funstrwords{goodind}=funpart;')
        assignin('caller','funpart',funword2)
        evalin('caller','funstrwords_b{goodind}=funpart;')
        assignin('caller','funpart',funword3)
        evalin('caller','funstrwords_e{goodind}=funpart;')
    return s,fs_good
def updatefunstr2_f(funstr,funstrwords,funstrwords_b,funstrwords_e,funstrnumbers,funstrnumbers_b,funstrnumbers_e,fs_good,oneline,**kwargs):
    funstrwords=_copy(funstrwords)
    funstrwords_b=_copy(funstrwords_b)
    funstrwords_e=_copy(funstrwords_e)
    funstrnumbers=_copy(funstrnumbers)
    funstrnumbers_b=_copy(funstrnumbers_b)
    funstrnumbers_e=_copy(funstrnumbers_e)
    s=length(funstr)
    to0out=['.*','./',".'",'.^']
    if nargin()==1:
        lo=1
        hi=s
        fs_good=m_array()
        funstrwords=cell(s,1)
        funstrwords_b=cell(s,1)
        funstrwords_e=cell(s,1)
        funstrnumbers=cell(s,1)
        funstrnumbers_b=cell(s,1)
        funstrnumbers_e=cell(s,1)
    else:
        lo=oneline
        hi=oneline
        fs_good=fs_good[int(fs_good<lo|fs_good>hi-1)]
        funstrwords[oneline-1]=cell(0)
        funstrwords_b[oneline-1]=m_array()
        funstrwords_e[oneline-1]=m_array()
        funstrnumbers[oneline-1]=cell(0)
        funstrnumbers_b[oneline-1]=m_array()
        funstrnumbers_e[oneline-1]=m_array()
    empty=cellfun('isempty',[funstr[lo-1:hi+1-1]])
    bad1=strncmp([funstr[lo-1:hi+1-1]],'!',1)
    bad2=strncmp([funstr[lo-1:hi+1-1]],'%',1)
    good= not (empty|bad1|bad2)
    ind=arange(lo,hi+1).reshape(1,-1)
    fs_good=m_array([fs_good,ind[int(good-1)]]).reshape(1,-1)
    goodind=ind[int(good-1)]
    if length(fs_good)/s>1/2&nargin()==1:
        funstrnumbers=regexp(funstr,'(\\<(\\d+\\.\\d+|\\d+\\.|\\.\\d+|\\d+)([eEdD][+-]?\\d+)?)','match')
        extents=regexp(funstr,'(\\<(\\d+\\.\\d+|\\d+\\.|\\.\\d+|\\d+)([eEdD][+-]?\\d+)?)','tokenExtents')
        for i in arange(1,length(extents)+1).reshape(1,-1).flat:
            temp=m_array([extents[i-1][:]]).reshape(1,-1)
            if  not isempty(temp):
                funstrnumbers_b[i-1]=temp[1-1:2:temp.shape[0]+1-1]
                funstrnumbers_e[i-1]=temp[2-1:2:temp.shape[0]+1-1]
        funstrwords=regexp(funstr,'(\\<[a-z_A-Z]\\w*)','match')
        extents=regexp(funstr,'(\\<[a-z_A-Z]\\w*)','tokenExtents')
        for i in arange(1,length(extents)+1).reshape(1,-1).flat:
            temp=m_array([extents[i-1][:]]).reshape(1,-1)
            if  not isempty(temp):
                funstrwords_b[i-1]=temp[1-1:2:temp.shape[0]+1-1]
                funstrwords_e[i-1]=temp[2-1:2:temp.shape[0]+1-1]
    else:
        funnum=regexp([funstr[goodind-1]],'(\\<(\\d+\\.\\d+|\\d+\\.|\\.\\d+|\\d+)([eEdD][+-]?\\d+)?)','match')
        funstrnumbers[goodind-1]=deal(funnum[:],nargout=1)
        extents=regexp([funstr[goodind-1]],'(\\<(\\d+\\.\\d+|\\d+\\.|\\.\\d+|\\d+)([eEdD][+-]?\\d+)?)','tokenExtents')
        for i in arange(1,length(extents)+1).reshape(1,-1).flat:
            temp=m_array([extents[i-1][:]]).reshape(1,-1)
            if  not isempty(temp):
                funstrnumbers_b[goodind[int(i-1)]-1]=temp[1-1:2:temp.shape[0]+1-1]
                funstrnumbers_e[goodind[int(i-1)]-1]=temp[2-1:2:temp.shape[0]+1-1]
        funword=regexp([funstr[goodind-1]],'(\\<[a-z_A-Z]\\w*)','match')
        funstrwords[goodind-1]=deal(funword[:],nargout=1)
        extents=regexp([funstr[goodind-1]],'(\\<[a-z_A-Z]\\w*)','tokenExtents')
        for i in arange(1,length(extents)+1).reshape(1,-1).flat:
            temp=m_array([extents[i-1][:]]).reshape(1,-1)
            if  not isempty(temp):
                funstrwords_b[goodind[int(i-1)]-1]=temp[1-1:2:temp.shape[0]+1-1]
                funstrwords_e[goodind[int(i-1)]-1]=temp[2-1:2:temp.shape[0]+1-1]
    fs_good=sort(fs_good)
    'fffffffffff'
    funstrnumbers[i-1]
    funstr[i-1]
    kb()
    return funstr,funstrwords,funstrwords_b,funstrwords_e,funstrnumbers,funstrnumbers_b,funstrnumbers_e,s,fs_good
def updatefunstr_f(funstr,funstrwords,funstrwords_b,funstrwords_e,funstrnumbers,funstrnumbers_b,funstrnumbers_e,fs_good,oneline,**kwargs):
    funstrwords=_copy(funstrwords)
    funstrwords_b=_copy(funstrwords_b)
    funstrwords_e=_copy(funstrwords_e)
    funstrnumbers=_copy(funstrnumbers)
    funstrnumbers_b=_copy(funstrnumbers_b)
    funstrnumbers_e=_copy(funstrnumbers_e)
    s=length(funstr)
    to0out=['.*','./',".'",'.^']
    global numstr,wordstr
    if isempty(numstr):
        numstr='(\\<(\\d+\\.\\d+|\\d+\\.|\\.\\d+|\\d+)([eEdDqQ][+-]?\\d+)?)'
        wordstr='(\\<[a-z_A-Z]\\w*)'
    if nargin()==1:
        lo=1
        hi=s
        fs_good=m_array()
        funstrwords=cell(s,1)
        funstrwords_b=cell(s,1)
        funstrwords_e=cell(s,1)
        funstrnumbers=cell(s,1)
        funstrnumbers_b=cell(s,1)
        funstrnumbers_e=cell(s,1)
        ind=arange(lo,hi+1).reshape(1,-1)
    else:
        lo=oneline
        hi=oneline
        fs_good=fs_good[int(fs_good<lo|fs_good>hi-1)]
        ind=oneline
    empty=cellfun('isempty',[funstr[ind-1]])
    bad1=strncmp([funstr[ind-1]],'!',1)
    bad2=strncmp([funstr[ind-1]],'%',1)
    good= not (empty|bad1|bad2)
    fs_good=m_array([fs_good,ind[int(good-1)]]).reshape(1,-1)
    goodind=ind[int(good-1)]
    if (length(fs_good)/s>1/2|length(fs_good)>1000)&nargin()==1:
        funstrnumbers,funstrnumbers_b,funstrnumbers_e=regexp(funstr,numstr,'match','start','end',nargout=3)
        funstrwords,funstrwords_b,funstrwords_e=regexp(funstr,wordstr,'match','start','end',nargout=3)
    else:
        if (hi-lo)>0:
            funnum1,funnum2,funnum3=regexp([funstr[goodind-1]],numstr,'match','start','end',nargout=3)
            funstrnumbers[goodind-1]=deal(funnum1[:],nargout=1)
            funstrnumbers_b[goodind-1]=deal(funnum2[:],nargout=1)
            funstrnumbers_e[goodind-1]=deal(funnum3[:],nargout=1)
            funword1,funword2,funword3=regexp([funstr[goodind-1]],wordstr,'match','start','end',nargout=3)
            funstrwords[goodind-1]=deal(funword1[:],nargout=1)
            funstrwords_b[goodind-1]=deal(funword2[:],nargout=1)
            funstrwords_e[goodind-1]=deal(funword3[:],nargout=1)
        else:
            if  not isempty(goodind):
                funstrnumbers[goodind-1],funstrnumbers_b[goodind-1],funstrnumbers_e[goodind-1]=regexp(funstr[goodind-1],numstr,'match','start','end',nargout=3)
                funstrwords[goodind-1],funstrwords_b[goodind-1],funstrwords_e[goodind-1]=regexp(funstr[goodind-1],wordstr,'match','start','end',nargout=3)
    fs_good=sort(fs_good)
    return funstr,funstrwords,funstrwords_b,funstrwords_e,funstrnumbers,funstrnumbers_b,funstrnumbers_e,s,fs_good
def varInUsedMods(word,modLocalVar,usedMods,**kwargs):
    out=[]
    for i in arange(length(usedMods),1+1,-1).reshape(1,-1).flat:
        temp1=find(strcmp(word,[modLocalVar[usedMods[int(i-1)]-1,2-1][:,1-1]]))
        if  not isempty(temp1):
            out=[modLocalVar[usedMods[int(i-1)]-1,2-1][temp1-1,:]]
            break
    return out
def varType(i,j,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,localVar,typeDefs,var_words,**kwargs):
    out=''
    outLine=[]
    temp1=find(strcmp(funstrwords[i-1][j-1],[localVar[:,1-1]]))
    if  not isempty(temp1):
        if any(strcmp(localVar[temp1-1,3-1],var_words)):
            out=localVar[temp1-1,3-1]
            outLine=[localVar[temp1-1,:]]
        else:
            howmany,subscripts,centercomma,parens=hassubscript_f(i,j,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,nargout=4)
            temp5=funstrwords_e[i-1][int(j-1)]
            if howmany>0:
                temp5=parens[int(2-1)]
            temp2=nextNonSpace(funstr[i-1],temp5)
            if funstr[i-1][int(temp2-1)]=='.':
                temp3=find(nextNonSpace(funstr[i-1],temp2)==funstrwords_b[i-1])
                if  not isempty(temp3):
                    temp4=find(strcmp(localVar[temp1-1,3-1],[typeDefs[:,1-1]]))
                    if  not isempty(temp4):
                        out,outLine,j=varType(i,temp3,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,typeDefs[temp4-1,2-1],typeDefs,var_words,nargout=3)
            else:
                out=localVar[temp1-1,3-1]
                outLine=[localVar[temp1-1,:]]
    return out,outLine,j
def writef(fid,varargin,**kwargs):
    if isnumeric(fid):
        if fid==6:
            out=fprintf(1,varargin[:])
        else:
            if fid==0:
                out=fprintf(2,varargin[:])
            else:
                if isempty(fid):
                    out=sprintf(varargin[:])
                    if nargin()>2:
                        if  not isempty(inputname(1)):
                            assignin('caller',inputname(1),out)
                else:
                    out=fprintf(fid,varargin[:])
    else:
        if ischar(fid):
            out=sprintf(varargin[:])
            if nargin()>2:
                if  not isempty(inputname(1)):
                    assignin('caller',inputname(1),out)
        else:
            out=fprintf(fid,varargin[:])
    return out
def zeroVarDec(funstr,i,temp2,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,localVar,temp6,varp,funwords,want_row,var_words,override,**kwargs):
    if  not exist('override','var'):
        override=0
    out=''
    hms,subscripts,centercomma,parens=hassubscript_f(i,temp2,funstr,funstrnumbers,funstrnumbers_b,funstrnumbers_e,funstrwords,funstrwords_b,funstrwords_e,funwords,nargout=4)
    howmany=length(localVar[temp6-1,5-1])
    if hms==0 and howmany>0:
        parens=m_array([funstrwords_b[i-1][int(temp2-1)],funstrwords_e[i-1][int(temp2-1)]]).reshape(1,-1)
    subscripts=localVar[temp6-1,5-1]
    temp3=find(funstr[i-1]=='=')
    temp3=temp3[int(temp3>funstrwords_e[i-1][int(temp2-1)]-1)]
    if isempty(temp3) or override:
        if  not isempty(localVar[temp6-1,11-1]) and  not override:
            if strcmp(localVar[temp6-1,3-1],'character'):
                out=m_array([funstrwords[i-1][temp2-1],"='';"]).reshape(1,-1)
            else:
                out=m_array([funstrwords[i-1][temp2-1],'=[];']).reshape(1,-1)
        else:
            temp7=cell(0)
            for j in arange(1,howmany+1).reshape(1,-1).flat:
                cc=m_array([parens[int(1-1)],centercomma,parens[int(2-1)]]).reshape(1,-1)
                temp3=strfind(subscripts[j-1],':')
                if  not isempty(temp3):
                    temp7[j-1]=subscripts[j-1][temp3[int(temp3.shape[0]-1)]+1-1:subscripts[j-1].shape[0]+1-1]
                    temp8=find( not isspace(temp7[j-1]),1,'last')
                    if temp7[j-1][int(temp8-1)]==']':
                        temp7[j-1][int(temp8-1)]=''
                else:
                    temp7[j-1]=subscripts[j-1]
                temp5=find(strcmpi(funstrwords[i-1][temp2-1],[varp[:,1-1]]))
                if  not isempty(temp5):
                    goon=find(j==varp[temp5-1,2-1])
                    if  not isempty(goon):
                        temp7[j-1]=m_array([temp7[j-1],'+',num2str(varp[temp5-1,3-1][int(goon-1)])]).reshape(1,-1)
            if howmany==0:
                goon=1
                if  not any(strcmp(localVar[temp6-1,3-1],var_words)):
                    out=m_array([funstrwords[i-1][temp2-1],'=',localVar[temp6-1,3-1],';']).reshape(1,-1)
                    goon=0
                if strcmp(localVar[temp6-1,3-1],'character'):
                    if ischar(localVar[temp6-1,2-1]):
                        out=m_array([funstrwords[i-1][temp2-1],"=repmat(' ',1,",localVar[temp6-1,2-1],');']).reshape(1,-1)
                    else:
                        out=m_array([funstrwords[i-1][temp2-1],"='';"]).reshape(1,-1)
                    goon=0
                if strcmp(localVar[temp6-1,3-1],'logical'):
                    out=m_array([funstrwords[i-1][temp2-1],'=false;']).reshape(1,-1)
                    goon=0
                if goon and  not strcmp(localVar[temp6-1,3-1],'character'):
                    if isempty(localVar[temp6-1,16-1]):
                        out=m_array([funstrwords[i-1][temp2-1],'=0;']).reshape(1,-1)
                    else:
                        out=m_array([funstrwords[i-1][temp2-1],'={};']).reshape(1,-1)
            else:
                if howmany==1:
                    if  not any(strcmp(localVar[temp6-1,3-1],var_words)):
                        if want_row:
                            out=m_array([funstrwords[i-1][temp2-1],'=',localVar[temp6-1,3-1],'(ones(1,',temp7[1-1],'));']).reshape(1,-1)
                        else:
                            out=m_array([funstrwords[i-1][temp2-1],'=',localVar[temp6-1,3-1],'(ones(',temp7[1-1],',1));']).reshape(1,-1)
                    else:
                        if strcmp(localVar[temp6-1,3-1],'character'):
                            out=m_array([funstrwords[i-1][temp2-1],'=cell(1,',char(localVar[temp6-1,5-1]),');']).reshape(1,-1)
                        else:
                            if isempty(localVar[temp6-1,16-1]):
                                temp8='zeros'
                            else:
                                temp8='cell'
                            if want_row:
                                out=m_array([funstrwords[i-1][temp2-1],'=',temp8,'(1,',temp7[1-1],');']).reshape(1,-1)
                            else:
                                out=m_array([funstrwords[i-1][temp2-1],'=',temp8,'(',temp7[1-1],',1);']).reshape(1,-1)
                else:
                    if  not any(strcmp(localVar[temp6-1,3-1],var_words)):
                        subscripts2=m_array(['=',localVar[temp6-1,3-1],'(ones(']).reshape(1,-1)
                    else:
                        if strcmp(localVar[temp6-1,3-1],'character'):
                            subscripts2='=cell('
                        else:
                            subscripts2='=zeros('
                    for j in arange(1,howmany+1).reshape(1,-1).flat:
                        if j!=howmany:
                            subscripts2=m_array([subscripts2,temp7[j-1],',']).reshape(1,-1)
                        else:
                            subscripts2=m_array([subscripts2,temp7[j-1],');']).reshape(1,-1)
                    if  not any(strcmp(localVar[temp6-1,3-1],var_words)):
                        subscripts2=m_array([subscripts2[1-1:subscripts2.shape[0]-1+1-1],');']).reshape(1,-1)
                    out=m_array([funstrwords[i-1][temp2-1],subscripts2]).reshape(1,-1)
    else:
        if howmany>0:
            if strcmp(localVar[temp6-1,3-1],'character'):
                out=m_array([funstrwords[i-1][temp2-1],strrep(strrep(funstr[i-1][parens[int(2-1)]+1-1:funstr[i-1].shape[0]+1-1],'(/','{'),'/)','}')]).reshape(1,-1)
            else:
                temp4=cell(0,1)
                for j in arange(1,howmany+1).reshape(1,-1).flat:
                    subscripts[j-1]=strtrim(subscripts[j-1])
                    temp5=strfind(subscripts[j-1],':')
                    temp4[j-1]=subscripts[j-1]
                    if  not isempty(temp5):
                        if subscripts[j-1][int(1-1)]==':':
                            temp4[j-1]=m_array(['1',subscripts[j-1]]).reshape(1,-1)
                    else:
                        temp4[j-1]=m_array(['1:',subscripts[j-1]]).reshape(1,-1)
                    temp4[j-1]=m_array(['[',temp4[j-1],']']).reshape(1,-1)
                    temp5=find(strcmpi(funstrwords[i-1][temp2-1],[varp[:,1-1]]))
                    if  not isempty(temp5):
                        goon=find(j==varp[temp5-1,2-1])
                        if  not isempty(goon):
                            temp4[j-1]=m_array([temp4[j-1],'+',num2str(varp[temp5-1,3-1][int(goon-1)])]).reshape(1,-1)
                subscripts2=''
                for j in arange(1,howmany+1).reshape(1,-1).flat:
                    if j!=howmany:
                        subscripts2=m_array([subscripts2,temp4[j-1],',']).reshape(1,-1)
                    else:
                        subscripts2=m_array([subscripts2,temp4[j-1]]).reshape(1,-1)
                out=m_array([funstrwords[i-1][temp2-1],'(',subscripts2,')',funstr[i-1][parens[int(2-1)]+1-1:funstr[i-1].shape[0]+1-1]]).reshape(1,-1)
        else:
            out=funstr[i-1][funstrwords_b[i-1][int(temp2-1)]-1:funstr[i-1].shape[0]+1-1]
    return out
def ztest(**kwargs):
    persistent('n')
    if isempty(n()):
        n=5
    global bcom_1
    global bcom_2
    global bl1_1
    global bl1_2
    global bl2_1
    global bl2_2
    bcom_1=1
    bcom_2=2
    bl1_1=3
    bl1_2=4
    bl2_1=5
    bl2_2[:]=6
    fprintf(1,'%s ','bcom_1=')
    fprintf(1,'%0.15g \\n',bcom_1)
    fprintf(1,'%s ','bcom_2=')
    fprintf(1,'%0.15g \\n',bcom_2)
    fprintf(1,'%s ','bl1_1=')
    fprintf(1,'%0.15g \\n',bl1_1)
    fprintf(1,'%s ','bl1_2=')
    fprintf(1,'%0.15g \\n',bl1_2)
    fprintf(1,'%s ','bl2_1=')
    fprintf(1,'%0.15g \\n',bl2_1)
    fprintf(1,'%s ','bl2_2=')
    fprintf(1,'%0.15g \\n',bl2_2)
    sub1()
    fprintf(1,'%s ','bcom_1=')
    fprintf(1,'%0.15g \\n',bcom_1)
    fprintf(1,'%s ','bcom_2=')
    fprintf(1,'%0.15g \\n',bcom_2)
    fprintf(1,'%s ','bl1_1=')
    fprintf(1,'%0.15g \\n',bl1_1)
    fprintf(1,'%s ','bl1_2=')
    fprintf(1,'%0.15g \\n',bl1_2)
    fprintf(1,'%s ','bl2_1=')
    fprintf(1,'%0.15g \\n',bl2_1)
    fprintf(1,'%s ','bl2_2=')
    fprintf(1,'%0.15g \\n',bl2_2)
    return 
def sub1(**kwargs):
    global bcom_1
    global bcom_2
    global bl1_1
    global bl1_2
    bcom_1=10
    bcom_2=20
    bl1_1=30
    bl1_2=40
    b5=50
    b6=60
    return 
