# Autogenerated with SMOP version 0.20
import numpy,sys
from copy import copy as _copy
from smop.runtime import *
numpy.random.seed(0)
def bustypes(bus,gen,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    nb=size(bus,1)
    ng=size(gen,1)
    Cg=sparse(gen[:,GEN_BUS-1],(arange(1,ng+1).reshape(1,-1)).T,gen[:,GEN_STATUS-1]>0,nb,ng)
    bus_gen_status=Cg*ones(ng,1)
    ref=find(bus[:,BUS_TYPE-1]==REF&bus_gen_status)
    pv=find(bus[:,BUS_TYPE-1]==PV&bus_gen_status)
    pq=find(bus[:,BUS_TYPE-1]==PQ| not bus_gen_status)
    if isempty(ref):
        ref=pv[int(1-1)]
        pv=pv[2-1:length(pv)+1-1]
    return ref,pv,pq
def compare_case(mpc1,mpc2,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    baseMVA1,bus1,gen1,branch1=loadcase(mpc1,nargout=4)
    baseMVA2,bus2,gen2,branch2=loadcase(mpc2,nargout=4)
    solvedPF=0
    solvedOPF=0
    Nb=VMIN
    Ng=APF
    Nl=ANGMAX
    if size(branch1,2)>=QT and size(branch2,2)>=QT:
        solvedPF=1
        Nl=QT
        if size(branch1,2)>=MU_ST and size(branch2,2)>=MU_ST:
            solvedOPF=1
            Nb=MU_VMIN
            Ng=MU_QMIN
            Nl=MU_ST
    buscols=char('BUS_I','BUS_TYPE','PD','QD','GS','BS','BUS_AREA','VM','VA','BASE_KV','ZONE','VMAX','VMIN')
    gencols=char('GEN_BUS','PG','QG','QMAX','QMIN','VG','MBASE','GEN_STATUS','PMAX','PMIN','PC1','PC2','QC1MIN','QC1MAX','QC2MIN','QC2MAX','RAMP_AGC','RAMP_10','RAMP_30','RAMP_Q','APF')
    brcols=char('F_BUS','T_BUS','BR_R','BR_X','BR_B','RATE_A','RATE_B','RATE_C','TAP','SHIFT','BR_STATUS','ANGMIN','ANGMAX')
    if solvedPF:
        brcols=char(brcols,'PF','QF','PT','QT')
        if solvedOPF:
            buscols=char(buscols,'LAM_P','LAM_Q','MU_VMAX','MU_VMIN')
            gencols=char(gencols,'MU_PMAX','MU_PMIN','MU_QMAX','MU_QMIN')
            brcols=char(brcols,'MU_SF','MU_ST')
    fprintf('----------------  --------------  --------------  --------------  -----\\n')
    fprintf(' matrix / col         case 1          case 2        difference     row \\n')
    fprintf('----------------  --------------  --------------  --------------  -----\\n')
    temp,i=max(abs(bus1[:,1-1:Nb+1-1]-bus2[:,1-1:Nb+1-1]),nargout=2)
    v,gmax=max(temp,nargout=2)
    i=i[int(gmax-1)]
    fprintf('bus')
    nodiff=' : no differences found'
    for j in arange(1,size(buscols,1)+1).reshape(1,-1).flat:
        v,i=max(abs(bus1[:,j-1]-bus2[:,j-1]),nargout=2)
        if v:
            nodiff=''
            if j==gmax:
                s=' *'
            else:
                s=''
            fprintf('\\n  %-12s%16g%16g%16g%7d%s',buscols[j-1,:],bus1[i-1,j-1],bus2[i-1,j-1],v,i,s)
    fprintf('%s\\n',nodiff)
    temp,i=max(abs(gen1[:,1-1:Ng+1-1]-gen2[:,1-1:Ng+1-1]),nargout=2)
    v,gmax=max(temp,nargout=2)
    i=i[int(gmax-1)]
    fprintf('\\ngen')
    nodiff=' : no differences found'
    for j in arange(1,size(gencols,1)+1).reshape(1,-1).flat:
        v,i=max(abs(gen1[:,j-1]-gen2[:,j-1]),nargout=2)
        if v:
            nodiff=''
            if j==gmax:
                s=' *'
            else:
                s=''
            fprintf('\\n  %-12s%16g%16g%16g%7d%s',gencols[j-1,:],gen1[i-1,j-1],gen2[i-1,j-1],v,i,s)
    fprintf('%s\\n',nodiff)
    temp,i=max(abs(branch1[:,1-1:Nl+1-1]-branch2[:,1-1:Nl+1-1]),nargout=2)
    v,gmax=max(temp,nargout=2)
    i=i[int(gmax-1)]
    fprintf('\\nbranch')
    nodiff=' : no differences found'
    for j in arange(1,size(brcols,1)+1).reshape(1,-1).flat:
        v,i=max(abs(branch1[:,j-1]-branch2[:,j-1]),nargout=2)
        if v:
            nodiff=''
            if j==gmax:
                s=' *'
            else:
                s=''
            fprintf('\\n  %-12s%16g%16g%16g%7d%s',brcols[j-1,:],branch1[i-1,j-1],branch2[i-1,j-1],v,i,s)
    fprintf('%s\\n',nodiff)
    return 
def copf_solver(om,mpopt,**kwargs):
    mpopt=_copy(mpopt)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    verbose=mpopt[int(31-1)]
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,nargout=4)
    vv=get_idx(om)
    nb=size(bus,1)
    nl=size(branch,1)
    ny=getN(om,'var','y')
    x0,LB,UB=getv(om,nargout=3)
    nxyz=length(x0)
    om2=om
    om2=add_constraints(om2,'varlims',speye(nxyz,nxyz),LB,UB)
    vv,ll,nn=get_idx(om2,nargout=3)
    A,l,u=linear_constraints(om2,nargout=3)
    ieq=find(abs(u-l)<=eps())
    igt=find(u>=10000000000.0&l>-10000000000.0)
    ilt=find(l<=-10000000000.0&u<10000000000.0)
    ibx=find((abs(u-l)>eps())&(u<10000000000.0)&(l>-10000000000.0))
    Af=m_array([[A[ilt-1,:]],[-A[igt-1,:]],[A[ibx-1,:]],[-A[ibx-1,:]]]).reshape(1,-1)
    bf=m_array([[u[int(ilt-1)]],[-l[int(igt-1)]],[u[int(ibx-1)]],[-l[int(ibx-1)]]]).reshape(1,-1)
    Afeq=A[ieq-1,:]
    bfeq=u[int(ieq-1)]
    Ybus,Yf,Yt=makeYbus(baseMVA,bus,branch,nargout=3)
    il=find(branch[:,RATE_A-1]!=0&branch[:,RATE_A-1]<10000000000.0)
    nl2=length(il)
    mpopt[int(15-1)]=2*nb+length(bfeq)
    if mpopt[int(19-1)]==0:
        mpopt[int(19-1)]=150+2*nb
    otopt=foptions()
    otopt[int(1-1)]=(verbose>0)
    otopt[int(2-1)]=mpopt[int(17-1)]
    otopt[int(3-1)]=mpopt[int(18-1)]
    otopt[int(4-1)]=mpopt[int(16-1)]
    otopt[int(13-1)]=mpopt[int(15-1)]
    otopt[int(14-1)]=mpopt[int(19-1)]
    x,otopt,lambda_=constr('fun_copf',x0,otopt,m_array(),m_array(),'grad_copf',om2,Ybus,Yf[il-1,:],Yt[il-1,:],Afeq,bfeq,Af,bf,mpopt,il,nargout=3)
    f,g=feval('fun_copf',x,om2,Ybus,Yf[il-1,:],Yt[il-1,:],Afeq,bfeq,Af,bf,mpopt,il,nargout=2)
    if otopt[int(10-1)]>=otopt[int(14-1)] or max(abs(g[1-1:otopt[int(13-1)]+1-1]))>otopt[int(4-1)] or max(g[(otopt[int(13-1)]+1)-1:length(g)+1-1])>otopt[int(4-1)]:
        success=0
    else:
        success=1
    info=success
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    V=Vm*exp(1j*Va)
    bus[:,VA-1]=Va*180/pi()
    bus[:,VM-1]=Vm
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    gen[:,VG-1]=Vm[int(gen[:,GEN_BUS-1]-1)]
    Sf=V[int(branch[:,F_BUS-1]-1)]*conj(Yf*V)
    St=V[int(branch[:,T_BUS-1]-1)]*conj(Yt*V)
    branch[:,PF-1]=real(Sf)*baseMVA
    branch[:,QF-1]=imag(Sf)*baseMVA
    branch[:,PT-1]=real(St)*baseMVA
    branch[:,QT-1]=imag(St)*baseMVA
    nA=length(u)
    neq=length(ieq)
    nlt=length(ilt)
    ngt=length(igt)
    nbx=length(ibx)
    inln=m_array([(arange(1,2*nb+1).reshape(1,-1)),(arange(1,2*nl2+1).reshape(1,-1))+2*nb+neq]).reshape(1,-1)
    kl=find(lambda_[int(inln-1)]<0)
    ku=find(lambda_[int(inln-1)]>0)
    nl_mu_l=zeros(2*(nb+nl2),1)
    nl_mu_u=zeros(2*(nb+nl2),1)
    nl_mu_l[int(kl-1)]=-lambda_[int(inln[int(kl-1)]-1)]
    nl_mu_u[int(ku-1)]=lambda_[int(inln[int(ku-1)]-1)]
    ilin=m_array([(arange(1,neq+1).reshape(1,-1))+2*nb,(arange(1,(nlt+ngt+2*nbx)+1).reshape(1,-1))+2*nb+neq+2*nl2]).reshape(1,-1)
    kl=find(lambda_[int(ilin[1-1:neq+1-1]-1)]<0)
    ku=find(lambda_[int(ilin[1-1:neq+1-1]-1)]>0)
    mu_l=zeros(nA,1)
    mu_l[int(ieq-1)]=-lambda_[int(ilin[1-1:neq+1-1]-1)]
    mu_l[int(ieq[int(ku-1)]-1)]=0
    mu_l[int(igt-1)]=lambda_[int(ilin[int(neq+nlt+(arange(1,ngt+1).reshape(1,-1))-1)]-1)]
    mu_l[int(ibx-1)]=lambda_[int(ilin[int(neq+nlt+ngt+nbx+(arange(1,nbx+1).reshape(1,-1))-1)]-1)]
    mu_u=zeros(nA,1)
    mu_u[int(ieq-1)]=lambda_[int(ilin[1-1:neq+1-1]-1)]
    mu_u[int(ieq[int(kl-1)]-1)]=0
    mu_u[int(ilt-1)]=lambda_[int(ilin[int(neq+(arange(1,nlt+1).reshape(1,-1))-1)]-1)]
    mu_u[int(ibx-1)]=lambda_[int(ilin[int(neq+nlt+ngt+(arange(1,nbx+1).reshape(1,-1))-1)]-1)]
    muLB=mu_l[ll.i1.varlims-1:ll.iN.varlims+1-1]
    muUB=mu_u[ll.i1.varlims-1:ll.iN.varlims+1-1]
    mu_l[ll.i1.varlims-1:ll.iN.varlims+1-1]=m_array()
    mu_u[ll.i1.varlims-1:ll.iN.varlims+1-1]=m_array()
    muSf=zeros(nl,1)
    muSt=zeros(nl,1)
    muSf[int(il-1)]=2*nl_mu_u[int((arange(1,nl2+1).reshape(1,-1))+2*nb-1)]*branch[il-1,RATE_A-1]/baseMVA
    muSt[int(il-1)]=2*nl_mu_u[int((arange(1,nl2+1).reshape(1,-1))+2*nb+nl2-1)]*branch[il-1,RATE_A-1]/baseMVA
    nl_mu_l=m_array([[nl_mu_l[1-1:2*nb+1-1]],[zeros(2*nl,1)]]).reshape(1,-1)
    nl_mu_u=m_array([[nl_mu_u[1-1:2*nb+1-1]],[muSf],[muSt]]).reshape(1,-1)
    bus[:,MU_VMAX-1]=muUB[vv.i1.Vm-1:vv.iN.Vm+1-1]
    bus[:,MU_VMIN-1]=muLB[vv.i1.Vm-1:vv.iN.Vm+1-1]
    gen[:,MU_PMAX-1]=muUB[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_PMIN-1]=muLB[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_QMAX-1]=muUB[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    gen[:,MU_QMIN-1]=muLB[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    bus[:,LAM_P-1]=(nl_mu_u[nn.i1.Pmis-1:nn.iN.Pmis+1-1]-nl_mu_l[nn.i1.Pmis-1:nn.iN.Pmis+1-1])/baseMVA
    bus[:,LAM_Q-1]=(nl_mu_u[nn.i1.Qmis-1:nn.iN.Qmis+1-1]-nl_mu_l[nn.i1.Qmis-1:nn.iN.Qmis+1-1])/baseMVA
    branch[:,MU_SF-1]=muSf/baseMVA
    branch[:,MU_ST-1]=muSt/baseMVA
    mu=struct('var',struct('l',muLB,'u',muUB),'nln',struct('l',nl_mu_l,'u',nl_mu_u),'lin',struct('l',mu_l,'u',mu_u))
    results=_copy(mpc)
    results.bus,results.branch,results.gen,results.om,results.x,results.mu,results.f=deal(bus,branch,gen,om,x,mu,f,nargout=7)
    pimul=m_array([[results.mu.nln.l-results.mu.nln.u],[results.mu.lin.l-results.mu.lin.u],[-ones(ny>0,1)],[results.mu.var.l-results.mu.var.u]]).reshape(1,-1)
    raw=struct('xr',x,'pimul',pimul,'info',info)
    return results,success,raw
def d2AIbr_dV2(dIbr_dVa,dIbr_dVm,Ibr,Ybr,V,lam,**kwargs):
    nl=length(lam)
    diaglam=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),lam,nl,nl)
    diagIbr_conj=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),conj(Ibr),nl,nl)
    Iaa,Iav,Iva,Ivv=d2Ibr_dV2(Ybr,V,diagIbr_conj*lam,nargout=4)
    Haa=2*real(Iaa+dIbr_dVa.T*diaglam*conj(dIbr_dVa))
    Hva=2*real(Iva+dIbr_dVm.T*diaglam*conj(dIbr_dVa))
    Hav=2*real(Iav+dIbr_dVa.T*diaglam*conj(dIbr_dVm))
    Hvv=2*real(Ivv+dIbr_dVm.T*diaglam*conj(dIbr_dVm))
    return Haa,Hav,Hva,Hvv
def d2ASbr_dV2(dSbr_dVa,dSbr_dVm,Sbr,Cbr,Ybr,V,lam,**kwargs):
    nl=length(lam)
    diaglam=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),lam,nl,nl)
    diagSbr_conj=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),conj(Sbr),nl,nl)
    Saa,Sav,Sva,Svv=d2Sbr_dV2(Cbr,Ybr,V,diagSbr_conj*lam,nargout=4)
    Haa=2*real(Saa+dSbr_dVa.T*diaglam*conj(dSbr_dVa))
    Hva=2*real(Sva+dSbr_dVm.T*diaglam*conj(dSbr_dVa))
    Hav=2*real(Sav+dSbr_dVa.T*diaglam*conj(dSbr_dVm))
    Hvv=2*real(Svv+dSbr_dVm.T*diaglam*conj(dSbr_dVm))
    return Haa,Hav,Hva,Hvv
def d2Ibr_dV2(Ybr,V,lam,**kwargs):
    nb=length(V)
    diaginvVm=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),ones(nb,1)/abs(V),nb,nb)
    Haa=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),-(Ybr.T*lam)*V,nb,nb)
    Hva=-1j*Haa*diaginvVm
    Hav=Hva
    Hvv=sparse(nb,nb)
    return Haa,Hav,Hva,Hvv
def d2Sbr_dV2(Cbr,Ybr,V,lam,**kwargs):
    nl=length(lam)
    nb=length(V)
    diaglam=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),lam,nl,nl)
    diagV=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),V,nb,nb)
    A=Ybr.T*diaglam*Cbr
    B=conj(diagV)*A*diagV
    D=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),(A*V)*conj(V),nb,nb)
    E=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),(A.T*conj(V))*V,nb,nb)
    F=B+B.T
    G=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),ones(nb,1)/abs(V),nb,nb)
    Haa=F-D-E
    Hva=1j*G*(B-B.T-D+E)
    Hav=Hva.T
    Hvv=G*F*G
    return Haa,Hav,Hva,Hvv
def d2Sbus_dV2(Ybus,V,lam,**kwargs):
    n=length(V)
    Ibus=Ybus*V
    diaglam=sparse(arange(1,n+1).reshape(1,-1),arange(1,n+1).reshape(1,-1),lam,n,n)
    diagV=sparse(arange(1,n+1).reshape(1,-1),arange(1,n+1).reshape(1,-1),V,n,n)
    A=sparse(arange(1,n+1).reshape(1,-1),arange(1,n+1).reshape(1,-1),lam*V,n,n)
    B=Ybus*diagV
    C=A*conj(B)
    D=Ybus.T*diagV
    E=conj(diagV)*(D*diaglam-sparse(arange(1,n+1).reshape(1,-1),arange(1,n+1).reshape(1,-1),D*lam,n,n))
    F=C-A*sparse(arange(1,n+1).reshape(1,-1),arange(1,n+1).reshape(1,-1),conj(Ibus),n,n)
    G=sparse(arange(1,n+1).reshape(1,-1),arange(1,n+1).reshape(1,-1),ones(n,1)/abs(V),n,n)
    Gaa=E+F
    Gva=1j*G*(E-F)
    Gav=Gva.T
    Gvv=G*(C+C.T)*G
    return Gaa,Gav,Gva,Gvv
def dAbr_dV(dSf_dVa,dSf_dVm,dSt_dVa,dSt_dVm,Sf,St,**kwargs):
    nl=length(Sf)
    dAf_dPf=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),2*real(Sf),nl,nl)
    dAf_dQf=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),2*imag(Sf),nl,nl)
    dAt_dPt=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),2*real(St),nl,nl)
    dAt_dQt=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),2*imag(St),nl,nl)
    dAf_dVm=dAf_dPf*real(dSf_dVm)+dAf_dQf*imag(dSf_dVm)
    dAf_dVa=dAf_dPf*real(dSf_dVa)+dAf_dQf*imag(dSf_dVa)
    dAt_dVm=dAt_dPt*real(dSt_dVm)+dAt_dQt*imag(dSt_dVm)
    dAt_dVa=dAt_dPt*real(dSt_dVa)+dAt_dQt*imag(dSt_dVa)
    return dAf_dVa,dAf_dVm,dAt_dVa,dAt_dVm
def dcopf_solver(om,mpopt,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    verbose=mpopt[int(31-1)]
    alg=mpopt[int(26-1)]
    if alg==0:
        if have_fcn('cplex'):
            alg=500
        else:
            if have_fcn('mosek'):
                alg=600
            else:
                if have_fcn('gurobi'):
                    alg=700
                else:
                    if have_fcn('bpmpd'):
                        alg=100
                    else:
                        if have_fcn('quadprog'):
                            alg=300
                        else:
                            alg=200
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch,gencost=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,mpc.gencost,nargout=5)
    cp=get_cost_params(om)
    N,H,Cw=deal(cp.N,cp.H,cp.Cw,nargout=3)
    fparm=m_array([cp.dd,cp.rh,cp.kk,cp.mm]).reshape(1,-1)
    Bf=userdata(om,'Bf')
    Pfinj=userdata(om,'Pfinj')
    vv,ll=get_idx(om,nargout=2)
    ipol=find(gencost[:,MODEL-1]==POLYNOMIAL)
    ipwl=find(gencost[:,MODEL-1]==PW_LINEAR)
    nb=size(bus,1)
    nl=size(branch,1)
    nw=size(N,1)
    ny=getN(om,'var','y')
    nxyz=getN(om,'var')
    A,l,u=linear_constraints(om,nargout=3)
    x0,xmin,xmax=getv(om,nargout=3)
    any_pwl=(ny>0)
    if any_pwl:
        Npwl=sparse(ones(ny,1),arange(vv.i1.y,vv.iN.y+1).reshape(1,-1),1,1,nxyz)
        Hpwl=0
        Cpwl=1
        fparm_pwl=m_array([1,0,0,1]).reshape(1,-1)
    else:
        Npwl=sparse(0,nxyz)
        Hpwl=m_array()
        Cpwl=m_array()
        fparm_pwl=m_array()
    npol=length(ipol)
    if any(find(gencost[ipol-1,NCOST-1]>3)):
        error('DC opf cannot handle polynomial costs with higher than quadratic order.')
    iqdr=find(gencost[ipol-1,NCOST-1]==3)
    ilin=find(gencost[ipol-1,NCOST-1]==2)
    polycf=zeros(npol,3)
    if  not isempty(iqdr):
        polycf[iqdr-1,:]=gencost[ipol[int(iqdr-1)]-1,COST-1:COST+2+1-1]
    polycf[ilin-1,2-1:3+1-1]=gencost[ipol[int(ilin-1)]-1,COST-1:COST+1+1-1]
    polycf=polycf*diag(m_array([baseMVA**2,baseMVA,1]).reshape(1,-1))
    Npol=sparse(arange(1,npol+1).reshape(1,-1),vv.i1.Pg-1+ipol,1,npol,nxyz)
    Hpol=sparse(arange(1,npol+1).reshape(1,-1),arange(1,npol+1).reshape(1,-1),2*polycf[:,1-1],npol,npol)
    Cpol=polycf[:,2-1]
    fparm_pol=ones(npol,1)*m_array([1,0,0,1]).reshape(1,-1)
    NN=m_array([[Npwl],[Npol],[N]]).reshape(1,-1)
    HHw=m_array([[Hpwl,sparse(any_pwl,npol+nw)],[sparse(npol,any_pwl),Hpol,sparse(npol,nw)],[sparse(nw,any_pwl+npol),H]]).reshape(1,-1)
    CCw=m_array([[Cpwl],[Cpol],[Cw]]).reshape(1,-1)
    ffparm=m_array([[fparm_pwl],[fparm_pol],[fparm]]).reshape(1,-1)
    nnw=any_pwl+npol+nw
    M=sparse(arange(1,nnw+1).reshape(1,-1),arange(1,nnw+1).reshape(1,-1),ffparm[:,4-1],nnw,nnw)
    MR=M*ffparm[:,2-1]
    HMR=HHw*MR
    MN=M*NN
    HH=MN.T*HHw*MN
    CC=full(MN.T*(CCw-HMR))
    C0=1/2*MR.T*HMR+sum(polycf[:,3-1])
    opt=struct('alg',alg,'verbose',verbose)
    if [200,250]==alg:
        Varefs=bus[bus[:,BUS_TYPE-1]==REF,VA-1]*(pi()/180)
        lb=_copy(xmin)
        ub=_copy(xmax)
        lb[int(xmin==-Inf())]=-10000000000.0
        ub[int(xmax==Inf())]=10000000000.0
        x0=(lb+ub)/2
        x0[vv.i1.Va-1:vv.iN.Va+1-1]=Varefs[int(1-1)]
        if ny>0:
            ipwl=find(gencost[:,MODEL-1]==PW_LINEAR)
            c=gencost[int(sub2ind(size(gencost),ipwl,NCOST+2*gencost[ipwl-1,NCOST-1])-1)]
            x0[vv.i1.y-1:vv.iN.y+1-1]=max(c)+0.1*abs(max(c))
        feastol=mpopt[int(81-1)]
        gradtol=mpopt[int(82-1)]
        comptol=mpopt[int(83-1)]
        costtol=mpopt[int(84-1)]
        max_it=mpopt[int(85-1)]
        max_red=mpopt[int(86-1)]
        if feastol==0:
            feastol=mpopt[int(16-1)]
        opt.mips_opt=struct('feastol',feastol,'gradtol',gradtol,'comptol',comptol,'costtol',costtol,'max_it',max_it,'max_red',max_red,'cost_mult',1)
    else:
        if 400==alg:
            opt.ipopt_opt=ipopt_options(m_array(),mpopt)
        else:
            if 500==alg:
                opt.cplex_opt=cplex_options(m_array(),mpopt)
            else:
                if 600==alg:
                    opt.mosek_opt=mosek_options(m_array(),mpopt)
                else:
                    if 700==alg:
                        opt.grb_opt=gurobi_options(m_array(),mpopt)
    x,f,info,output,lambda_=qps_matpower(HH,CC,A,l,u,xmin,xmax,x0,opt,nargout=5)
    success=(info==1)
    if  not any(isnan(x)):
        Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
        Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
        f=f+C0
        bus[:,VA-1]=Va*180/pi()
        gen[:,PG-1]=Pg*baseMVA
        branch[:,m_array([QF,QT]).reshape(1,-1)-1]=zeros(nl,2)
        branch[:,PF-1]=(Bf*Va+Pfinj)*baseMVA
        branch[:,PT-1]=-branch[:,PF-1]
    mu_l=lambda_.mu_l
    mu_u=lambda_.mu_u
    muLB=lambda_.lower
    muUB=lambda_.upper
    il=find(branch[:,RATE_A-1]!=0&branch[:,RATE_A-1]<10000000000.0)
    bus[:,m_array([LAM_P,LAM_Q,MU_VMIN,MU_VMAX]).reshape(1,-1)-1]=zeros(nb,4)
    gen[:,m_array([MU_PMIN,MU_PMAX,MU_QMIN,MU_QMAX]).reshape(1,-1)-1]=zeros(size(gen,1),4)
    branch[:,m_array([MU_SF,MU_ST]).reshape(1,-1)-1]=zeros(nl,2)
    bus[:,LAM_P-1]=(mu_u[ll.i1.Pmis-1:ll.iN.Pmis+1-1]-mu_l[ll.i1.Pmis-1:ll.iN.Pmis+1-1])/baseMVA
    branch[il-1,MU_SF-1]=mu_u[ll.i1.Pf-1:ll.iN.Pf+1-1]/baseMVA
    branch[il-1,MU_ST-1]=mu_u[ll.i1.Pt-1:ll.iN.Pt+1-1]/baseMVA
    gen[:,MU_PMIN-1]=muLB[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_PMAX-1]=muUB[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    pimul=m_array([[mu_l-mu_u],[-ones(ny>0,1)],[muLB-muUB]]).reshape(1,-1)
    mu=struct('var',struct('l',muLB,'u',muUB),'lin',struct('l',mu_l,'u',mu_u))
    results=_copy(mpc)
    results.bus,results.branch,results.gen,results.om,results.x,results.mu,results.f=deal(bus,branch,gen,om,x,mu,f,nargout=7)
    raw=struct('xr',x,'pimul',pimul,'info',info,'output',output)
    return results,success,raw
def dcpf(B,Pbus,Va0,ref,pv,pq,**kwargs):
    Va=_copy(Va0)
    Va[int(m_array([[pv],[pq]]).reshape(1,-1)-1)]=numpy.linalg.solve(B[m_array([[pv],[pq]]).reshape(1,-1)-1,m_array([[pv],[pq]]).reshape(1,-1)-1],(Pbus[int(m_array([[pv],[pq]]).reshape(1,-1)-1)]-B[m_array([[pv],[pq]]).reshape(1,-1)-1,ref-1]*Va0[int(ref-1)]))
    return Va
def dIbr_dV(branch,Yf,Yt,V,**kwargs):
    nb=length(V)
    Vnorm=V/abs(V)
    if issparse(Yf):
        diagV=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),V,nb,nb)
        diagVnorm=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),Vnorm,nb,nb)
    else:
        diagV=diag(V)
        diagVnorm=diag(Vnorm)
    dIf_dVa=Yf*1j*diagV
    dIf_dVm=Yf*diagVnorm
    dIt_dVa=Yt*1j*diagV
    dIt_dVm=Yt*diagVnorm
    if nargout()>4:
        If=Yf*V
        It=Yt*V
    return dIf_dVa,dIf_dVm,dIt_dVa,dIt_dVm,If,It
def dSbr_dV(branch,Yf,Yt,V,**kwargs):
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    f=branch[:,F_BUS-1]
    t=branch[:,T_BUS-1]
    nl=length(f)
    nb=length(V)
    If=Yf*V
    It=Yt*V
    Vnorm=V/abs(V)
    if issparse(Yf):
        diagVf=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),V[int(f-1)],nl,nl)
        diagIf=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),If,nl,nl)
        diagVt=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),V[int(t-1)],nl,nl)
        diagIt=sparse(arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1),It,nl,nl)
        diagV=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),V,nb,nb)
        diagVnorm=sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),Vnorm,nb,nb)
        dSf_dVa=1j*(conj(diagIf)*sparse(arange(1,nl+1).reshape(1,-1),f,V[int(f-1)],nl,nb)-diagVf*conj(Yf*diagV))
        dSf_dVm=diagVf*conj(Yf*diagVnorm)+conj(diagIf)*sparse(arange(1,nl+1).reshape(1,-1),f,Vnorm[int(f-1)],nl,nb)
        dSt_dVa=1j*(conj(diagIt)*sparse(arange(1,nl+1).reshape(1,-1),t,V[int(t-1)],nl,nb)-diagVt*conj(Yt*diagV))
        dSt_dVm=diagVt*conj(Yt*diagVnorm)+conj(diagIt)*sparse(arange(1,nl+1).reshape(1,-1),t,Vnorm[int(t-1)],nl,nb)
    else:
        diagVf=diag(V[int(f-1)])
        diagIf=diag(If)
        diagVt=diag(V[int(t-1)])
        diagIt=diag(It)
        diagV=diag(V)
        diagVnorm=diag(Vnorm)
        temp1=zeros(nl,nb)
        temp1[int(sub2ind(m_array([nl,nb]).reshape(1,-1),(arange(1,nl+1).reshape(1,-1)).T,f)-1)]=V[int(f-1)]
        temp2=zeros(nl,nb)
        temp2[int(sub2ind(m_array([nl,nb]).reshape(1,-1),(arange(1,nl+1).reshape(1,-1)).T,f)-1)]=Vnorm[int(f-1)]
        temp3=zeros(nl,nb)
        temp3[int(sub2ind(m_array([nl,nb]).reshape(1,-1),(arange(1,nl+1).reshape(1,-1)).T,t)-1)]=V[int(t-1)]
        temp4=zeros(nl,nb)
        temp4[int(sub2ind(m_array([nl,nb]).reshape(1,-1),(arange(1,nl+1).reshape(1,-1)).T,t)-1)]=Vnorm[int(t-1)]
        dSf_dVa=1j*(conj(diagIf)*temp1-diagVf*conj(Yf*diagV))
        dSf_dVm=diagVf*conj(Yf*diagVnorm)+conj(diagIf)*temp2
        dSt_dVa=1j*(conj(diagIt)*temp3-diagVt*conj(Yt*diagV))
        dSt_dVm=diagVt*conj(Yt*diagVnorm)+conj(diagIt)*temp4
    if nargout()>4:
        Sf=V[int(f-1)]*conj(If)
        St=V[int(t-1)]*conj(It)
    return dSf_dVa,dSf_dVm,dSt_dVa,dSt_dVm,Sf,St
def dSbus_dV(Ybus,V,**kwargs):
    n=length(V)
    Ibus=Ybus*V
    if issparse(Ybus):
        diagV=sparse(arange(1,n+1).reshape(1,-1),arange(1,n+1).reshape(1,-1),V,n,n)
        diagIbus=sparse(arange(1,n+1).reshape(1,-1),arange(1,n+1).reshape(1,-1),Ibus,n,n)
        diagVnorm=sparse(arange(1,n+1).reshape(1,-1),arange(1,n+1).reshape(1,-1),V/abs(V),n,n)
    else:
        diagV=diag(V)
        diagIbus=diag(Ibus)
        diagVnorm=diag(V/abs(V))
    dSbus_dVm=diagV*conj(Ybus*diagVnorm)+conj(diagIbus)*diagVnorm
    dSbus_dVa=1j*diagV*conj(diagIbus-Ybus*diagV)
    return dSbus_dVm,dSbus_dVa
def ext2int(bus,gen,branch,areas,**kwargs):
    bus=_copy(bus)
    gen=_copy(gen)
    branch=_copy(branch)
    areas=_copy(areas)
    if isstruct(bus):
        mpc=_copy(bus)
        if nargin()==1:
            first= not isfield(mpc,'order')
            if first or mpc.order.state=='e':
                PQ,PV,REF,NONE,BUS_I,BUS_TYPE=idx_bus(nargout=6)
                GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS=idx_gen(nargout=8)
                F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS=idx_brch(nargout=11)
                AREA_I,PRICE_REF_BUS=idx_area(nargout=2)
                if first:
                    status=struct('on',m_array(),'off',m_array())
                    tmp=struct('e2i',m_array(),'i2e',m_array(),'status',status)
                    o=struct('ext',struct('bus',m_array(),'branch',m_array(),'gen',m_array()),'bus',tmp,'gen',tmp,'branch',struct('status',status))
                else:
                    o=mpc.order
                nb=size(mpc.bus,1)
                ng=size(mpc.gen,1)
                ng0=ng
                if isfield(mpc,'A') and size(mpc.A,2)<2*nb+2*ng:
                    dc=1
                else:
                    if isfield(mpc,'N') and size(mpc.N,2)<2*nb+2*ng:
                        dc=1
                    else:
                        dc=0
                o.ext.bus=mpc.bus
                o.ext.branch=mpc.branch
                o.ext.gen=mpc.gen
                if isfield(mpc,'areas'):
                    if isempty(mpc.areas):
                        mpc=rmfield(mpc,'areas')
                    else:
                        o.ext.areas=mpc.areas
                bt=mpc.bus[:,BUS_TYPE-1]
                err=find( not (bt==PQ|bt==PV|bt==REF|bt==NONE))
                if  not isempty(err):
                    error('ext2int: bus %d has an invalid BUS_TYPE',err)
                n2i=sparse(mpc.bus[:,BUS_I-1],ones(nb,1),arange(1,nb+1).reshape(1,-1),max(mpc.bus[:,BUS_I-1]),1)
                bs=(bt!=NONE)
                o.bus.status.on=find(bs)
                o.bus.status.off=find( not bs)
                gs=(mpc.gen[:,GEN_STATUS-1]>0&bs[int(n2i[int(mpc.gen[:,GEN_BUS-1]-1)]-1)])
                o.gen.status.on=find(gs)
                o.gen.status.off=find( not gs)
                brs=(mpc.branch[:,BR_STATUS-1]&bs[int(n2i[int(mpc.branch[:,F_BUS-1]-1)]-1)]&bs[int(n2i[int(mpc.branch[:,T_BUS-1]-1)]-1)])
                o.branch.status.on=find(brs)
                o.branch.status.off=find( not brs)
                if isfield(mpc,'areas'):
                    as=bs[int(n2i[int(mpc.areas[:,PRICE_REF_BUS-1]-1)]-1)]
                    o.areas.status.on=find(as)
                    o.areas.status.off=find( not as)
                if  not isempty(o.bus.status.off):
                    mpc.bus[o.bus.status.off-1,:]=m_array()
                if  not isempty(o.branch.status.off):
                    mpc.branch[o.branch.status.off-1,:]=m_array()
                if  not isempty(o.gen.status.off):
                    mpc.gen[o.gen.status.off-1,:]=m_array()
                if isfield(mpc,'areas') and  not isempty(o.areas.status.off):
                    mpc.areas[o.areas.status.off-1,:]=m_array()
                nb=size(mpc.bus,1)
                o.bus.i2e=mpc.bus[:,BUS_I-1]
                o.bus.e2i=sparse(max(o.bus.i2e),1)
                o.bus.e2i[int(o.bus.i2e-1)]=(arange(1,nb+1).reshape(1,-1)).T
                mpc.bus[:,BUS_I-1]=o.bus.e2i[int(mpc.bus[:,BUS_I-1]-1)]
                mpc.gen[:,GEN_BUS-1]=o.bus.e2i[int(mpc.gen[:,GEN_BUS-1]-1)]
                mpc.branch[:,F_BUS-1]=o.bus.e2i[int(mpc.branch[:,F_BUS-1]-1)]
                mpc.branch[:,T_BUS-1]=o.bus.e2i[int(mpc.branch[:,T_BUS-1]-1)]
                if isfield(mpc,'areas'):
                    mpc.areas[:,PRICE_REF_BUS-1]=o.bus.e2i[int(mpc.areas[:,PRICE_REF_BUS-1]-1)]
                tmp,o.gen.e2i=sort(mpc.gen[:,GEN_BUS-1],nargout=2)
                tmp,o.gen.i2e=sort(o.gen.e2i,nargout=2)
                mpc.gen=mpc.gen[o.gen.e2i-1,:]
                if isfield(o,'int'):
                    o=rmfield(o,'int')
                o.state='i'
                mpc.order=o
                if isfield(mpc,'gencost'):
                    ordering=['gen']
                    if size(mpc.gencost,1)==2*ng0:
                        ordering[2-1]='gen'
                    mpc=e2i_field(mpc,'gencost',ordering)
                if isfield(mpc,'A') or isfield(mpc,'N'):
                    if dc:
                        ordering=['bus','gen']
                    else:
                        ordering=['bus','bus','gen','gen']
                if isfield(mpc,'A'):
                    mpc=e2i_field(mpc,'A',ordering,2)
                if isfield(mpc,'N'):
                    mpc=e2i_field(mpc,'N',ordering,2)
                if isfield(mpc,'userfcn'):
                    mpc=run_userfcn(mpc.userfcn,'ext2int',mpc)
            i2e=mpc
        else:
            ordering=branch
            if nargin()<4:
                dim=1
            else:
                dim=areas
            if ischar(gen) or iscell(gen):
                warning("Calls of the form MPC = EXT2INT(MPC, 'FIELD_NAME', ...) have been deprecated. Please replace EXT2INT with E2I_FIELD.")
                i2e=e2i_field(mpc,gen,branch,dim)
            else:
                warning('Calls of the form VAL = EXT2INT(MPC, VAL, ...) have been deprecated. Please replace EXT2INT with E2I_DATA.')
                i2e=e2i_data(mpc,gen,branch,dim)
    else:
        PQ,PV,REF,NONE,BUS_I=idx_bus(nargout=5)
        GEN_BUS=idx_gen(nargout=1)
        F_BUS,T_BUS=idx_brch(nargout=2)
        AREA_I,PRICE_REF_BUS=idx_area(nargout=2)
        i2e=bus[:,BUS_I-1]
        e2i=sparse(max(i2e),1)
        e2i[int(i2e-1)]=(arange(1,size(bus,1)+1).reshape(1,-1)).T
        bus[:,BUS_I-1]=e2i[int(bus[:,BUS_I-1]-1)]
        gen[:,GEN_BUS-1]=e2i[int(gen[:,GEN_BUS-1]-1)]
        branch[:,F_BUS-1]=e2i[int(branch[:,F_BUS-1]-1)]
        branch[:,T_BUS-1]=e2i[int(branch[:,T_BUS-1]-1)]
        if nargin()>3 and nargout()>4 and  not isempty(areas):
            areas[:,PRICE_REF_BUS-1]=e2i[int(areas[:,PRICE_REF_BUS-1]-1)]
    return i2e,bus,gen,branch,areas
def fairmax(x,**kwargs):
    val=max(x)
    i=find(x==val)
    n=length(i)
    idx=i[int(fix(n*rand())+1-1)]
    return val,idx
def fdpf(Ybus,Sbus,V0,Bp,Bpp,ref,pv,pq,mpopt,**kwargs):
    if nargin()<7:
        mpopt=mpoption()
    tol=mpopt[int(2-1)]
    max_it=mpopt[int(4-1)]
    verbose=mpopt[int(31-1)]
    converged=0
    i=0
    V=V0
    Va=angle(V)
    Vm=abs(V)
    npv=length(pv)
    npq=length(pq)
    mis=(V*conj(Ybus*V)-Sbus)/Vm
    P=real(mis[int(m_array([[pv],[pq]]).reshape(1,-1)-1)])
    Q=imag(mis[int(pq-1)])
    normP=norm(P,inf())
    normQ=norm(Q,inf())
    if verbose>1:
        fprintf('\\niteration     max mismatch (p.u.)  ')
        fprintf('\\ntype   #        P            Q     ')
        fprintf('\\n---- ----  -----------  -----------')
        fprintf('\\n  -  %3d   %10.3e   %10.3e',i,normP,normQ)
    if normP<tol and normQ<tol:
        converged=1
        if verbose>1:
            fprintf('\\nConverged!\\n')
    Bp=Bp[m_array([[pv],[pq]]).reshape(1,-1)-1,m_array([[pv],[pq]]).reshape(1,-1)-1]
    Bpp=Bpp[pq-1,pq-1]
    Lp,Up,Pp=lu(Bp,nargout=3)
    Lpp,Upp,Ppp=lu(Bpp,nargout=3)
    while ( not converged and i<max_it):
        i=i+1
        dVa=-(numpy.linalg.solve(Up,(numpy.linalg.solve(Lp,(Pp*P)))))
        Va[int(m_array([[pv],[pq]]).reshape(1,-1)-1)]=Va[int(m_array([[pv],[pq]]).reshape(1,-1)-1)]+dVa
        V=Vm*exp(1j*Va)
        mis=(V*conj(Ybus*V)-Sbus)/Vm
        P=real(mis[int(m_array([[pv],[pq]]).reshape(1,-1)-1)])
        Q=imag(mis[int(pq-1)])
        normP=norm(P,inf())
        normQ=norm(Q,inf())
        if verbose>1:
            fprintf('\\n  P  %3d   %10.3e   %10.3e',i,normP,normQ)
        if normP<tol and normQ<tol:
            converged=1
            if verbose:
                fprintf('\\nFast-decoupled power flow converged in %d P-iterations and %d Q-iterations.\\n',i,i-1)
            break
        dVm=-(numpy.linalg.solve(Upp,(numpy.linalg.solve(Lpp,(Ppp*Q)))))
        Vm[int(pq-1)]=Vm[int(pq-1)]+dVm
        V=Vm*exp(1j*Va)
        mis=(V*conj(Ybus*V)-Sbus)/Vm
        P=real(mis[int(m_array([[pv],[pq]]).reshape(1,-1)-1)])
        Q=imag(mis[int(pq-1)])
        normP=norm(P,inf())
        normQ=norm(Q,inf())
        if verbose>1:
            fprintf('\\n  Q  %3d   %10.3e   %10.3e',i,normP,normQ)
        if normP<tol and normQ<tol:
            converged=1
            if verbose:
                fprintf('\\nFast-decoupled power flow converged in %d P-iterations and %d Q-iterations.\\n',i,i)
            break
    if verbose:
        if  not converged:
            fprintf('\\nFast-decoupled power flow did not converge in %d iterations.\\n',i)
    return V,converged,i
def fmincopf6_solver(om,mpopt,**kwargs):
    mpopt=_copy(mpopt)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    verbose=mpopt[int(31-1)]
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,nargout=4)
    vv,ll,nn=get_idx(om,nargout=3)
    nb=size(bus,1)
    nl=size(branch,1)
    ny=getN(om,'var','y')
    x0,LB,UB=getv(om,nargout=3)
    A,l,u=linear_constraints(om,nargout=3)
    ieq=find(abs(u-l)<=eps())
    igt=find(u>=10000000000.0&l>-10000000000.0)
    ilt=find(l<=-10000000000.0&u<10000000000.0)
    ibx=find((abs(u-l)>eps())&(u<10000000000.0)&(l>-10000000000.0))
    Af=m_array([[A[ilt-1,:]],[-A[igt-1,:]],[A[ibx-1,:]],[-A[ibx-1,:]]]).reshape(1,-1)
    bf=m_array([[u[int(ilt-1)]],[-l[int(igt-1)]],[u[int(ibx-1)]],[-l[int(ibx-1)]]]).reshape(1,-1)
    Afeq=A[ieq-1,:]
    bfeq=u[int(ieq-1)]
    Ybus,Yf,Yt=makeYbus(baseMVA,bus,branch,nargout=3)
    il=find(branch[:,RATE_A-1]!=0&branch[:,RATE_A-1]<10000000000.0)
    nl2=length(il)
    fmoptions=optimset('GradObj','on','GradConstr','on','TolCon',mpopt[int(16-1)],'TolX',mpopt[int(17-1)],'TolFun',mpopt[int(18-1)])
    if mpopt[int(19-1)]!=0:
        fmoptions=optimset(fmoptions,'MaxIter',mpopt[int(19-1)],'MaxFunEvals',4*mpopt[int(19-1)])
    if verbose==0:
        fmoptions.Display='off'
    else:
        if verbose==1:
            fmoptions.Display='iter'
        else:
            fmoptions.Display='testing'
    fmoptions=optimset(fmoptions,'LargeScale','off')
    Af=full(Af)
    Afeq=full(Afeq)
    f_fcn=opf_costfcn()
    gh_fcn=opf_consfcn()
    mpopt[int(51-1)]=0
    x,f,info,Output,Lambda=fmincon(f_fcn,x0,Af,bf,Afeq,bfeq,LB,UB,gh_fcn,fmoptions,om,Ybus,Yf[il-1,:],Yt[il-1,:],mpopt,il,nargout=5)
    success=(info>0)
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    V=Vm*exp(1j*Va)
    bus[:,VA-1]=Va*180/pi()
    bus[:,VM-1]=Vm
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    gen[:,VG-1]=Vm[int(gen[:,GEN_BUS-1]-1)]
    Sf=V[int(branch[:,F_BUS-1]-1)]*conj(Yf*V)
    St=V[int(branch[:,T_BUS-1]-1)]*conj(Yt*V)
    branch[:,PF-1]=real(Sf)*baseMVA
    branch[:,QF-1]=imag(Sf)*baseMVA
    branch[:,PT-1]=real(St)*baseMVA
    branch[:,QT-1]=imag(St)*baseMVA
    muSf=zeros(nl,1)
    muSt=zeros(nl,1)
    if  not isempty(il):
        muSf[int(il-1)]=2*Lambda.ineqnonlin[1-1:nl2+1-1]*branch[il-1,RATE_A-1]/baseMVA
        muSt[int(il-1)]=2*Lambda.ineqnonlin[int((arange(1,nl2+1).reshape(1,-1))+nl2-1)]*branch[il-1,RATE_A-1]/baseMVA
    bus[:,MU_VMAX-1]=Lambda.upper[vv.i1.Vm-1:vv.iN.Vm+1-1]
    bus[:,MU_VMIN-1]=Lambda.lower[vv.i1.Vm-1:vv.iN.Vm+1-1]
    gen[:,MU_PMAX-1]=Lambda.upper[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_PMIN-1]=Lambda.lower[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_QMAX-1]=Lambda.upper[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    gen[:,MU_QMIN-1]=Lambda.lower[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    bus[:,LAM_P-1]=Lambda.eqnonlin[nn.i1.Pmis-1:nn.iN.Pmis+1-1]/baseMVA
    bus[:,LAM_Q-1]=Lambda.eqnonlin[nn.i1.Qmis-1:nn.iN.Qmis+1-1]/baseMVA
    branch[:,MU_SF-1]=muSf/baseMVA
    branch[:,MU_ST-1]=muSt/baseMVA
    nlnN=getN(om,'nln')
    nlt=length(ilt)
    ngt=length(igt)
    nbx=length(ibx)
    kl=find(Lambda.eqnonlin<0)
    ku=find(Lambda.eqnonlin>0)
    nl_mu_l=zeros(nlnN,1)
    nl_mu_u=m_array([[zeros(2*nb,1)],[muSf],[muSt]]).reshape(1,-1)
    nl_mu_l[int(kl-1)]=-Lambda.eqnonlin[int(kl-1)]
    nl_mu_u[int(ku-1)]=Lambda.eqnonlin[int(ku-1)]
    kl=find(Lambda.eqlin<0)
    ku=find(Lambda.eqlin>0)
    mu_l=zeros(size(u))
    mu_l[int(ieq[int(kl-1)]-1)]=-Lambda.eqlin[int(kl-1)]
    mu_l[int(igt-1)]=Lambda.ineqlin[int(nlt+(arange(1,ngt+1).reshape(1,-1))-1)]
    mu_l[int(ibx-1)]=Lambda.ineqlin[int(nlt+ngt+nbx+(arange(1,nbx+1).reshape(1,-1))-1)]
    mu_u=zeros(size(u))
    mu_u[int(ieq[int(ku-1)]-1)]=Lambda.eqlin[int(ku-1)]
    mu_u[int(ilt-1)]=Lambda.ineqlin[1-1:nlt+1-1]
    mu_u[int(ibx-1)]=Lambda.ineqlin[int(nlt+ngt+(arange(1,nbx+1).reshape(1,-1))-1)]
    mu=struct('var',struct('l',Lambda.lower,'u',Lambda.upper),'nln',struct('l',nl_mu_l,'u',nl_mu_u),'lin',struct('l',mu_l,'u',mu_u))
    results=_copy(mpc)
    results.bus,results.branch,results.gen,results.om,results.x,results.mu,results.f=deal(bus,branch,gen,om,x,mu,f,nargout=7)
    pimul=m_array([[results.mu.nln.l-results.mu.nln.u],[results.mu.lin.l-results.mu.lin.u],[-ones(ny>0,1)],[results.mu.var.l-results.mu.var.u]]).reshape(1,-1)
    raw=struct('xr',x,'pimul',pimul,'info',info,'output',Output)
    return results,success,raw
def fmincopf_solver(om,mpopt,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    verbose=mpopt[int(31-1)]
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,nargout=4)
    vv,ll,nn=get_idx(om,nargout=3)
    nb=size(bus,1)
    nl=size(branch,1)
    ny=getN(om,'var','y')
    x0,LB,UB=getv(om,nargout=3)
    A,l,u=linear_constraints(om,nargout=3)
    ieq=find(abs(u-l)<=eps())
    igt=find(u>=10000000000.0&l>-10000000000.0)
    ilt=find(l<=-10000000000.0&u<10000000000.0)
    ibx=find((abs(u-l)>eps())&(u<10000000000.0)&(l>-10000000000.0))
    Af=m_array([[A[ilt-1,:]],[-A[igt-1,:]],[A[ibx-1,:]],[-A[ibx-1,:]]]).reshape(1,-1)
    bf=m_array([[u[int(ilt-1)]],[-l[int(igt-1)]],[u[int(ibx-1)]],[-l[int(ibx-1)]]]).reshape(1,-1)
    Afeq=A[ieq-1,:]
    bfeq=u[int(ieq-1)]
    Ybus,Yf,Yt=makeYbus(baseMVA,bus,branch,nargout=3)
    il=find(branch[:,RATE_A-1]!=0&branch[:,RATE_A-1]<10000000000.0)
    nl2=length(il)
    fmoptions=optimset('GradObj','on','GradConstr','on','TolCon',mpopt[int(16-1)],'TolX',mpopt[int(17-1)],'TolFun',mpopt[int(18-1)])
    if mpopt[int(19-1)]!=0:
        fmoptions=optimset(fmoptions,'MaxIter',mpopt[int(19-1)],'MaxFunEvals',4*mpopt[int(19-1)])
    if verbose==0:
        fmoptions.Display='off'
    else:
        if verbose==1:
            fmoptions.Display='iter'
        else:
            fmoptions.Display='testing'
    otver=ver('optim')
    if str2double(otver.Version[int(1-1)])<4:
        fmoptions=optimset(fmoptions,'LargeScale','off')
        Af=full(Af)
        Afeq=full(Afeq)
    else:
        if mpopt[int(55-1)]==1:
            fmoptions=optimset(fmoptions,'Algorithm','active-set')
            Af=full(Af)
            Afeq=full(Afeq)
        else:
            if mpopt[int(55-1)]==2:
                fmoptions=optimset(fmoptions,'Algorithm','interior-point')
            else:
                if mpopt[int(55-1)]==3:
                    fmoptions=optimset(fmoptions,'Algorithm','interior-point','Hessian','lbfgs')
                else:
                    if mpopt[int(55-1)]==4:
                        fmc_hessian=lambda x,lambda_: opf_hessfcn(x(),lambda_(),1,om,Ybus,Yf[il-1,:],Yt[il-1,:],mpopt,il)
                        fmoptions=optimset(fmoptions,'Algorithm','interior-point','Hessian','user-supplied','HessFcn',fmc_hessian)
                    else:
                        if mpopt[int(55-1)]==5:
                            fmoptions=optimset(fmoptions,'Algorithm','interior-point','Hessian','fin-diff-grads','SubProblem','cg')
                        else:
                            error('fmincopf_solver: unknown algorithm specified in FMC_ALG option')
    if str2double(otver.Version[int(1-1)])>=4 and strcmp(optimget(fmoptions,'Algorithm'),'interior-point'):
        x0=zeros(getN(om,'var'),1)
        x0[vv.i1.Va-1:vv.iN.Va+1-1]=0
        x0[vv.i1.Vm-1:vv.iN.Vm+1-1]=1
        x0[vv.i1.Pg-1:vv.iN.Pg+1-1]=(gen[:,PMIN-1]+gen[:,PMAX-1])/2/baseMVA
        x0[vv.i1.Qg-1:vv.iN.Qg+1-1]=(gen[:,QMIN-1]+gen[:,QMAX-1])/2/baseMVA
    f_fcn=lambda x: opf_costfcn(x,om)
    gh_fcn=lambda x: opf_consfcn(x,om,Ybus,Yf[il-1,:],Yt[il-1,:],mpopt,il)
    x,f,info,Output,Lambda=fmincon(f_fcn,x0,Af,bf,Afeq,bfeq,LB,UB,gh_fcn,fmoptions,nargout=5)
    success=(info>0)
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    V=Vm*exp(1j*Va)
    bus[:,VA-1]=Va*180/pi()
    bus[:,VM-1]=Vm
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    gen[:,VG-1]=Vm[int(gen[:,GEN_BUS-1]-1)]
    Sf=V[int(branch[:,F_BUS-1]-1)]*conj(Yf*V)
    St=V[int(branch[:,T_BUS-1]-1)]*conj(Yt*V)
    branch[:,PF-1]=real(Sf)*baseMVA
    branch[:,QF-1]=imag(Sf)*baseMVA
    branch[:,PT-1]=real(St)*baseMVA
    branch[:,QT-1]=imag(St)*baseMVA
    muSf=zeros(nl,1)
    muSt=zeros(nl,1)
    if  not isempty(il):
        muSf[int(il-1)]=2*Lambda.ineqnonlin[1-1:nl2+1-1]*branch[il-1,RATE_A-1]/baseMVA
        muSt[int(il-1)]=2*Lambda.ineqnonlin[int((arange(1,nl2+1).reshape(1,-1))+nl2-1)]*branch[il-1,RATE_A-1]/baseMVA
    bus[:,MU_VMAX-1]=Lambda.upper[vv.i1.Vm-1:vv.iN.Vm+1-1]
    bus[:,MU_VMIN-1]=Lambda.lower[vv.i1.Vm-1:vv.iN.Vm+1-1]
    gen[:,MU_PMAX-1]=Lambda.upper[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_PMIN-1]=Lambda.lower[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_QMAX-1]=Lambda.upper[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    gen[:,MU_QMIN-1]=Lambda.lower[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    bus[:,LAM_P-1]=Lambda.eqnonlin[nn.i1.Pmis-1:nn.iN.Pmis+1-1]/baseMVA
    bus[:,LAM_Q-1]=Lambda.eqnonlin[nn.i1.Qmis-1:nn.iN.Qmis+1-1]/baseMVA
    branch[:,MU_SF-1]=muSf/baseMVA
    branch[:,MU_ST-1]=muSt/baseMVA
    nlnN=getN(om,'nln')
    nlt=length(ilt)
    ngt=length(igt)
    nbx=length(ibx)
    kl=find(Lambda.eqnonlin<0)
    ku=find(Lambda.eqnonlin>0)
    nl_mu_l=zeros(nlnN,1)
    nl_mu_u=m_array([[zeros(2*nb,1)],[muSf],[muSt]]).reshape(1,-1)
    nl_mu_l[int(kl-1)]=-Lambda.eqnonlin[int(kl-1)]
    nl_mu_u[int(ku-1)]=Lambda.eqnonlin[int(ku-1)]
    kl=find(Lambda.eqlin<0)
    ku=find(Lambda.eqlin>0)
    mu_l=zeros(size(u))
    mu_l[int(ieq[int(kl-1)]-1)]=-Lambda.eqlin[int(kl-1)]
    mu_l[int(igt-1)]=Lambda.ineqlin[int(nlt+(arange(1,ngt+1).reshape(1,-1))-1)]
    mu_l[int(ibx-1)]=Lambda.ineqlin[int(nlt+ngt+nbx+(arange(1,nbx+1).reshape(1,-1))-1)]
    mu_u=zeros(size(u))
    mu_u[int(ieq[int(ku-1)]-1)]=Lambda.eqlin[int(ku-1)]
    mu_u[int(ilt-1)]=Lambda.ineqlin[1-1:nlt+1-1]
    mu_u[int(ibx-1)]=Lambda.ineqlin[int(nlt+ngt+(arange(1,nbx+1).reshape(1,-1))-1)]
    mu=struct('var',struct('l',Lambda.lower,'u',Lambda.upper),'nln',struct('l',nl_mu_l,'u',nl_mu_u),'lin',struct('l',mu_l,'u',mu_u))
    results=_copy(mpc)
    results.bus,results.branch,results.gen,results.om,results.x,results.mu,results.f=deal(bus,branch,gen,om,x,mu,f,nargout=7)
    pimul=m_array([[results.mu.nln.l-results.mu.nln.u],[results.mu.lin.l-results.mu.lin.u],[-ones(ny>0,1)],[results.mu.var.l-results.mu.var.u]]).reshape(1,-1)
    raw=struct('xr',x,'pimul',pimul,'info',info,'output',Output)
    return results,success,raw
def fun_copf(x,om,Ybus,Yf,Yt,Afeq,bfeq,Af,bf,mpopt,il,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    if nargin()<11:
        il=m_array()
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch,gencost=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,mpc.gencost,nargout=5)
    cp=get_cost_params(om)
    N,Cw,H,dd,rh,kk,mm=deal(cp.N,cp.Cw,cp.H,cp.dd,cp.rh,cp.kk,cp.mm,nargout=7)
    vv=get_idx(om)
    ny=getN(om,'var','y')
    nxyz=length(x)
    if isempty(il):
        nl=size(branch,1)
        il=(arange(1,nl+1).reshape(1,-1))
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    ipol=find(gencost[:,MODEL-1]==POLYNOMIAL)
    xx=m_array([[gen[:,PG-1]],[gen[:,QG-1]]]).reshape(1,-1)
    if  not isempty(ipol):
        f=sum(totcost(gencost[ipol-1,:],xx[int(ipol-1)]))
    else:
        f=0
    if ny>0:
        ccost=full(sparse(ones(1,ny),arange(vv.i1.y,vv.iN.y+1).reshape(1,-1),ones(1,ny),1,nxyz))
        f=f+ccost*x
    if  not isempty(N):
        nw=size(N,1)
        r=N*x-rh
        iLT=find(r<-kk)
        iEQ=find(r==0&kk==0)
        iGT=find(r>kk)
        iND=m_array([[iLT],[iEQ],[iGT]]).reshape(1,-1)
        iL=find(dd==1)
        iQ=find(dd==2)
        LL=sparse(iL,iL,1,nw,nw)
        QQ=sparse(iQ,iQ,1,nw,nw)
        kbar=sparse(iND,iND,m_array([[ones(length(iLT),1)],[zeros(length(iEQ),1)],[-ones(length(iGT),1)]]).reshape(1,-1),nw,nw)*kk
        rr=r+kbar
        M=sparse(iND,iND,mm[int(iND-1)],nw,nw)
        diagrr=sparse(arange(1,nw+1).reshape(1,-1),arange(1,nw+1).reshape(1,-1),rr,nw,nw)
        w=M*(LL+QQ*diagrr)*rr
        f=f+(w.T*H*w)/2+Cw.T*w
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    V=Vm*exp(1j*Va)
    Sbus=makeSbus(baseMVA,bus,gen)
    mis=V*conj(Ybus*V)-Sbus
    geq=m_array([[real(mis)],[imag(mis)]]).reshape(1,-1)
    flow_max=(branch[il-1,RATE_A-1]/baseMVA)**2
    flow_max[int(flow_max==0)]=Inf()
    if mpopt[int(24-1)]==2:
        If=Yf*V
        It=Yt*V
        gineq=m_array([[If*conj(If)-flow_max],[It*conj(It)-flow_max]]).reshape(1,-1)
    else:
        Sf=V[int(branch[il-1,F_BUS-1]-1)]*conj(Yf*V)
        St=V[int(branch[il-1,T_BUS-1]-1)]*conj(Yt*V)
        if mpopt[int(24-1)]==1:
            gineq=m_array([[real(Sf)**2-flow_max],[real(St)**2-flow_max]]).reshape(1,-1)
        else:
            gineq=m_array([[Sf*conj(Sf)-flow_max],[St*conj(St)-flow_max]]).reshape(1,-1)
    g=m_array([[geq],[Afeq*x-bfeq],[gineq],[Af*x-bf]]).reshape(1,-1)
    return f,g
def gausspf(Ybus,Sbus,V0,ref,pv,pq,mpopt,**kwargs):
    Sbus=_copy(Sbus)
    if nargin()<7:
        mpopt=mpoption()
    tol=mpopt[int(2-1)]
    max_it=mpopt[int(5-1)]
    verbose=mpopt[int(31-1)]
    converged=0
    i=0
    V=_copy(V0)
    Vm=abs(V)
    npv=length(pv)
    npq=length(pq)
    mis=V*conj(Ybus*V)-Sbus
    F=m_array([[real(mis[int(m_array([[pv],[pq]]).reshape(1,-1)-1)])],[imag(mis[int(pq-1)])]]).reshape(1,-1)
    normF=norm(F,inf())
    if verbose>1:
        fprintf('\\n it    max P & Q mismatch (p.u.)')
        fprintf('\\n----  ---------------------------')
        fprintf('\\n%3d        %10.3e',i,normF)
    if normF<tol:
        converged=1
        if verbose>1:
            fprintf('\\nConverged!\\n')
    while ( not converged and i<max_it):
        i=i+1
        for k in pq[1-1:npq+1-1].T.flat:
            V[int(k-1)]=V[int(k-1)]+(conj(Sbus[int(k-1)]/V[int(k-1)])-Ybus[k-1,:]*V)/Ybus[k-1,k-1]
        if npv:
            for k in pv[1-1:npv+1-1].T.flat:
                Sbus[int(k-1)]=real(Sbus[int(k-1)])+1j*imag(V[int(k-1)]*conj(Ybus[k-1,:]*V))
                V[int(k-1)]=V[int(k-1)]+(conj(Sbus[int(k-1)]/V[int(k-1)])-Ybus[k-1,:]*V)/Ybus[k-1,k-1]
            V[int(pv-1)]=Vm[int(pv-1)]*V[int(pv-1)]/abs(V[int(pv-1)])
        mis=V*conj(Ybus*V)-Sbus
        F=m_array([[real(mis[int(pv-1)])],[real(mis[int(pq-1)])],[imag(mis[int(pq-1)])]]).reshape(1,-1)
        normF=norm(F,inf())
        if verbose>1:
            fprintf('\\n%3d        %10.3e',i,normF)
        if normF<tol:
            converged=1
            if verbose:
                fprintf('\\nGauss-Seidel power flow converged in %d iterations.\\n',i)
    if verbose:
        if  not converged:
            fprintf('\\nGauss-Seidel power did not converge in %d iterations.\\n',i)
    return V,converged,i
def grad_copf(x,om,Ybus,Yf,Yt,Afeq,bfeq,Af,bf,mpopt,il,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    if nargin()<11:
        il=m_array()
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch,gencost=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,mpc.gencost,nargout=5)
    cp=get_cost_params(om)
    N,Cw,H,dd,rh,kk,mm=deal(cp.N,cp.Cw,cp.H,cp.dd,cp.rh,cp.kk,cp.mm,nargout=7)
    vv=get_idx(om)
    nb=size(bus,1)
    nl=size(branch,1)
    ng=size(gen,1)
    ny=getN(om,'var','y')
    nxyz=length(x)
    if isempty(il):
        il=(arange(1,nl+1).reshape(1,-1))
    nl2=length(il)
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    ipol=find(gencost[:,MODEL-1]==POLYNOMIAL)
    xx=m_array([[gen[:,PG-1]],[gen[:,QG-1]]]).reshape(1,-1)
    if  not isempty(ipol):
        f=sum(totcost(gencost[ipol-1,:],xx[int(ipol-1)]))
    else:
        f=0
    if ny>0:
        ccost=full(sparse(ones(1,ny),arange(vv.i1.y,vv.iN.y+1).reshape(1,-1),ones(1,ny),1,nxyz))
        f=f+ccost*x
    else:
        ccost=zeros(1,nxyz)
    if  not isempty(N):
        nw=size(N,1)
        r=N*x-rh
        iLT=find(r<-kk)
        iEQ=find(r==0&kk==0)
        iGT=find(r>kk)
        iND=m_array([[iLT],[iEQ],[iGT]]).reshape(1,-1)
        iL=find(dd==1)
        iQ=find(dd==2)
        LL=sparse(iL,iL,1,nw,nw)
        QQ=sparse(iQ,iQ,1,nw,nw)
        kbar=sparse(iND,iND,m_array([[ones(length(iLT),1)],[zeros(length(iEQ),1)],[-ones(length(iGT),1)]]).reshape(1,-1),nw,nw)*kk
        rr=r+kbar
        M=sparse(iND,iND,mm[int(iND-1)],nw,nw)
        diagrr=sparse(arange(1,nw+1).reshape(1,-1),arange(1,nw+1).reshape(1,-1),rr,nw,nw)
        w=M*(LL+QQ*diagrr)*rr
        f=f+(w.T*H*w)/2+Cw.T*w
    iPg=arange(vv.i1.Pg,vv.iN.Pg+1).reshape(1,-1)
    iQg=arange(vv.i1.Qg,vv.iN.Qg+1).reshape(1,-1)
    df_dPgQg=zeros(2*ng,1)
    df_dPgQg[int(ipol-1)]=baseMVA*polycost(gencost[ipol-1,:],xx[int(ipol-1)],1)
    df=zeros(nxyz,1)
    df[int(iPg-1)]=df_dPgQg[1-1:ng+1-1]
    df[int(iQg-1)]=df_dPgQg[int((arange(1,ng+1).reshape(1,-1))+ng-1)]
    df=df+ccost.T
    if  not isempty(N):
        HwC=H*w+Cw
        AA=N.T*M*(LL+2*QQ*diagrr)
        df=df+AA*HwC
        if 0:
            ddff=zeros(size(df))
            step=1e-07
            tol=0.001
            for k in arange(1,length(x)+1).reshape(1,-1).flat:
                xx=_copy(x)
                xx[int(k-1)]=xx[int(k-1)]+step
                ddff[int(k-1)]=(fun_copf(xx,om,Ybus,Yf,Yt,Afeq,bfeq,Af,bf,mpopt,il)-f)/step
            if max(abs(ddff-df))>tol:
                idx=find(abs(ddff-df)==max(abs(ddff-df)))
                fprintf('\\nMismatch in gradient\\n')
                fprintf('idx             df(num)         df              diff\\n')
                fprintf('%4d%16g%16g%16g\\n',m_array([[arange(1,length(df)+1).reshape(1,-1)],[ddff.T],[df.T],[abs(ddff-df).T]]).reshape(1,-1))
                fprintf('MAX\\n')
                fprintf('%4d%16g%16g%16g\\n',m_array([[idx.T],[ddff[int(idx-1)].T],[df[int(idx-1)].T],[abs(ddff[int(idx-1)]-df[int(idx-1)]).T]]).reshape(1,-1))
                fprintf('\\n')
    if nargout()>2:
        pcost=gencost[1-1:ng+1-1,:]
        if size(gencost,1)>ng:
            qcost=gencost[ng+1-1:2*ng+1-1,:]
        else:
            qcost=m_array()
        d2f_dPg2=sparse(ng,1)
        d2f_dQg2=sparse(ng,1)
        ipolp=find(pcost[:,MODEL-1]==POLYNOMIAL)
        d2f_dPg2[int(ipolp-1)]=baseMVA**2*polycost(pcost[ipolp-1,:],Pg[int(ipolp-1)]*baseMVA,2)
        if  not isempty(qcost):
            ipolq=find(qcost[:,MODEL-1]==POLYNOMIAL)
            d2f_dQg2[int(ipolq-1)]=baseMVA**2*polycost(qcost[ipolq-1,:],Qg[int(ipolq-1)]*baseMVA,2)
        i=(arange(pgbas(),qgend()+1).reshape(1,-1)).T
        d2f=sparse(i,i,m_array([[d2f_dPg2],[d2f_dQg2]]).reshape(1,-1),nxyz,nxyz)
        if  not isempty(N):
            d2f=d2f+AA*H*AA.T+2*N.T*M*QQ*sparse(arange(1,nw+1).reshape(1,-1),arange(1,nw+1).reshape(1,-1),HwC,nw,nw)*N
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    V=Vm*exp(1j*Va)
    dSbus_dVm,dSbus_dVa=dSbus_dV(Ybus,V,nargout=2)
    neg_Cg=sparse(gen[:,GEN_BUS-1],arange(1,ng+1).reshape(1,-1),-1,nb,ng)
    if mpopt[int(24-1)]==2:
        dFf_dVa,dFf_dVm,dFt_dVa,dFt_dVm,Ff,Ft=dIbr_dV(branch[il-1,:],Yf,Yt,V,nargout=6)
    else:
        dFf_dVa,dFf_dVm,dFt_dVa,dFt_dVm,Ff,Ft=dSbr_dV(branch[il-1,:],Yf,Yt,V,nargout=6)
    if mpopt[int(24-1)]==1:
        dFf_dVa=real(dFf_dVa)
        dFf_dVm=real(dFf_dVm)
        dFt_dVa=real(dFt_dVa)
        dFt_dVm=real(dFt_dVm)
        Ff=real(Ff)
        Ft=real(Ft)
    df_dVa,df_dVm,dt_dVa,dt_dVm=dAbr_dV(dFf_dVa,dFf_dVm,dFt_dVa,dFt_dVm,Ff,Ft,nargout=4)
    iVa=arange(vv.i1.Va,vv.iN.Va+1).reshape(1,-1)
    iVm=arange(vv.i1.Vm,vv.iN.Vm+1).reshape(1,-1)
    iPg=arange(vv.i1.Pg,vv.iN.Pg+1).reshape(1,-1)
    iQg=arange(vv.i1.Qg,vv.iN.Qg+1).reshape(1,-1)
    nleq=size(Afeq,1)
    nliq=size(Af,1)
    dg=sparse(nxyz,2*nb+2*nl2+nleq+nliq)
    dg[m_array([iVa,iVm]).reshape(1,-1)-1,1-1:2*nb+1-1]=m_array([[real(dSbus_dVa),real(dSbus_dVm)],[imag(dSbus_dVa),imag(dSbus_dVm)]]).reshape(1,-1).T
    dg[iPg-1,1-1:nb+1-1]=neg_Cg.T
    dg[iQg-1,(arange(1,nb+1).reshape(1,-1))+nb-1]=neg_Cg.T
    dg[:,(arange(1,nleq+1).reshape(1,-1))+2*nb-1]=Afeq.T
    dg[m_array([iVa,iVm]).reshape(1,-1)-1,(arange(1,2*nl2+1).reshape(1,-1))+2*nb+nleq-1]=m_array([[df_dVa,df_dVm],[dt_dVa,dt_dVm]]).reshape(1,-1).T
    dg[:,(arange(1,nliq+1).reshape(1,-1))+2*nb+2*nl2+nleq-1]=Af.T
    dg=full(dg)
    return df,dg,d2f
def hasPQcap(gen,hilo,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    if nargin()<2:
        hilo='B'
    if any(gen[:,PC1-1]>gen[:,PC2-1]):
        error('hasPQcap: Pc1 > Pc2')
    if any(gen[:,QC2MAX-1]>gen[:,QC1MAX-1]):
        error('hasPQcap: Qc2max > Qc1max')
    if any(gen[:,QC2MIN-1]<gen[:,QC1MIN-1]):
        error('hasPQcap: Qc2min < Qc1min')
    L=zeros(size(gen,1),1)
    U=zeros(size(gen,1),1)
    k=find(gen[:,PC1-1]!=gen[:,PC2-1])
    if  not strcmp(hilo,'U'):
        Qmin_at_Pmax=gen[k-1,QC1MIN-1]+(gen[k-1,PMAX-1]-gen[k-1,PC1-1])*(gen[k-1,QC2MIN-1]-gen[k-1,QC1MIN-1])/(gen[k-1,PC2-1]-gen[k-1,PC1-1])
        L[int(k-1)]=Qmin_at_Pmax>gen[k-1,QMIN-1]
    if  not strcmp(hilo,'L'):
        Qmax_at_Pmax=gen[k-1,QC1MAX-1]+(gen[k-1,PMAX-1]-gen[k-1,PC1-1])*(gen[k-1,QC2MAX-1]-gen[k-1,QC1MAX-1])/(gen[k-1,PC2-1]-gen[k-1,PC1-1])
        U[int(k-1)]=Qmax_at_Pmax<gen[k-1,QMAX-1]
    TorF=L|U
    return TorF
def idx_area(**kwargs):
    AREA_I=1
    PRICE_REF_BUS=2
    return AREA_I,PRICE_REF_BUS
def idx_brch(**kwargs):
    F_BUS=1
    T_BUS=2
    BR_R=3
    BR_X=4
    BR_B=5
    RATE_A=6
    RATE_B=7
    RATE_C=8
    TAP=9
    SHIFT=10
    BR_STATUS=11
    ANGMIN=12
    ANGMAX=13
    PF=14
    QF=15
    PT=16
    QT=17
    MU_SF=18
    MU_ST=19
    MU_ANGMIN=20
    MU_ANGMAX=21
    return F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX
def idx_bus(**kwargs):
    PQ=1
    PV=2
    REF=3
    NONE=4
    BUS_I=1
    BUS_TYPE=2
    PD=3
    QD=4
    GS=5
    BS=6
    BUS_AREA=7
    VM=8
    VA=9
    BASE_KV=10
    ZONE=11
    VMAX=12
    VMIN=13
    LAM_P=14
    LAM_Q=15
    MU_VMAX=16
    MU_VMIN=17
    return PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN
def idx_cost(**kwargs):
    PW_LINEAR=1
    POLYNOMIAL=2
    MODEL=1
    STARTUP=2
    SHUTDOWN=3
    NCOST=4
    COST=5
    return PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST
def idx_dcline(**kwargs):
    c=struct('F_BUS',1,'T_BUS',2,'BR_STATUS',3,'PF',4,'PT',5,'QF',6,'QT',7,'VF',8,'VT',9,'PMIN',10,'PMAX',11,'QMINF',12,'QMAXF',13,'QMINT',14,'QMAXT',15,'LOSS0',16,'LOSS1',17,'MU_PMIN',18,'MU_PMAX',19,'MU_QMINF',20,'MU_QMAXF',21,'MU_QMINT',22,'MU_QMAXT',23)
    return c
def idx_gen(**kwargs):
    GEN_BUS=1
    PG=2
    QG=3
    QMAX=4
    QMIN=5
    VG=6
    MBASE=7
    GEN_STATUS=8
    PMAX=9
    PMIN=10
    PC1=11
    PC2=12
    QC1MIN=13
    QC1MAX=14
    QC2MIN=15
    QC2MAX=16
    RAMP_AGC=17
    RAMP_10=18
    RAMP_30=19
    RAMP_Q=20
    APF=21
    MU_PMAX=22
    MU_PMIN=23
    MU_QMAX=24
    MU_QMIN=25
    return GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF
def int2ext(i2e,bus,gen,branch,areas,**kwargs):
    bus=_copy(bus)
    gen=_copy(gen)
    branch=_copy(branch)
    areas=_copy(areas)
    if isstruct(i2e):
        mpc=_copy(i2e)
        if nargin()==1:
            if  not isfield(mpc,'order'):
                error("int2ext: mpc does not have the 'order' field required for conversion back to external numbering.")
            o=mpc.order
            if o.state=='i':
                PQ,PV,REF,NONE,BUS_I=idx_bus(nargout=5)
                GEN_BUS=idx_gen()
                F_BUS,T_BUS=idx_brch(nargout=2)
                AREA_I,PRICE_REF_BUS=idx_area(nargout=2)
                if isfield(mpc,'userfcn'):
                    mpc=run_userfcn(mpc.userfcn,'int2ext',mpc)
                o.int.bus=mpc.bus
                o.int.branch=mpc.branch
                o.int.gen=mpc.gen
                mpc.bus=o.ext.bus
                mpc.branch=o.ext.branch
                mpc.gen=o.ext.gen
                if isfield(mpc,'gencost'):
                    o.int.gencost=mpc.gencost
                    mpc.gencost=o.ext.gencost
                if isfield(mpc,'areas'):
                    o.int.areas=mpc.areas
                    mpc.areas=o.ext.areas
                if isfield(mpc,'A'):
                    o.int.A=mpc.A
                    mpc.A=o.ext.A
                if isfield(mpc,'N'):
                    o.int.N=mpc.N
                    mpc.N=o.ext.N
                mpc.bus[o.bus.status.on-1,:]=o.int.bus
                mpc.branch[o.branch.status.on-1,:]=o.int.branch
                mpc.gen[o.gen.status.on-1,:]=o.int.gen[o.gen.i2e-1,:]
                if isfield(mpc,'areas'):
                    mpc.areas[o.areas.status.on-1,:]=o.int.areas
                mpc.bus[o.bus.status.on-1,BUS_I-1]=o.bus.i2e[int(mpc.bus[o.bus.status.on-1,BUS_I-1]-1)]
                mpc.branch[o.branch.status.on-1,F_BUS-1]=o.bus.i2e[int(mpc.branch[o.branch.status.on-1,F_BUS-1]-1)]
                mpc.branch[o.branch.status.on-1,T_BUS-1]=o.bus.i2e[int(mpc.branch[o.branch.status.on-1,T_BUS-1]-1)]
                mpc.gen[o.gen.status.on-1,GEN_BUS-1]=o.bus.i2e[int(mpc.gen[o.gen.status.on-1,GEN_BUS-1]-1)]
                if isfield(mpc,'areas'):
                    mpc.areas[o.areas.status.on-1,PRICE_REF_BUS-1]=o.bus.i2e[int(mpc.areas[o.areas.status.on-1,PRICE_REF_BUS-1]-1)]
                if isfield(o,'ext'):
                    o=rmfield(o,'ext')
                o.state='e'
                mpc.order=o
            else:
                error('int2ext: mpc claims it is already using external numbering.')
            bus=mpc
        else:
            if ischar(bus) or iscell(bus):
                warning("Calls of the form MPC = INT2EXT(MPC, 'FIELD_NAME', ...) have been deprecated. Please replace INT2EXT with I2E_FIELD.")
                if nargin()>3:
                    dim=branch
                else:
                    dim=1
                bus=i2e_field(mpc,bus,gen,dim)
            else:
                warning('Calls of the form VAL = INT2EXT(MPC, VAL, ...) have been deprecated. Please replace INT2EXT with I2E_DATA.')
                if nargin()>4:
                    dim=areas
                else:
                    dim=1
                bus=i2e_data(mpc,bus,gen,branch,dim)
    else:
        PQ,PV,REF,NONE,BUS_I=idx_bus(nargout=5)
        GEN_BUS=idx_gen(nargout=1)
        F_BUS,T_BUS=idx_brch(nargout=2)
        AREA_I,PRICE_REF_BUS=idx_area(nargout=2)
        bus[:,BUS_I-1]=i2e[int(bus[:,BUS_I-1]-1)]
        gen[:,GEN_BUS-1]=i2e[int(gen[:,GEN_BUS-1]-1)]
        branch[:,F_BUS-1]=i2e[int(branch[:,F_BUS-1]-1)]
        branch[:,T_BUS-1]=i2e[int(branch[:,T_BUS-1]-1)]
        if nargin()>4 and nargout()>3 and  not isempty(areas):
            areas[:,PRICE_REF_BUS-1]=i2e[int(areas[:,PRICE_REF_BUS-1]-1)]
    return bus,gen,branch,areas
def objective(x,d,**kwargs):
    f=opf_costfcn(x,d.om)
    return f
def gradient(x,d,**kwargs):
    f,df=opf_costfcn(x,d.om,nargout=2)
    return df
def constraints(x,d,**kwargs):
    hn,gn=opf_consfcn(x,d.om,d.Ybus,d.Yf,d.Yt,d.mpopt,d.il,nargout=2)
    if isempty(d.A):
        c=m_array([[gn],[hn]]).reshape(1,-1)
    else:
        c=m_array([[gn],[hn],[d.A*x]]).reshape(1,-1)
    return c
def jacobian(x,d,**kwargs):
    hn,gn,dhn,dgn=opf_consfcn(x,d.om,d.Ybus,d.Yf,d.Yt,d.mpopt,d.il,nargout=4)
    J=m_array([[dgn.T],[dhn.T],[d.A]]).reshape(1,-1)
    return J
def isload(gen,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    TorF=gen[:,PMIN-1]<0&gen[:,PMAX-1]==0
    return TorF
def write_ktropts(ktropts,**kwargs):
    fname=sprintf('ktropts_%06d.txt',fix(1000000.0*rand()))
    fd,msg=fopen(fname,'wt',nargout=2)
    if fd==-1:
        error('could not create %d : %s',fname,msg)
    fields=fieldnames(ktropts)
    for k in arange(1,length(fields)+1).reshape(1,-1).flat:
        fprintf(fd,'%s %g\\n',fields[k-1],getfield(ktropts,fields[k-1]))
    if fd!=1:
        fclose(fd)
    return fname
def load2disp(mpc0,fname,idx,voll,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    mpc=loadcase(mpc0)
    if nargin()<3 or isempty(idx):
        idx=find(mpc.bus[:,PD-1]>0)
    voll0=5000
    mBase=100
    nld=length(idx)
    v1=ones(nld,1)
    v0=zeros(nld,1)
    gen=m_array([mpc.bus[idx-1,BUS_I-1],-mpc.bus[idx-1,PD-1],-mpc.bus[idx-1,QD-1],max(0,-mpc.bus[idx-1,QD-1]),min(0,-mpc.bus[idx-1,QD-1]),mpc.bus[idx-1,VM-1],mBase*v1,v1,max(0,-mpc.bus[idx-1,PD-1]),min(0,-mpc.bus[idx-1,PD-1]),zeros(nld,6),Inf()*ones(nld,4),zeros(nld,1)]).reshape(1,-1)
    mpc.gen=m_array([[mpc.gen],[gen]]).reshape(1,-1)
    mpc.bus[idx-1,m_array([PD,QD]).reshape(1,-1)-1]=0
    nc=size(mpc.gencost,2)
    if nargin()<4:
        voll=voll0*v1
    else:
        if length(voll)==1:
            voll=voll*v1
    gencost=m_array([POLYNOMIAL*v1,zeros(nld,2),2*v1,voll,zeros(nld,nc-5)]).reshape(1,-1)
    mpc.gencost=m_array([[mpc.gencost],[gencost]]).reshape(1,-1)
    if nargin()>1 and  not isempty(fname):
        savecase(fname,mpc,'2')
    if nargout()>0:
        mpc1=mpc
    return mpc1
def loadcase(casefile,**kwargs):
    info=0
    if nargout()<3:
        return_as_struct=true()
    else:
        return_as_struct=false()
    if nargout()>=5:
        expect_gencost=true()
        if nargout()>5:
            expect_areas=true()
        else:
            expect_areas=false()
    else:
        expect_gencost=false()
        expect_areas=false()
    if ischar(casefile):
        l=length(casefile)
        if l>2:
            if strcmp(casefile[l-1-1:l+1-1],'.m'):
                rootname=casefile[1-1:l-2+1-1]
                extension='.m'
            else:
                if l>4:
                    if strcmp(casefile[l-3-1:l+1-1],'.mat'):
                        rootname=casefile[1-1:l-4+1-1]
                        extension='.mat'
        if  not exist('rootname','var'):
            rootname=casefile
            if exist(m_array([casefile,'.mat']).reshape(1,-1),'file')==2:
                extension='.mat'
            else:
                if exist(m_array([casefile,'.m']).reshape(1,-1),'file')==2:
                    extension='.m'
                else:
                    info=2
        if info==0:
            if strcmp(extension,'.mat'):
                try: 
                    s=load(rootname)
                    if isfield(s,'mpc'):
                        s=s.mpc
                    else:
                        s.version='1'
                except: 
                    info=3
            else:
                if strcmp(extension,'.m'):
                    try: 
                        s=feval(rootname)
                    except: 
                        info=4
                    if info==0 and  not isstruct(s):
                        clear('s')
                        s.version='1'
                        if expect_gencost:
                            try: 
                                s.baseMVA,s.bus,s.gen,s.branch,s.areas,s.gencost=feval(rootname,nargout=6)
                            except: 
                                info=4
                        else:
                            if return_as_struct:
                                try: 
                                    s.baseMVA,s.bus,s.gen,s.branch,s.areas,s.gencost=feval(rootname,nargout=6)
                                except: 
                                    try: 
                                        s.baseMVA,s.bus,s.gen,s.branch=feval(rootname,nargout=4)
                                    except: 
                                        info=4
                            else:
                                try: 
                                    s.baseMVA,s.bus,s.gen,s.branch=feval(rootname,nargout=4)
                                except: 
                                    info=4
                    if info==4 and exist(m_array([rootname,'.m']).reshape(1,-1),'file')==2:
                        info=5
                        err5=lasterr()
    else:
        if isstruct(casefile):
            s=casefile
        else:
            info=1
    if info==0:
        if  not (isfield(s,'baseMVA') and isfield(s,'bus') and isfield(s,'gen') and isfield(s,'branch')) or (expect_gencost and  not isfield(s,'gencost')) or (expect_areas and  not isfield(s,'areas')):
            info=5
            err5='missing data'
        else:
            if isfield(s,'areas') and isempty(s.areas) and  not expect_areas:
                s=rmfield(s,'areas')
            mpc=_copy(s)
            if  not isfield(mpc,'version'):
                if size(mpc.gen,2)<21:
                    mpc.version='1'
                else:
                    mpc.version='2'
            if strcmp(mpc.version,'1'):
                mpc.gen,mpc.branch=mpc_1to2(mpc.gen,mpc.branch,nargout=2)
                mpc.version='2'
    if return_as_struct:
        bus=info
    if info==0:
        if return_as_struct:
            baseMVA=mpc
        else:
            baseMVA=mpc.baseMVA
            bus=mpc.bus
            gen=mpc.gen
            branch=mpc.branch
            if expect_gencost:
                if expect_areas:
                    areas=mpc.areas
                    gencost=mpc.gencost
                else:
                    areas=mpc.gencost
    else:
        if nargout()==2 or nargout()==7:
            if return_as_struct:
                baseMVA=struct(m_array())
            else:
                baseMVA=m_array()
                bus=m_array()
                gen=m_array()
                branch=m_array()
                areas=m_array()
                gencost=m_array()
        else:
            if 1==info:
                error('loadcase: input arg should be a struct or a string containing a filename')
            else:
                if 2==info:
                    error("loadcase: specified case not in MATLAB's search path")
                else:
                    if 3==info:
                        error('loadcase: specified MAT file does not exist')
                    else:
                        if 4==info:
                            error('loadcase: specified M file does not exist')
                        else:
                            if 5==info:
                                error('loadcase: syntax error or undefined data matrix(ices) in the file\\n%s',err5)
                            else:
                                error('loadcase: unknown error')
    return baseMVA,bus,gen,branch,areas,gencost,info
def mpc_1to2(gen,branch,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    if size(gen,2)>APF:
        error('mpc_1to2: gen matrix appears to already be in version 2 format')
    shift=MU_PMAX-PMIN-1
    tmp=num2cell(m_array([MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN]).reshape(1,-1)-shift)
    MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN=deal(tmp[:],nargout=4)
    tmp=zeros(size(gen,1),shift)
    if size(gen,2)>=MU_QMIN:
        gen=m_array([gen[:,1-1:PMIN+1-1],tmp,gen[:,MU_PMAX-1:MU_QMIN+1-1]]).reshape(1,-1)
    else:
        gen=m_array([gen[:,1-1:PMIN+1-1],tmp]).reshape(1,-1)
    shift=PF-BR_STATUS-1
    tmp=num2cell(m_array([PF,QF,PT,QT,MU_SF,MU_ST]).reshape(1,-1)-shift)
    PF,QF,PT,QT,MU_SF,MU_ST=deal(tmp[:],nargout=6)
    tmp=ones(size(branch,1),1)*m_array([-360,360]).reshape(1,-1)
    tmp2=zeros(size(branch,1),2)
    if size(branch,2)>=MU_ST:
        branch=m_array([branch[:,1-1:BR_STATUS+1-1],tmp,branch[:,PF-1:MU_ST+1-1],tmp2]).reshape(1,-1)
    else:
        if size(branch,2)>=QT:
            branch=m_array([branch[:,1-1:BR_STATUS+1-1],tmp,branch[:,PF-1:QT+1-1]]).reshape(1,-1)
        else:
            branch=m_array([branch[:,1-1:BR_STATUS+1-1],tmp]).reshape(1,-1)
    return gen,branch
def LPconstr(FUN,x,mpopt,step0,VLB,VUB,GRADFUN,LPEQUSVR,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,**kwargs):
    if nargin()<8:
        error('\\ LPconstr needs more arguments ! \\   ')
    nvars=length(x)
    nequ=mpopt[int(15-1)]
    if  not any(FUN<48):
        etype=1
        evalstr=m_array([FUN]).reshape(1,-1)
        evalstr=m_array([evalstr,'(x']).reshape(1,-1)
        for i in arange(1,nargin()-8+1).reshape(1,-1).flat:
            etype=2
            evalstr=m_array([evalstr,',P',int2str(i)]).reshape(1,-1)
        evalstr=m_array([evalstr,')']).reshape(1,-1)
    else:
        etype=3
        evalstr=m_array([FUN,'; g=g(:);']).reshape(1,-1)
    if  not any(GRADFUN<48):
        gtype=1
        evalstr2=m_array([GRADFUN,'(x']).reshape(1,-1)
        for i in arange(1,nargin()-8+1).reshape(1,-1).flat:
            gtype=2
            evalstr2=m_array([evalstr2,',P',int2str(i)]).reshape(1,-1)
        evalstr2=m_array([evalstr2,')']).reshape(1,-1)
    else:
        gtype=3
        evalstr2=m_array([GRADFUN,';']).reshape(1,-1)
    if  not any(LPEQUSVR<48):
        lpeqtype=1
        evalstr3=m_array([LPEQUSVR,'(x']).reshape(1,-1)
        for i in arange(1,nargin()-8+1).reshape(1,-1).flat:
            lpeqtype=2
            evalstr3=m_array([evalstr3,',P',int2str(i)]).reshape(1,-1)
        evalstr3=m_array([evalstr3,')']).reshape(1,-1)
    else:
        lpeqtype=3
        evalstr3=m_array([LPEQUSVR,';']).reshape(1,-1)
    verbose=mpopt[int(31-1)]
    itcounter=0
    runcounter=1
    stepsize=step0*0.02
    f_best=9.9e+15
    f_best_run=9.9e+15
    max_slackvar_last=9.9e+15
    converged=0
    if verbose:
        fprintf(' it   obj function   max violation  max slack var    norm grad       norm dx\\n')
        fprintf('----  -------------  -------------  -------------  -------------  -------------\\n')
    while (converged==0) and (itcounter<mpopt[int(22-1)]) and (runcounter<mpopt[int(23-1)]):
        itcounter=itcounter+1
        if verbose:
            fprintf('%3d ',itcounter)
        if lpeqtype==1:
            x,success_lf=feval(LPEQUSVR,x,nargout=2)
        else:
            if lpeqtype==2:
                x,success_lf=eval(evalstr3,nargout=2)
            else:
                eval(evalstr3)
        if success_lf==0:
            fprintf('\\n      Load flow did not converge. LPconstr restarted with reduced stepsize! ')
            x=xbackup
            stepsize=0.7*stepsize
        if etype==1:
            f,g=feval(FUN,x,nargout=2)
        else:
            if etype==2:
                f,g=eval(evalstr,nargout=2)
            else:
                eval(evalstr)
        if gtype==1:
            df_dx,dg_dx=feval(GRADFUN,x,nargout=2)
        else:
            if gtype==2:
                df_dx,dg_dx=eval(evalstr2,nargout=2)
            else:
                eval(evalstr2)
        dg_dx=dg_dx.T
        max_g=max(g)
        if verbose:
            fprintf('   %-12.6g   %-12.6g',f,max_g)
        a_lp=dg_dx
        f_lp=df_dx
        rhs_lp=-g
        vubdx=stepsize
        vlbdx=-stepsize
        if isempty(VUB)!=1 or isempty(VLB)!=1:
            error('sorry, at this stage LPconstr can not solve a problem with VLB or VUB ')
        temp=find((g/(abs(g)+ones(length(g),1)))>0.1*mpopt[int(16-1)])
        if isempty(temp)!=1:
            n_slack=length(temp)
            if issparse(a_lp):
                a_lp=m_array([a_lp,sparse(temp,arange(1,n_slack+1).reshape(1,-1),-1,size(a_lp,1),n_slack)]).reshape(1,-1)
            else:
                a_lp=m_array([a_lp,full(sparse(temp,arange(1,n_slack+1).reshape(1,-1),-1,size(a_lp,1),n_slack))]).reshape(1,-1)
            vubdx=m_array([[vubdx],[g[int(temp-1)]+10000.0*ones(n_slack,1)]]).reshape(1,-1)
            vlbdx=m_array([[vlbdx],[zeros(n_slack,1)]]).reshape(1,-1)
            f_lp=m_array([[f_lp],[9900000.0*max(df_dx)*ones(n_slack,1)]]).reshape(1,-1)
        if itcounter==1:
            idx_workc=m_array()
            flag_workc=zeros(3*length(rhs_lp)+2*nvars,1)
        else:
            flag_workc=flag_workc-1
            flag_workc[int(idx_bindc-1)]=20*ones(size(idx_bindc))
            if itcounter>20:
                idx_workc=find(flag_workc>0)
        dx,lambda_,idx_workc,idx_bindc=LPsetup(a_lp,f_lp,rhs_lp,nequ,vlbdx,vubdx,idx_workc,mpopt,nargout=4)
        if length(dx)==nvars:
            max_slackvar=0
        else:
            max_slackvar=max(dx[nvars+1-1:length(dx)+1-1])
            if max_slackvar<1e-08:
                max_slackvar=0
        if verbose:
            fprintf('   %-12.6g',max_slackvar)
        dx=dx[1-1:nvars+1-1]
        x=x+dx
        xbackup=x
        dL_dx=df_dx+dg_dx.T*lambda_
        norm_dL=norm(dL_dx,inf())
        if abs(f)<1e-10:
            norm_grad=norm_dL
        else:
            norm_grad=norm_dL/abs(f)
        norm_dx=norm(dx/step0,inf())
        if verbose:
            fprintf('   %-12.6g   %-12.6g\\n',norm_grad,norm_dx)
        if (norm_grad<mpopt[int(20-1)]) and (max_g<mpopt[int(16-1)]) and (norm_dx<mpopt[int(21-1)]):
            converged=1
            break
        if norm_dx<0.05*mpopt[int(21-1)]:
            if max_g<mpopt[int(16-1)] and abs(f_best-f_best_run)/f_best_run<0.0001:
                converged=1
                break
            else:
                f_best_run=f_best
                stepsize=0.4*step0
                if verbose:
                    fprintf('\\n----- restarted with larger stepsize\\n')
                runcounter=runcounter+1
        if itcounter==1:
            if norm_grad<mpopt[int(20-1)]:
                stepsize=0.015*step0
            else:
                if norm_grad<2.0*mpopt[int(20-1)]:
                    stepsize=0.05*step0
                else:
                    if norm_grad<4.0*mpopt[int(20-1)]:
                        stepsize=0.3*step0
                    else:
                        if norm_grad<6.0*mpopt[int(20-1)]:
                            stepsize=0.6*step0
                        else:
                            stepsize=step0
        if itcounter>2:
            if max_slackvar>max_slackvar_last+1e-10:
                stepsize=0.7*stepsize
            if max_slackvar<1e-07:
                actual_df=f_last-f
                if abs(predict_df)>1e-12:
                    ratio=actual_df/predict_df
                else:
                    ratio=-99999
                if ratio<0.25 or f>f_last*0.9999:
                    stepsize=0.5*stepsize
                else:
                    if ratio>0.8:
                        stepsize=1.05*stepsize
                if norm(stepsize/step0,inf())>3.0:
                    stepsize=3*step0
        max_slackvar_last=max_slackvar
        f_best=min(f,f_best)
        f_last=f
        predict_df=-(df_dx[1-1:nvars+1-1]).T*dx[1-1:nvars+1-1]
    if etype==1:
        f,g=feval(FUN,x,nargout=2)
    else:
        if etype==2:
            f,g=eval(evalstr,nargout=2)
        else:
            eval(evalstr)
    i=find(g<-mpopt[int(16-1)])
    lambda_[int(i-1)]=zeros(size(i))
    return x,lambda_,converged
def LPeqslvr(x,om,Ybus,Yf,Yt,Afeq,bfeq,Af,bf,mpopt,il,**kwargs):
    x=_copy(x)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    verbose=mpopt[int(31-1)]
    if nargin()<11:
        il=m_array()
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch,gencost=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,mpc.gencost,nargout=5)
    vv=get_idx(om)
    ny=getN(om,'var','y')
    if isempty(il):
        nl=size(branch,1)
        il=(arange(1,nl+1).reshape(1,-1))
    bus[:,VA-1]=x[vv.i1.Va-1:vv.iN.Va+1-1]*180/pi()
    bus[:,VM-1]=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    gen[:,PG-1]=x[vv.i1.Pg-1:vv.iN.Pg+1-1]*baseMVA
    gen[:,QG-1]=x[vv.i1.Qg-1:vv.iN.Qg+1-1]*baseMVA
    if verbose:
        mpopt=mpoption(mpopt,'VERBOSE',verbose-1)
    ref,pv,pq=bustypes(bus,gen,nargout=3)
    V=bus[:,VM-1]*exp(1j*bus[:,VA-1]*pi()/180)
    Sbus=makeSbus(baseMVA,bus,gen)
    V,success,iterations=newtonpf(Ybus,Sbus,V,ref,pv,pq,mpopt,nargout=3)
    bus,gen,branch=pfsoln(baseMVA,bus,gen,branch[il-1,:],Ybus,Yf,Yt,V,ref,pv,pq,nargout=3)
    x[vv.i1.Va-1:vv.iN.Va+1-1]=bus[:,VA-1]*pi()/180
    x[vv.i1.Vm-1:vv.iN.Vm+1-1]=bus[:,VM-1]
    x[vv.i1.Pg-1:vv.iN.Pg+1-1]=gen[:,PG-1]/baseMVA
    x[vv.i1.Qg-1:vv.iN.Qg+1-1]=gen[:,QG-1]/baseMVA
    if ny>0:
        PgQg=m_array([[gen[:,PG-1]],[gen[:,QG-1]]]).reshape(1,-1)
        ipwl=find(gencost[:,MODEL-1]==PW_LINEAR)
        x[vv.i1.y-1:vv.iN.y+1-1]=totcost(gencost[ipwl-1,:],PgQg[int(ipwl-1)])
    return x,success
def lpopf_solver(om,mpopt,**kwargs):
    mpopt=_copy(mpopt)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch,gencost=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,mpc.gencost,nargout=5)
    vv=get_idx(om)
    nb=size(bus,1)
    nl=size(branch,1)
    ny=getN(om,'var','y')
    x0,LB,UB=getv(om,nargout=3)
    nxyz=length(x0)
    om2=om
    om2=add_constraints(om2,'varlims',speye(nxyz,nxyz),LB,UB)
    vv,ll,nn=get_idx(om2,nargout=3)
    A,l,u=linear_constraints(om2,nargout=3)
    ieq=find(abs(u-l)<=eps())
    igt=find(u>=10000000000.0&l>-10000000000.0)
    ilt=find(l<=-10000000000.0&u<10000000000.0)
    ibx=find((abs(u-l)>eps())&(u<10000000000.0)&(l>-10000000000.0))
    Af=m_array([[A[ilt-1,:]],[-A[igt-1,:]],[A[ibx-1,:]],[-A[ibx-1,:]]]).reshape(1,-1)
    bf=m_array([[u[int(ilt-1)]],[-l[int(igt-1)]],[u[int(ibx-1)]],[-l[int(ibx-1)]]]).reshape(1,-1)
    Afeq=A[ieq-1,:]
    bfeq=u[int(ieq-1)]
    Ybus,Yf,Yt=makeYbus(baseMVA,bus,branch,nargout=3)
    il=find(branch[:,RATE_A-1]!=0&branch[:,RATE_A-1]<10000000000.0)
    nl2=length(il)
    mpopt[int(15-1)]=2*nb+length(bfeq)
    if mpopt[int(19-1)]==0:
        mpopt[int(19-1)]=150+2*nb
    x,success_lf=LPeqslvr(x0,om2,Ybus,Yf,Yt,Afeq,bfeq,Af,bf,mpopt,nargout=2)
    if success_lf!=1:
        error('Sorry, cannot find a starting point using power flow, please check data!')
    cstep=0
    if ny>0:
        PgQg=m_array([[gen[:,PG-1]],[gen[:,QG-1]]]).reshape(1,-1)
        ipwl=find(gencost[:,MODEL-1]==PW_LINEAR)
        Cp=totcost(gencost[ipwl-1,:],PgQg[int(ipwl-1)])
        cstep=max(abs(Cp))
        if cstep<1000000.0:
            cstep=1000000.0
    step0=ones(size(x0))
    step0[vv.i1.Va-1:vv.iN.Va+1-1]=2
    step0[vv.i1.Vm-1:vv.iN.Vm+1-1]=1
    step0[vv.i1.Pg-1:vv.iN.Pg+1-1]=0.6
    step0[vv.i1.Qg-1:vv.iN.Qg+1-1]=0.3
    if ny>0:
        step0[vv.i1.y-1:vv.iN.y+1-1]=cstep
    x,lambda_,success=LPconstr('fun_copf',x0,mpopt,step0,m_array(),m_array(),'grad_copf','LPeqslvr',om2,Ybus,Yf[il-1,:],Yt[il-1,:],Afeq,bfeq,Af,bf,mpopt,il,nargout=3)
    info=success
    f,g=feval('fun_copf',x,om2,Ybus,Yf[il-1,:],Yt[il-1,:],Afeq,bfeq,Af,bf,mpopt,il,nargout=2)
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    V=Vm*exp(1j*Va)
    bus[:,VA-1]=Va*180/pi()
    bus[:,VM-1]=Vm
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    gen[:,VG-1]=Vm[int(gen[:,GEN_BUS-1]-1)]
    Sf=V[int(branch[:,F_BUS-1]-1)]*conj(Yf*V)
    St=V[int(branch[:,T_BUS-1]-1)]*conj(Yt*V)
    branch[:,PF-1]=real(Sf)*baseMVA
    branch[:,QF-1]=imag(Sf)*baseMVA
    branch[:,PT-1]=real(St)*baseMVA
    branch[:,QT-1]=imag(St)*baseMVA
    nA=length(u)
    neq=length(ieq)
    nlt=length(ilt)
    ngt=length(igt)
    nbx=length(ibx)
    inln=m_array([(arange(1,2*nb+1).reshape(1,-1)),(arange(1,2*nl2+1).reshape(1,-1))+2*nb+neq]).reshape(1,-1)
    kl=find(lambda_[int(inln-1)]<0)
    ku=find(lambda_[int(inln-1)]>0)
    nl_mu_l=zeros(2*(nb+nl2),1)
    nl_mu_u=zeros(2*(nb+nl2),1)
    nl_mu_l[int(kl-1)]=-lambda_[int(inln[int(kl-1)]-1)]
    nl_mu_u[int(ku-1)]=lambda_[int(inln[int(ku-1)]-1)]
    ilin=m_array([(arange(1,neq+1).reshape(1,-1))+2*nb,(arange(1,(nlt+ngt+2*nbx)+1).reshape(1,-1))+2*nb+neq+2*nl2]).reshape(1,-1)
    kl=find(lambda_[int(ilin[1-1:neq+1-1]-1)]<0)
    ku=find(lambda_[int(ilin[1-1:neq+1-1]-1)]>0)
    mu_l=zeros(nA,1)
    mu_l[int(ieq-1)]=-lambda_[int(ilin[1-1:neq+1-1]-1)]
    mu_l[int(ieq[int(ku-1)]-1)]=0
    mu_l[int(igt-1)]=lambda_[int(ilin[int(neq+nlt+(arange(1,ngt+1).reshape(1,-1))-1)]-1)]
    mu_l[int(ibx-1)]=lambda_[int(ilin[int(neq+nlt+ngt+nbx+(arange(1,nbx+1).reshape(1,-1))-1)]-1)]
    mu_u=zeros(nA,1)
    mu_u[int(ieq-1)]=lambda_[int(ilin[1-1:neq+1-1]-1)]
    mu_u[int(ieq[int(kl-1)]-1)]=0
    mu_u[int(ilt-1)]=lambda_[int(ilin[int(neq+(arange(1,nlt+1).reshape(1,-1))-1)]-1)]
    mu_u[int(ibx-1)]=lambda_[int(ilin[int(neq+nlt+ngt+(arange(1,nbx+1).reshape(1,-1))-1)]-1)]
    muLB=mu_l[ll.i1.varlims-1:ll.iN.varlims+1-1]
    muUB=mu_u[ll.i1.varlims-1:ll.iN.varlims+1-1]
    mu_l[ll.i1.varlims-1:ll.iN.varlims+1-1]=m_array()
    mu_u[ll.i1.varlims-1:ll.iN.varlims+1-1]=m_array()
    muSf=zeros(nl,1)
    muSt=zeros(nl,1)
    muSf[int(il-1)]=2*nl_mu_u[int((arange(1,nl2+1).reshape(1,-1))+2*nb-1)]*branch[il-1,RATE_A-1]/baseMVA
    muSt[int(il-1)]=2*nl_mu_u[int((arange(1,nl2+1).reshape(1,-1))+2*nb+nl2-1)]*branch[il-1,RATE_A-1]/baseMVA
    nl_mu_l=m_array([[nl_mu_l[1-1:2*nb+1-1]],[zeros(2*nl,1)]]).reshape(1,-1)
    nl_mu_u=m_array([[nl_mu_u[1-1:2*nb+1-1]],[muSf],[muSt]]).reshape(1,-1)
    bus[:,MU_VMAX-1]=muUB[vv.i1.Vm-1:vv.iN.Vm+1-1]
    bus[:,MU_VMIN-1]=muLB[vv.i1.Vm-1:vv.iN.Vm+1-1]
    gen[:,MU_PMAX-1]=muUB[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_PMIN-1]=muLB[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_QMAX-1]=muUB[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    gen[:,MU_QMIN-1]=muLB[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    bus[:,LAM_P-1]=(nl_mu_u[nn.i1.Pmis-1:nn.iN.Pmis+1-1]-nl_mu_l[nn.i1.Pmis-1:nn.iN.Pmis+1-1])/baseMVA
    bus[:,LAM_Q-1]=(nl_mu_u[nn.i1.Qmis-1:nn.iN.Qmis+1-1]-nl_mu_l[nn.i1.Qmis-1:nn.iN.Qmis+1-1])/baseMVA
    branch[:,MU_SF-1]=muSf/baseMVA
    branch[:,MU_ST-1]=muSt/baseMVA
    mu=struct('var',struct('l',muLB,'u',muUB),'nln',struct('l',nl_mu_l,'u',nl_mu_u),'lin',struct('l',mu_l,'u',mu_u))
    results=_copy(mpc)
    results.bus,results.branch,results.gen,results.om,results.x,results.mu,results.f=deal(bus,branch,gen,om,x,mu,f,nargout=7)
    pimul=m_array([[results.mu.nln.l-results.mu.nln.u],[results.mu.lin.l-results.mu.lin.u],[-ones(ny>0,1)],[results.mu.var.l-results.mu.var.u]]).reshape(1,-1)
    raw=struct('xr',x,'pimul',pimul,'info',info)
    return results,success,raw
def LPrelax(a,f,b,nequs,vlb,vub,idx_workc,mpopt,**kwargs):
    alg=mpopt[int(11-1)]
    if alg==320:
        idx_workc=find(b<0.001)
    converged=0
    while converged==0:
        atemp=a[idx_workc-1,:]
        btemp=b[int(idx_workc-1)]
        x2,duals=mp_lp(f,atemp,btemp,vlb,vub,m_array(),nequs,-1,100,nargout=2)
        diffs=b-a*x2
        idx_bindc=find(diffs<1e-08)
        if isempty(find(diffs<-1e-08)):
            converged=1
        else:
            flag=zeros(length(b),1)
            flag[int(idx_workc-1)]=ones(length(idx_workc),1)
            idx_add=find(diffs<0.001)
            flag[int(idx_add-1)]=ones(length(idx_add),1)
            flag[1-1:nequs+1-1]=ones(nequs,1)
            idx_workc_new=find(flag)
            if length(idx_workc)==length(idx_workc_new):
                if isempty(find(idx_workc-idx_workc_new)):
                    converged=1
            idx_workc=idx_workc_new
    duals_rlx=zeros(length(b),1)
    duals_rlx[int(idx_workc-1)]=duals[1-1:length(btemp)+1-1]
    return x2,duals_rlx,idx_workc,idx_bindc
def makeAang(baseMVA,branch,nb,mpopt,**kwargs):
    ignore_ang_lim=mpopt[int(25-1)]
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    if ignore_ang_lim:
        Aang=sparse(0,nb)
        lang=m_array()
        uang=m_array()
        iang=m_array()
    else:
        iang=find((branch[:,ANGMIN-1]&branch[:,ANGMIN-1]>-360)|(branch[:,ANGMAX-1]&branch[:,ANGMAX-1]<360))
        iangl=find(branch[iang-1,ANGMIN-1])
        iangh=find(branch[iang-1,ANGMAX-1])
        nang=length(iang)
        if nang>0:
            ii=m_array([[(arange(1,nang+1).reshape(1,-1)).T],[(arange(1,nang+1).reshape(1,-1)).T]]).reshape(1,-1)
            jj=m_array([[branch[iang-1,F_BUS-1]],[branch[iang-1,T_BUS-1]]]).reshape(1,-1)
            Aang=sparse(ii,jj,m_array([[ones(nang,1)],[-ones(nang,1)]]).reshape(1,-1),nang,nb)
            uang=Inf()*ones(nang,1)
            lang=-uang
            lang[int(iangl-1)]=branch[iang[int(iangl-1)]-1,ANGMIN-1]*pi()/180
            uang[int(iangh-1)]=branch[iang[int(iangh-1)]-1,ANGMAX-1]*pi()/180
        else:
            Aang=sparse(0,nb)
            lang=m_array()
            uang=m_array()
    return Aang,lang,uang,iang
def makeAvl(baseMVA,gen,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    ng=size(gen,1)
    Pg=gen[:,PG-1]/baseMVA
    Qg=gen[:,QG-1]/baseMVA
    Pmin=gen[:,PMIN-1]/baseMVA
    Qmin=gen[:,QMIN-1]/baseMVA
    Qmax=gen[:,QMAX-1]/baseMVA
    ivl=find(isload(gen)&(Qmin!=0|Qmax!=0))
    nvl=size(ivl,1)
    if any(Qmin[int(ivl-1)]!=0&Qmax[int(ivl-1)]!=0):
        error('makeAvl: either Qmin or Qmax must be equal to zero for each dispatchable load.')
    Qlim=(Qmin[int(ivl-1)]==0)*Qmax[int(ivl-1)]+(Qmax[int(ivl-1)]==0)*Qmin[int(ivl-1)]
    if any(abs(Qg[int(ivl-1)]-Pg[int(ivl-1)]*Qlim/Pmin[int(ivl-1)])>1e-06):
        error('makeAvl: %s\\n         %s\\n','For a dispatchable load, PG and QG must be consistent','with the power factor defined by PMIN and the Q limits.')
    if nvl>0:
        xx=Pmin[int(ivl-1)]
        yy=Qlim
        pftheta=atan2(yy,xx)
        pc=sin(pftheta)
        qc=-cos(pftheta)
        ii=m_array([[(arange(1,nvl+1).reshape(1,-1)).T],[(arange(1,nvl+1).reshape(1,-1)).T]]).reshape(1,-1)
        jj=m_array([[ivl],[ivl+ng]]).reshape(1,-1)
        Avl=sparse(ii,jj,m_array([[pc],[qc]]).reshape(1,-1),nvl,2*ng)
        lvl=zeros(nvl,1)
        uvl=lvl
    else:
        Avl=sparse(0,2*ng)
        lvl=m_array()
        uvl=m_array()
    return Avl,lvl,uvl,ivl
def makeAy(baseMVA,ng,gencost,pgbas,qgbas,ybas,**kwargs):
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    iycost=find(gencost[:,MODEL-1]==PW_LINEAR)
    ny=size(iycost,1)
    if ny==0:
        Ay=sparse(m_array(),m_array(),m_array(),0,ybas+ny-1,0)
        by=m_array()
        return Ay,by
    m=sum(gencost[iycost-1,NCOST-1])
    Ay=sparse(m_array(),m_array(),m_array(),m-ny,ybas+ny-1,2*(m-ny))
    by=m_array()
    k=1
    for i in iycost.T.flat:
        ns=gencost[i-1,NCOST-1]
        p=gencost[i-1,COST-1:2:COST+2*ns-1+1-1]/baseMVA
        c=gencost[i-1,COST+1-1:2:COST+2*ns+1-1]
        m=diff(c)/diff(p)
        if any(diff(p)==0):
            fprintf('\\nmakeAy: bad x axis data in row %i of gencost matrix\\n',i)
        b=m*p[1-1:ns-1+1-1]-c[1-1:ns-1+1-1]
        by=m_array([[by],[b.T]]).reshape(1,-1)
        if i>ng:
            sidx=qgbas+(i-ng)-1
        else:
            sidx=pgbas+i-1
        Ay[k-1:k+ns-2+1-1,sidx-1]=m.T
        k=k+ns-1
    k=1
    j=1
    for i in iycost.T.flat:
        ns=gencost[i-1,NCOST-1]
        Ay[k-1:k+ns-2+1-1,ybas+j-1-1]=-ones(ns-1,1)
        k=k+ns-1
        j=j+1
    return Ay,by
def makeBdc(baseMVA,bus,branch,**kwargs):
    nb=size(bus,1)
    nl=size(branch,1)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    if any(bus[:,BUS_I-1]!=(arange(1,nb+1).reshape(1,-1)).T):
        error('makeBdc: buses must be numbered consecutively in bus matrix')
    stat=branch[:,BR_STATUS-1]
    b=stat/branch[:,BR_X-1]
    tap=ones(nl,1)
    i=find(branch[:,TAP-1])
    tap[int(i-1)]=branch[i-1,TAP-1]
    b=b/tap
    f=branch[:,F_BUS-1]
    t=branch[:,T_BUS-1]
    i=m_array([[(arange(1,nl+1).reshape(1,-1)).T],[(arange(1,nl+1).reshape(1,-1)).T]]).reshape(1,-1)
    Cft=sparse(i,m_array([[f],[t]]).reshape(1,-1),m_array([[ones(nl,1)],[-ones(nl,1)]]).reshape(1,-1),nl,nb)
    Bf=sparse(i,m_array([[f],[t]]).reshape(1,-1),m_array([[b],[-b]]).reshape(1,-1))
    Bbus=Cft.T*Bf
    Pfinj=b*(-branch[:,SHIFT-1]*pi()/180)
    Pbusinj=Cft.T*Pfinj
    return Bbus,Bf,Pbusinj,Pfinj
def makeB(baseMVA,bus,branch,alg,**kwargs):
    nb=size(bus,1)
    nl=size(branch,1)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    temp_branch=_copy(branch)
    temp_bus=_copy(bus)
    temp_bus[:,BS-1]=zeros(nb,1)
    temp_branch[:,BR_B-1]=zeros(nl,1)
    temp_branch[:,TAP-1]=ones(nl,1)
    if alg==2:
        temp_branch[:,BR_R-1]=zeros(nl,1)
    Bp=-imag(makeYbus(baseMVA,temp_bus,temp_branch))
    if nargout()==2:
        temp_branch=_copy(branch)
        temp_branch[:,SHIFT-1]=zeros(nl,1)
        if alg==3:
            temp_branch[:,BR_R-1]=zeros(nl,1)
        Bpp=-imag(makeYbus(baseMVA,bus,temp_branch))
    return Bp,Bpp
def makeJac(baseMVA,bus,branch,gen,**kwargs):
    if nargin()<4:
        mpc=baseMVA
        baseMVA=mpc.baseMVA
        bus=mpc.bus
        branch=mpc.branch
        gen=mpc.gen
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    ref,pv,pq=bustypes(bus,gen,nargout=3)
    Ybus,Yf,Yt=makeYbus(baseMVA,bus,branch,nargout=3)
    V=bus[:,VM-1]*exp(sqrt(-1)*pi()/180*bus[:,VA-1])
    on=find(gen[:,GEN_STATUS-1]>0)
    gbus=gen[on-1,GEN_BUS-1]
    V[int(gbus-1)]=gen[on-1,VG-1]/abs(V[int(gbus-1)])*V[int(gbus-1)]
    dSbus_dVm,dSbus_dVa=dSbus_dV(Ybus,V,nargout=2)
    j11=real(dSbus_dVa[m_array([[pv],[pq]]).reshape(1,-1)-1,m_array([[pv],[pq]]).reshape(1,-1)-1])
    j12=real(dSbus_dVm[m_array([[pv],[pq]]).reshape(1,-1)-1,pq-1])
    j21=imag(dSbus_dVa[pq-1,m_array([[pv],[pq]]).reshape(1,-1)-1])
    j22=imag(dSbus_dVm[pq-1,pq-1])
    J=m_array([[j11,j12],[j21,j22]]).reshape(1,-1)
    return J,Ybus,Yf,Yt
def makeLODF(branch,PTDF,**kwargs):
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    nl,nb=size(PTDF,nargout=2)
    f=branch[:,F_BUS-1]
    t=branch[:,T_BUS-1]
    Cft=sparse(m_array([[f],[t]]).reshape(1,-1),m_array([arange(1,nl+1).reshape(1,-1),arange(1,nl+1).reshape(1,-1)]).reshape(1,-1).T,m_array([[ones(nl,1)],[-ones(nl,1)]]).reshape(1,-1),nb,nl)
    H=PTDF*Cft
    h=diag(H,0)
    LODF=H/(ones(nl,nl)-ones(nl,1)*h.T)
    LODF=LODF-diag(diag(LODF))-eye(nl,nl)
    return LODF
def makePTDF(baseMVA,bus,branch,slack,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    if nargin()<4:
        slack=find(bus[:,BUS_TYPE-1]==REF)
        slack=slack[int(1-1)]
    if length(slack)==1:
        slack_bus=slack
    else:
        slack_bus=1
    nb=size(bus,1)
    nbr=size(branch,1)
    noref=(arange(2,nb+1).reshape(1,-1)).T
    noslack=find((arange(1,nb+1).reshape(1,-1)).T!=slack_bus)
    if any(bus[:,BUS_I-1]!=(arange(1,nb+1).reshape(1,-1)).T):
        error('makePTDF: buses must be numbered consecutively in bus matrix')
    Bbus,Bf,Pbusinj,Pfinj=makeBdc(baseMVA,bus,branch,nargout=4)
    H=zeros(nbr,nb)
    H[:,noslack-1]=full(Bf[:,noref-1]/Bbus[noslack-1,noref-1])
    if length(slack)!=1:
        if size(slack,2)==1:
            slack=slack/sum(slack)
            v=H*slack
            for k in arange(1,nb+1).reshape(1,-1).flat:
                H[:,k-1]=H[:,k-1]-v
        else:
            H=H*slack
    return H
def makeSbus(baseMVA,bus,gen,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    on=find(gen[:,GEN_STATUS-1]>0)
    gbus=gen[on-1,GEN_BUS-1]
    nb=size(bus,1)
    ngon=size(on,1)
    Cg=sparse(gbus,(arange(1,ngon+1).reshape(1,-1)).T,ones(ngon,1),nb,ngon)
    Sbus=(Cg*(gen[on-1,PG-1]+1j*gen[on-1,QG-1])-(bus[:,PD-1]+1j*bus[:,QD-1]))/baseMVA
    return Sbus
def makeYbus(baseMVA,bus,branch,**kwargs):
    if nargin()<3:
        mpc=baseMVA
        baseMVA=mpc.baseMVA
        bus=mpc.bus
        branch=mpc.branch
    nb=size(bus,1)
    nl=size(branch,1)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    if any(bus[:,BUS_I-1]!=(arange(1,nb+1).reshape(1,-1)).T):
        error('buses must appear in order by bus number')
    stat=branch[:,BR_STATUS-1]
    Ys=stat/(branch[:,BR_R-1]+1j*branch[:,BR_X-1])
    Bc=stat*branch[:,BR_B-1]
    tap=ones(nl,1)
    i=find(branch[:,TAP-1])
    tap[int(i-1)]=branch[i-1,TAP-1]
    tap=tap*exp(1j*pi()/180*branch[:,SHIFT-1])
    Ytt=Ys+1j*Bc/2
    Yff=Ytt/(tap*conj(tap))
    Yft=-Ys/conj(tap)
    Ytf=-Ys/tap
    Ysh=(bus[:,GS-1]+1j*bus[:,BS-1])/baseMVA
    f=branch[:,F_BUS-1]
    t=branch[:,T_BUS-1]
    Cf=sparse(arange(1,nl+1).reshape(1,-1),f,ones(nl,1),nl,nb)
    Ct=sparse(arange(1,nl+1).reshape(1,-1),t,ones(nl,1),nl,nb)
    i=m_array([[arange(1,nl+1).reshape(1,-1)],[arange(1,nl+1).reshape(1,-1)]]).reshape(1,-1).T
    Yf=sparse(i,m_array([[f],[t]]).reshape(1,-1),m_array([[Yff],[Yft]]).reshape(1,-1),nl,nb)
    Yt=sparse(i,m_array([[f],[t]]).reshape(1,-1),m_array([[Ytf],[Ytt]]).reshape(1,-1),nl,nb)
    Ybus=Cf.T*Yf+Ct.T*Yt+sparse(arange(1,nb+1).reshape(1,-1),arange(1,nb+1).reshape(1,-1),Ysh,nb,nb)
    return Ybus,Yf,Yt
def mips6opf_solver(om,mpopt,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    verbose=mpopt[int(31-1)]
    feastol=mpopt[int(81-1)]
    gradtol=mpopt[int(82-1)]
    comptol=mpopt[int(83-1)]
    costtol=mpopt[int(84-1)]
    max_it=mpopt[int(85-1)]
    max_red=mpopt[int(86-1)]
    step_control=(mpopt[int(11-1)]==565)
    if feastol==0:
        feastol=mpopt[int(16-1)]
    opt=struct('feastol',feastol,'gradtol',gradtol,'comptol',comptol,'costtol',costtol,'max_it',max_it,'max_red',max_red,'step_control',step_control,'cost_mult',0.0001,'verbose',verbose)
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch,gencost=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,mpc.gencost,nargout=5)
    vv,ll,nn=get_idx(om,nargout=3)
    nb=size(bus,1)
    nl=size(branch,1)
    ny=getN(om,'var','y')
    A,l,u=linear_constraints(om,nargout=3)
    x0,xmin,xmax=getv(om,nargout=3)
    Ybus,Yf,Yt=makeYbus(baseMVA,bus,branch,nargout=3)
    ll=_copy(xmin)
    uu=_copy(xmax)
    ll[int(xmin==-Inf())]=-10000000000.0
    uu[int(xmax==Inf())]=10000000000.0
    x0=(ll+uu)/2
    Varefs=bus[bus[:,BUS_TYPE-1]==REF,VA-1]*(pi()/180)
    x0[vv.i1.Va-1:vv.iN.Va+1-1]=Varefs[int(1-1)]
    if ny>0:
        ipwl=find(gencost[:,MODEL-1]==PW_LINEAR)
        c=gencost[int(sub2ind(size(gencost),ipwl,NCOST+2*gencost[ipwl-1,NCOST-1])-1)]
        x0[vv.i1.y-1:vv.iN.y+1-1]=max(c)+0.1*abs(max(c))
    il=find(branch[:,RATE_A-1]!=0&branch[:,RATE_A-1]<10000000000.0)
    nl2=length(il)
    f_fcn=opf_costfcn()
    gh_fcn=opf_consfcn()
    ipm_hessian=opf_hessfcn()
    x,f,info,Output,Lambda=mips6(f_fcn,x0,A,l,u,xmin,xmax,gh_fcn,ipm_hessian,opt,om,Ybus,Yf[il-1,:],Yt[il-1,:],mpopt,il,nargout=5)
    success=(info>0)
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    V=Vm*exp(1j*Va)
    bus[:,VA-1]=Va*180/pi()
    bus[:,VM-1]=Vm
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    gen[:,VG-1]=Vm[int(gen[:,GEN_BUS-1]-1)]
    Sf=V[int(branch[:,F_BUS-1]-1)]*conj(Yf*V)
    St=V[int(branch[:,T_BUS-1]-1)]*conj(Yt*V)
    branch[:,PF-1]=real(Sf)*baseMVA
    branch[:,QF-1]=imag(Sf)*baseMVA
    branch[:,PT-1]=real(St)*baseMVA
    branch[:,QT-1]=imag(St)*baseMVA
    muSf=zeros(nl,1)
    muSt=zeros(nl,1)
    if  not isempty(il):
        muSf[int(il-1)]=2*Lambda.ineqnonlin[1-1:nl2+1-1]*branch[il-1,RATE_A-1]/baseMVA
        muSt[int(il-1)]=2*Lambda.ineqnonlin[int((arange(1,nl2+1).reshape(1,-1))+nl2-1)]*branch[il-1,RATE_A-1]/baseMVA
    bus[:,MU_VMAX-1]=Lambda.upper[vv.i1.Vm-1:vv.iN.Vm+1-1]
    bus[:,MU_VMIN-1]=Lambda.lower[vv.i1.Vm-1:vv.iN.Vm+1-1]
    gen[:,MU_PMAX-1]=Lambda.upper[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_PMIN-1]=Lambda.lower[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_QMAX-1]=Lambda.upper[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    gen[:,MU_QMIN-1]=Lambda.lower[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    bus[:,LAM_P-1]=Lambda.eqnonlin[nn.i1.Pmis-1:nn.iN.Pmis+1-1]/baseMVA
    bus[:,LAM_Q-1]=Lambda.eqnonlin[nn.i1.Qmis-1:nn.iN.Qmis+1-1]/baseMVA
    branch[:,MU_SF-1]=muSf/baseMVA
    branch[:,MU_ST-1]=muSt/baseMVA
    nlnN=getN(om,'nln')
    kl=find(Lambda.eqnonlin<0)
    ku=find(Lambda.eqnonlin>0)
    nl_mu_l=zeros(nlnN,1)
    nl_mu_u=m_array([[zeros(2*nb,1)],[muSf],[muSt]]).reshape(1,-1)
    nl_mu_l[int(kl-1)]=-Lambda.eqnonlin[int(kl-1)]
    nl_mu_u[int(ku-1)]=Lambda.eqnonlin[int(ku-1)]
    mu=struct('var',struct('l',Lambda.lower,'u',Lambda.upper),'nln',struct('l',nl_mu_l,'u',nl_mu_u),'lin',struct('l',Lambda.mu_l,'u',Lambda.mu_u))
    results=_copy(mpc)
    results.bus,results.branch,results.gen,results.om,results.x,results.mu,results.f=deal(bus,branch,gen,om,x,mu,f,nargout=7)
    pimul=m_array([[results.mu.nln.l-results.mu.nln.u],[results.mu.lin.l-results.mu.lin.u],[-ones(ny>0,1)],[results.mu.var.l-results.mu.var.u]]).reshape(1,-1)
    raw=struct('xr',x,'pimul',pimul,'info',info,'output',Output)
    return results,success,raw
def mipsopf_solver(om,mpopt,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    verbose=mpopt[int(31-1)]
    feastol=mpopt[int(81-1)]
    gradtol=mpopt[int(82-1)]
    comptol=mpopt[int(83-1)]
    costtol=mpopt[int(84-1)]
    max_it=mpopt[int(85-1)]
    max_red=mpopt[int(86-1)]
    step_control=(mpopt[int(11-1)]==565)
    if feastol==0:
        feastol=mpopt[int(16-1)]
    opt=struct('feastol',feastol,'gradtol',gradtol,'comptol',comptol,'costtol',costtol,'max_it',max_it,'max_red',max_red,'step_control',step_control,'cost_mult',0.0001,'verbose',verbose)
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch,gencost=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,mpc.gencost,nargout=5)
    vv,ll,nn=get_idx(om,nargout=3)
    nb=size(bus,1)
    nl=size(branch,1)
    ny=getN(om,'var','y')
    A,l,u=linear_constraints(om,nargout=3)
    x0,xmin,xmax=getv(om,nargout=3)
    Ybus,Yf,Yt=makeYbus(baseMVA,bus,branch,nargout=3)
    ll=_copy(xmin)
    uu=_copy(xmax)
    ll[int(xmin==-Inf())]=-10000000000.0
    uu[int(xmax==Inf())]=10000000000.0
    x0=(ll+uu)/2
    Varefs=bus[bus[:,BUS_TYPE-1]==REF,VA-1]*(pi()/180)
    x0[vv.i1.Va-1:vv.iN.Va+1-1]=Varefs[int(1-1)]
    if ny>0:
        ipwl=find(gencost[:,MODEL-1]==PW_LINEAR)
        c=gencost[int(sub2ind(size(gencost),ipwl,NCOST+2*gencost[ipwl-1,NCOST-1])-1)]
        x0[vv.i1.y-1:vv.iN.y+1-1]=max(c)+0.1*abs(max(c))
    il=find(branch[:,RATE_A-1]!=0&branch[:,RATE_A-1]<10000000000.0)
    nl2=length(il)
    f_fcn=lambda x: opf_costfcn(x(),om)
    gh_fcn=lambda x: opf_consfcn(x,om,Ybus,Yf[il-1,:],Yt[il-1,:],mpopt,il)
    hess_fcn=lambda x,lambda_,cost_mult: opf_hessfcn(x,lambda_(),cost_mult(),om,Ybus,Yf[il-1,:],Yt[il-1,:],mpopt,il)
    x,f,info,Output,Lambda=mips(f_fcn,x0,A,l,u,xmin,xmax,gh_fcn,hess_fcn,opt,nargout=5)
    success=(info>0)
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    V=Vm*exp(1j*Va)
    bus[:,VA-1]=Va*180/pi()
    bus[:,VM-1]=Vm
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    gen[:,VG-1]=Vm[int(gen[:,GEN_BUS-1]-1)]
    Sf=V[int(branch[:,F_BUS-1]-1)]*conj(Yf*V)
    St=V[int(branch[:,T_BUS-1]-1)]*conj(Yt*V)
    branch[:,PF-1]=real(Sf)*baseMVA
    branch[:,QF-1]=imag(Sf)*baseMVA
    branch[:,PT-1]=real(St)*baseMVA
    branch[:,QT-1]=imag(St)*baseMVA
    muSf=zeros(nl,1)
    muSt=zeros(nl,1)
    if  not isempty(il):
        muSf[int(il-1)]=2*Lambda.ineqnonlin[1-1:nl2+1-1]*branch[il-1,RATE_A-1]/baseMVA
        muSt[int(il-1)]=2*Lambda.ineqnonlin[int((arange(1,nl2+1).reshape(1,-1))+nl2-1)]*branch[il-1,RATE_A-1]/baseMVA
    bus[:,MU_VMAX-1]=Lambda.upper[vv.i1.Vm-1:vv.iN.Vm+1-1]
    bus[:,MU_VMIN-1]=Lambda.lower[vv.i1.Vm-1:vv.iN.Vm+1-1]
    gen[:,MU_PMAX-1]=Lambda.upper[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_PMIN-1]=Lambda.lower[vv.i1.Pg-1:vv.iN.Pg+1-1]/baseMVA
    gen[:,MU_QMAX-1]=Lambda.upper[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    gen[:,MU_QMIN-1]=Lambda.lower[vv.i1.Qg-1:vv.iN.Qg+1-1]/baseMVA
    bus[:,LAM_P-1]=Lambda.eqnonlin[nn.i1.Pmis-1:nn.iN.Pmis+1-1]/baseMVA
    bus[:,LAM_Q-1]=Lambda.eqnonlin[nn.i1.Qmis-1:nn.iN.Qmis+1-1]/baseMVA
    branch[:,MU_SF-1]=muSf/baseMVA
    branch[:,MU_ST-1]=muSt/baseMVA
    nlnN=getN(om,'nln')
    kl=find(Lambda.eqnonlin<0)
    ku=find(Lambda.eqnonlin>0)
    nl_mu_l=zeros(nlnN,1)
    nl_mu_u=m_array([[zeros(2*nb,1)],[muSf],[muSt]]).reshape(1,-1)
    nl_mu_l[int(kl-1)]=-Lambda.eqnonlin[int(kl-1)]
    nl_mu_u[int(ku-1)]=Lambda.eqnonlin[int(ku-1)]
    mu=struct('var',struct('l',Lambda.lower,'u',Lambda.upper),'nln',struct('l',nl_mu_l,'u',nl_mu_u),'lin',struct('l',Lambda.mu_l,'u',Lambda.mu_u))
    results=_copy(mpc)
    results.bus,results.branch,results.gen,results.om,results.x,results.mu,results.f=deal(bus,branch,gen,om,x,mu,f,nargout=7)
    pimul=m_array([[results.mu.nln.l-results.mu.nln.u],[results.mu.lin.l-results.mu.lin.u],[-ones(ny>0,1)],[results.mu.var.l-results.mu.var.u]]).reshape(1,-1)
    raw=struct('xr',x,'pimul',pimul,'info',info,'output',Output)
    return results,success,raw
def mipsver(varargin,**kwargs):
    v=struct('Name','MIPS','Version','1.0','Release','','Date','07-Feb-2011')
    if nargout()>0:
        if nargin()>0:
            rv=v
        else:
            rv=v.Version
    else:
        fprintf('%-22s Version %-9s  %11s\\n',v.Name,v.Version,v.Date)
    return rv
def modcost(gencost,alpha,modtype,**kwargs):
    gencost=_copy(gencost)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    if nargin()<3:
        modtype='SCALE_F'
    ng,m=size(gencost,nargout=2)
    if ng!=0:
        ipwl=find(gencost[:,MODEL-1]==PW_LINEAR)
        ipol=find(gencost[:,MODEL-1]==POLYNOMIAL)
        c=gencost[ipol-1,COST-1:m+1-1]
        if 'SCALE_F'==modtype:
            gencost[ipol-1,COST-1:m+1-1]=alpha*c
            gencost[ipwl-1,COST+1-1:2:m+1-1]=alpha*gencost[ipwl-1,COST+1-1:2:m+1-1]
        else:
            if 'SCALE_X'==modtype:
                for k in arange(1,length(ipol)+1).reshape(1,-1).flat:
                    n=gencost[ipol[int(k-1)]-1,NCOST-1]
                    for i in arange(1,n+1).reshape(1,-1).flat:
                        gencost[ipol[int(k-1)]-1,COST+i-1-1]=c[k-1,i-1]/alpha**(n-i)
                gencost[ipwl-1,COST-1:2:m-1+1-1]=alpha*gencost[ipwl-1,COST-1:2:m-1+1-1]
            else:
                if 'SHIFT_F'==modtype:
                    for k in arange(1,length(ipol)+1).reshape(1,-1).flat:
                        n=gencost[ipol[int(k-1)]-1,NCOST-1]
                        gencost[ipol[int(k-1)]-1,COST+n-1-1]=alpha+c[k-1,n-1]
                    gencost[ipwl-1,COST+1-1:2:m+1-1]=alpha+gencost[ipwl-1,COST+1-1:2:m+1-1]
                else:
                    if 'SHIFT_X'==modtype:
                        for k in arange(1,length(ipol)+1).reshape(1,-1).flat:
                            n=gencost[ipol[int(k-1)]-1,NCOST-1]
                            gencost[ipol[int(k-1)]-1,COST-1:COST+n-1+1-1]=polyshift(c[k-1,1-1:n+1-1].T,alpha).T
                        gencost[ipwl-1,COST-1:2:m-1+1-1]=alpha+gencost[ipwl-1,COST-1:2:m-1+1-1]
                    else:
                        error("modcost: '%s' is not a valid modtype\\n",modtype)
    return gencost
def polyshift(c,a,**kwargs):
    n=length(c)
    d=zeros(size(c))
    A=(-a*ones(n,1))**((arange(0,n-1+1).reshape(1,-1)).T)
    b=ones(n,1)
    for k in arange(1,n+1).reshape(1,-1).flat:
        d[int(n-k+1-1)]=b.T*(c[n-k+1-1:-1:1+1-1]*A[1-1:n-k+1+1-1])
        b=cumsum(b[1-1:n-k+1-1])
    return d
def mpoption(varargin,**kwargs):
    i=1
    if rem(nargin(),2):
        options=varargin[1-1]
        i=2
    else:
        options=m_array([[1],[1e-08],[10],[30],[1000],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[5e-06],[0.0001],[0.0001],[0],[0.003],[0.0001],[400],[5],[0],[0],[0],[0],[0],[0],[0],[1],[-1],[1],[0],[1],[1],[0],[-1],[1],[1],[1],[1],[0],[0],[0],[0],[0],[0],[0],[0],[1],[0],[0],[0],[4],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[-1],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[1e-06],[1e-06],[1e-06],[150],[20],[0],[0.0005],[0.0005],[1e-05],[40],[100],[0.04],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[1],[Inf()],[0],[0]]).reshape(1,-1)
    names=char('PF_ALG','PF_TOL','PF_MAX_IT','PF_MAX_IT_FD','PF_MAX_IT_GS','ENFORCE_Q_LIMS','RESERVED7','RESERVED8','RESERVED9','PF_DC')
    names=char(names,'OPF_ALG','RESERVED12','RESERVED13','RESERVED14','OPF_NEQ','OPF_VIOLATION','CONSTR_TOL_X','CONSTR_TOL_F','CONSTR_MAX_IT','LPC_TOL_GRAD')
    names=char(names,'LPC_TOL_X','LPC_MAX_IT','LPC_MAX_RESTART','OPF_FLOW_LIM','OPF_IGNORE_ANG_LIM','OPF_ALG_DC','RESERVED27','RESERVED28','RESERVED29','RESERVED30')
    names=char(names,'VERBOSE','OUT_ALL','OUT_SYS_SUM','OUT_AREA_SUM','OUT_BUS','OUT_BRANCH','OUT_GEN','OUT_ALL_LIM','OUT_V_LIM','OUT_LINE_LIM')
    names=char(names,'OUT_PG_LIM','OUT_QG_LIM','RESERVED43','RESERVED44','RESERVED45','RESERVED46','RESERVED47','RESERVED48','RESERVED49','RESERVED50')
    names=char(names,'SPARSE_QP','RETURN_RAW_DER','RESERVED53','RESERVED54','FMC_ALG','RESERVED56','RESERVED57','KNITRO_OPT','RESERVED59','IPOPT_OPT')
    names=char(names,'MNS_FEASTOL','MNS_ROWTOL','MNS_XTOL','MNS_MAJDAMP','MNS_MINDAMP','MNS_PENALTY_PARM','MNS_MAJOR_IT','MNS_MINOR_IT','MNS_MAX_IT','MNS_VERBOSITY')
    names=char(names,'MNS_CORE','MNS_SUPBASIC_LIM','MNS_MULT_PRICE','RESERVED74','RESERVED75','RESERVED76','RESERVED77','RESERVED78','RESERVED79','FORCE_PC_EQ_P0')
    names=char(names,'PDIPM_FEASTOL','PDIPM_GRADTOL','PDIPM_COMPTOL','PDIPM_COSTTOL','PDIPM_MAX_IT','SCPDIPM_RED_IT','TRALM_FEASTOL','TRALM_PRIMETOL','TRALM_DUALTOL','TRALM_COSTTOL','TRALM_MAJOR_IT','TRALM_MINOR_IT','SMOOTHING_RATIO')
    names=char(names,'RESERVED94','CPLEX_LPMETHOD','CPLEX_QPMETHOD','CPLEX_OPT','RESERVED98','RESERVED99','RESERVED100','RESERVED101','RESERVED102','RESERVED103','RESERVED104','RESERVED105','RESERVED106','RESERVED107','RESERVED108','RESERVED109','RESERVED110')
    names=char(names,'MOSEK_LP_ALG','MOSEK_MAX_IT','MOSEK_GAP_TOL','MOSEK_MAX_TIME','MOSEK_NUM_THREADS','MOSEK_OPT','RESERVED117','RESERVED118','RESERVED119','RESERVED120')
    names=char(names,'GRB_METHOD','GRB_TIMELIMIT','GRB_THREADS','GRB_OPT')
    while i<=nargin():
        pname=varargin[i-1]
        pval=varargin[i+1-1]
        namestr=names.T
        namestr=namestr[:].T
        namelen=size(names,2)
        pidx=ceil(findstr(m_array([pname,blanks(namelen-length(pname))]).reshape(1,-1),namestr)/namelen)
        if isempty(pidx):
            error('"%s" is not a valid named option',pname)
        options[int(pidx-1)]=pval
        i=i+2
    return options,names
def mp_qp(H,f,A,b,VLB,VUB,x0,N,verbose,alg,opt,**kwargs):
    if nargin()<11:
        opt=m_array()
        if nargin()<10:
            alg=0
    if verbose==-1:
        verbose=0
    qps_opt=struct('alg',alg,'verbose',verbose)
    if  not isempty(opt):
        qps_opt.mips_opt=opt
    m=size(A,1)
    l=_copy(b)
    l[(N+1)-1:m+1-1]=-Inf()*ones(m-N,1)
    xout,fval,howout,output,lambda_=qps_matpower(H,f,A,l,b,VLB,VUB,x0,qps_opt,nargout=5)
    if nargout()>1:
        lambdaout=m_array([[lambda_.mu_u-lambda_.mu_l],[lambda_.lower],[lambda_.upper]]).reshape(1,-1)
        if nargout()>3:
            success=(howout==1)
    return xout,lambdaout,howout,success
def newtonpf(Ybus,Sbus,V0,ref,pv,pq,mpopt,**kwargs):
    if nargin()<7:
        mpopt=mpoption()
    tol=mpopt[int(2-1)]
    max_it=mpopt[int(3-1)]
    verbose=mpopt[int(31-1)]
    converged=0
    i=0
    V=V0
    Va=angle(V)
    Vm=abs(V)
    npv=length(pv)
    npq=length(pq)
    j1=1
    j2=npv
    j3=j2+1
    j4=j2+npq
    j5=j4+1
    j6=j4+npq
    mis=V*conj(Ybus*V)-Sbus
    F=m_array([[real(mis[int(m_array([[pv],[pq]]).reshape(1,-1)-1)])],[imag(mis[int(pq-1)])]]).reshape(1,-1)
    normF=norm(F,inf())
    if verbose>1:
        fprintf('\\n it    max P & Q mismatch (p.u.)')
        fprintf('\\n----  ---------------------------')
        fprintf('\\n%3d        %10.3e',i,normF)
    if normF<tol:
        converged=1
        if verbose>1:
            fprintf('\\nConverged!\\n')
    while ( not converged and i<max_it):
        i=i+1
        dSbus_dVm,dSbus_dVa=dSbus_dV(Ybus,V,nargout=2)
        j11=real(dSbus_dVa[m_array([[pv],[pq]]).reshape(1,-1)-1,m_array([[pv],[pq]]).reshape(1,-1)-1])
        j12=real(dSbus_dVm[m_array([[pv],[pq]]).reshape(1,-1)-1,pq-1])
        j21=imag(dSbus_dVa[pq-1,m_array([[pv],[pq]]).reshape(1,-1)-1])
        j22=imag(dSbus_dVm[pq-1,pq-1])
        J=m_array([[j11,j12],[j21,j22]]).reshape(1,-1)
        dx=-(numpy.linalg.solve(J,F))
        if npv:
            Va[int(pv-1)]=Va[int(pv-1)]+dx[j1-1:j2+1-1]
        if npq:
            Va[int(pq-1)]=Va[int(pq-1)]+dx[j3-1:j4+1-1]
            Vm[int(pq-1)]=Vm[int(pq-1)]+dx[j5-1:j6+1-1]
        V=Vm*exp(1j*Va)
        Vm=abs(V)
        Va=angle(V)
        mis=V*conj(Ybus*V)-Sbus
        F=m_array([[real(mis[int(pv-1)])],[real(mis[int(pq-1)])],[imag(mis[int(pq-1)])]]).reshape(1,-1)
        normF=norm(F,inf())
        if verbose>1:
            fprintf('\\n%3d        %10.3e',i,normF)
        if normF<tol:
            converged=1
            if verbose:
                fprintf("\\nNewton's method power flow converged in %d iterations.\\n",i)
    if verbose:
        if  not converged:
            fprintf("\\nNewton's method power did not converge in %d iterations.\\n",i)
    return V,converged,i
def opf_args(baseMVA,bus,gen,branch,areas,gencost,Au,lbu,ubu,mpopt,N,fparm,H,Cw,z0,zl,zu,**kwargs):
    if nargout()==2:
        want_mpc=1
    else:
        want_mpc=0
    userfcn=m_array()
    if ischar(baseMVA) or isstruct(baseMVA):
        if any(nargin()==m_array([1,2,3,4,5,9,12]).reshape(1,-1)):
            casefile=baseMVA
            if nargin()==12:
                zu=fparm
                zl=N
                z0=mpopt
                Cw=ubu
                H=lbu
                fparm=Au
                N=gencost
                mpopt=areas
                ubu=branch
                lbu=gen
                Au=bus
            else:
                if nargin()==9:
                    zu=m_array()
                    zl=m_array()
                    z0=m_array()
                    Cw=ubu
                    H=lbu
                    fparm=Au
                    N=gencost
                    mpopt=areas
                    ubu=branch
                    lbu=gen
                    Au=bus
                else:
                    if nargin()==5:
                        zu=m_array()
                        zl=m_array()
                        z0=m_array()
                        Cw=m_array()
                        H=sparse(0,0)
                        fparm=m_array()
                        N=sparse(0,0)
                        mpopt=areas
                        ubu=branch
                        lbu=gen
                        Au=bus
                    else:
                        if nargin()==4:
                            zu=m_array()
                            zl=m_array()
                            z0=m_array()
                            Cw=m_array()
                            H=sparse(0,0)
                            fparm=m_array()
                            N=sparse(0,0)
                            mpopt=mpoption()
                            ubu=branch
                            lbu=gen
                            Au=bus
                        else:
                            if nargin()==3:
                                userfcn=bus
                                zu=m_array()
                                zl=m_array()
                                z0=m_array()
                                Cw=m_array()
                                H=sparse(0,0)
                                fparm=m_array()
                                N=sparse(0,0)
                                mpopt=gen
                                ubu=m_array()
                                lbu=m_array()
                                Au=sparse(0,0)
                            else:
                                if nargin()==2:
                                    zu=m_array()
                                    zl=m_array()
                                    z0=m_array()
                                    Cw=m_array()
                                    H=sparse(0,0)
                                    fparm=m_array()
                                    N=sparse(0,0)
                                    mpopt=bus
                                    ubu=m_array()
                                    lbu=m_array()
                                    Au=sparse(0,0)
                                else:
                                    if nargin()==1:
                                        zu=m_array()
                                        zl=m_array()
                                        z0=m_array()
                                        Cw=m_array()
                                        H=sparse(0,0)
                                        fparm=m_array()
                                        N=sparse(0,0)
                                        mpopt=mpoption()
                                        ubu=m_array()
                                        lbu=m_array()
                                        Au=sparse(0,0)
        else:
            error('opf_args.m: Incorrect input parameter order, number or type')
        mpc=loadcase(casefile)
        baseMVA,bus,gen,branch,gencost=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,mpc.gencost,nargout=5)
        if isfield(mpc,'areas'):
            areas=mpc.areas
        else:
            areas=m_array()
        if isempty(Au) and isfield(mpc,'A'):
            Au,lbu,ubu=deal(mpc.A,mpc.l,mpc.u,nargout=3)
        if isempty(N) and isfield(mpc,'N'):
            N,Cw=deal(mpc.N,mpc.Cw,nargout=2)
        if isempty(H) and isfield(mpc,'H'):
            H=mpc.H
        if isempty(fparm) and isfield(mpc,'fparm'):
            fparm=mpc.fparm
        if isempty(z0) and isfield(mpc,'z0'):
            z0=mpc.z0
        if isempty(zl) and isfield(mpc,'zl'):
            zl=mpc.zl
        if isempty(zu) and isfield(mpc,'zu'):
            zu=mpc.zu
        if isempty(userfcn) and isfield(mpc,'userfcn'):
            userfcn=mpc.userfcn
    else:
        if any(nargin()==m_array([6,7,8,9,10,14,17]).reshape(1,-1)):
            if nargin()==14:
                zu=m_array()
                zl=m_array()
                z0=m_array()
            else:
                if nargin()==10:
                    zu=m_array()
                    zl=m_array()
                    z0=m_array()
                    Cw=m_array()
                    H=sparse(0,0)
                    fparm=m_array()
                    N=sparse(0,0)
                else:
                    if nargin()==9:
                        zu=m_array()
                        zl=m_array()
                        z0=m_array()
                        Cw=m_array()
                        H=sparse(0,0)
                        fparm=m_array()
                        N=sparse(0,0)
                        mpopt=mpoption()
                    else:
                        if nargin()==8:
                            userfcn=Au
                            zu=m_array()
                            zl=m_array()
                            z0=m_array()
                            Cw=m_array()
                            H=sparse(0,0)
                            fparm=m_array()
                            N=sparse(0,0)
                            mpopt=lbu
                            ubu=m_array()
                            lbu=m_array()
                            Au=sparse(0,0)
                        else:
                            if nargin()==7:
                                zu=m_array()
                                zl=m_array()
                                z0=m_array()
                                Cw=m_array()
                                H=sparse(0,0)
                                fparm=m_array()
                                N=sparse(0,0)
                                mpopt=Au
                                ubu=m_array()
                                lbu=m_array()
                                Au=sparse(0,0)
                            else:
                                if nargin()==6:
                                    zu=m_array()
                                    zl=m_array()
                                    z0=m_array()
                                    Cw=m_array()
                                    H=sparse(0,0)
                                    fparm=m_array()
                                    N=sparse(0,0)
                                    mpopt=mpoption()
                                    ubu=m_array()
                                    lbu=m_array()
                                    Au=sparse(0,0)
        else:
            error('opf_args.m: Incorrect input parameter order, number or type')
        if want_mpc:
            mpc=struct('baseMVA',baseMVA,'bus',bus,'gen',gen,'branch',branch,'gencost',gencost)
    nw=size(N,1)
    if nw:
        if size(Cw,1)!=nw:
            error('opf_args.m: dimension mismatch between N and Cw in generalized cost parameters')
        if  not isempty(fparm) and size(fparm,1)!=nw:
            error('opf_args.m: dimension mismatch between N and fparm in generalized cost parameters')
        if  not isempty(H) and (size(H,1)!=nw or size(H,2)!=nw):
            error('opf_args.m: dimension mismatch between N and H in generalized cost parameters')
        if size(Au,1)>0 and size(N,2)!=size(Au,2):
            error('opf_args.m: A and N must have the same number of columns')
        if  not issparse(N):
            error('opf_args.m: N must be sparse in generalized cost parameters')
        if  not issparse(H):
            error('opf_args.m: H must be sparse in generalized cost parameters')
    if  not issparse(Au):
        error('opf_args.m: Au must be sparse')
    if isempty(mpopt):
        mpopt=mpoption()
    if want_mpc:
        if  not isempty(areas):
            mpc.areas=areas
        if  not isempty(Au):
            mpc.A,mpc.l,mpc.u=deal(Au,lbu,ubu,nargout=3)
        if  not isempty(N):
            mpc.N,mpc.Cw=deal(N,Cw,nargout=2)
            if  not isempty(fparm):
                mpc.fparm=fparm
            if  not isempty(H):
                mpc.H=H
        if  not isempty(z0):
            mpc.z0=z0
        if  not isempty(zl):
            mpc.zl=zl
        if  not isempty(zu):
            mpc.zu=zu
        if  not isempty(userfcn):
            mpc.userfcn=userfcn
        baseMVA=mpc
        bus=mpopt
    return baseMVA,bus,gen,branch,gencost,Au,lbu,ubu,mpopt,N,fparm,H,Cw,z0,zl,zu,userfcn,areas
def opf_consfcn(x,om,Ybus,Yf,Yt,mpopt,il,varargin,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,nargout=4)
    vv=get_idx(om)
    nb=size(bus,1)
    nl=size(branch,1)
    ng=size(gen,1)
    nxyz=length(x)
    if nargin()<7:
        il=(arange(1,nl+1).reshape(1,-1))
    nl2=length(il)
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    Sbus=makeSbus(baseMVA,bus,gen)
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    V=Vm*exp(1j*Va)
    mis=V*conj(Ybus*V)-Sbus
    g=m_array([[real(mis)],[imag(mis)]]).reshape(1,-1)
    if nl2>0:
        flow_max=(branch[il-1,RATE_A-1]/baseMVA)**2
        flow_max[int(flow_max==0)]=Inf()
        if mpopt[int(24-1)]==2:
            If=Yf*V
            It=Yt*V
            h=m_array([[If*conj(If)-flow_max],[It*conj(It)-flow_max]]).reshape(1,-1)
        else:
            Sf=V[int(branch[il-1,F_BUS-1]-1)]*conj(Yf*V)
            St=V[int(branch[il-1,T_BUS-1]-1)]*conj(Yt*V)
            if mpopt[int(24-1)]==1:
                h=m_array([[real(Sf)**2-flow_max],[real(St)**2-flow_max]]).reshape(1,-1)
            else:
                h=m_array([[Sf*conj(Sf)-flow_max],[St*conj(St)-flow_max]]).reshape(1,-1)
    else:
        h=zeros(0,1)
    if nargout()>2:
        iVa=arange(vv.i1.Va,vv.iN.Va+1).reshape(1,-1)
        iVm=arange(vv.i1.Vm,vv.iN.Vm+1).reshape(1,-1)
        iPg=arange(vv.i1.Pg,vv.iN.Pg+1).reshape(1,-1)
        iQg=arange(vv.i1.Qg,vv.iN.Qg+1).reshape(1,-1)
        dSbus_dVm,dSbus_dVa=dSbus_dV(Ybus,V,nargout=2)
        neg_Cg=sparse(gen[:,GEN_BUS-1],arange(1,ng+1).reshape(1,-1),-1,nb,ng)
        dg=sparse(2*nb,nxyz)
        dg[:,m_array([iVa,iVm,iPg,iQg]).reshape(1,-1)-1]=m_array([[real(m_array([dSbus_dVa,dSbus_dVm]).reshape(1,-1)),neg_Cg,sparse(nb,ng)],[imag(m_array([dSbus_dVa,dSbus_dVm]).reshape(1,-1)),sparse(nb,ng),neg_Cg]]).reshape(1,-1)
        dg=dg.T
        if nl2>0:
            if mpopt[int(24-1)]==2:
                dFf_dVa,dFf_dVm,dFt_dVa,dFt_dVm,Ff,Ft=dIbr_dV(branch[il-1,:],Yf,Yt,V,nargout=6)
            else:
                dFf_dVa,dFf_dVm,dFt_dVa,dFt_dVm,Ff,Ft=dSbr_dV(branch[il-1,:],Yf,Yt,V,nargout=6)
            if mpopt[int(24-1)]==1:
                dFf_dVa=real(dFf_dVa)
                dFf_dVm=real(dFf_dVm)
                dFt_dVa=real(dFt_dVa)
                dFt_dVm=real(dFt_dVm)
                Ff=real(Ff)
                Ft=real(Ft)
            df_dVa,df_dVm,dt_dVa,dt_dVm=dAbr_dV(dFf_dVa,dFf_dVm,dFt_dVa,dFt_dVm,Ff,Ft,nargout=4)
            dh=sparse(2*nl2,nxyz)
            dh[:,m_array([iVa,iVm]).reshape(1,-1)-1]=m_array([[df_dVa,df_dVm],[dt_dVa,dt_dVm]]).reshape(1,-1)
            dh=dh.T
        else:
            dh=sparse(nxyz,0)
        if mpopt[int(51-1)]==0:
            dg=full(dg)
            dh=full(dh)
    return h,g,dh,dg
def opf_costfcn(x,om,varargin,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    mpc=get_mpc(om)
    baseMVA,gen,gencost=deal(mpc.baseMVA,mpc.gen,mpc.gencost,nargout=3)
    cp=get_cost_params(om)
    N,Cw,H,dd,rh,kk,mm=deal(cp.N,cp.Cw,cp.H,cp.dd,cp.rh,cp.kk,cp.mm,nargout=7)
    vv=get_idx(om)
    ng=size(gen,1)
    ny=getN(om,'var','y')
    nxyz=length(x)
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    ipol=find(gencost[:,MODEL-1]==POLYNOMIAL)
    xx=m_array([[Pg],[Qg]]).reshape(1,-1)*baseMVA
    if  not isempty(ipol):
        f=sum(totcost(gencost[ipol-1,:],xx[int(ipol-1)]))
    else:
        f=0
    if ny>0:
        ccost=full(sparse(ones(1,ny),arange(vv.i1.y,vv.iN.y+1).reshape(1,-1),ones(1,ny),1,nxyz))
        f=f+ccost*x
    else:
        ccost=zeros(1,nxyz)
    if  not isempty(N):
        nw=size(N,1)
        r=N*x-rh
        iLT=find(r<-kk)
        iEQ=find(r==0&kk==0)
        iGT=find(r>kk)
        iND=m_array([[iLT],[iEQ],[iGT]]).reshape(1,-1)
        iL=find(dd==1)
        iQ=find(dd==2)
        LL=sparse(iL,iL,1,nw,nw)
        QQ=sparse(iQ,iQ,1,nw,nw)
        kbar=sparse(iND,iND,m_array([[ones(length(iLT),1)],[zeros(length(iEQ),1)],[-ones(length(iGT),1)]]).reshape(1,-1),nw,nw)*kk
        rr=r+kbar
        M=sparse(iND,iND,mm[int(iND-1)],nw,nw)
        diagrr=sparse(arange(1,nw+1).reshape(1,-1),arange(1,nw+1).reshape(1,-1),rr,nw,nw)
        w=M*(LL+QQ*diagrr)*rr
        f=f+(w.T*H*w)/2+Cw.T*w
    if nargout()>1:
        iPg=arange(vv.i1.Pg,vv.iN.Pg+1).reshape(1,-1)
        iQg=arange(vv.i1.Qg,vv.iN.Qg+1).reshape(1,-1)
        df_dPgQg=zeros(2*ng,1)
        df_dPgQg[int(ipol-1)]=baseMVA*polycost(gencost[ipol-1,:],xx[int(ipol-1)],1)
        df=zeros(nxyz,1)
        df[int(iPg-1)]=df_dPgQg[1-1:ng+1-1]
        df[int(iQg-1)]=df_dPgQg[int((arange(1,ng+1).reshape(1,-1))+ng-1)]
        df=df+ccost.T
        if  not isempty(N):
            HwC=H*w+Cw
            AA=N.T*M*(LL+2*QQ*diagrr)
            df=df+AA*HwC
            if 0:
                ddff=zeros(size(df))
                step=1e-07
                tol=0.001
                for k in arange(1,length(x)+1).reshape(1,-1).flat:
                    xx=_copy(x)
                    xx[int(k-1)]=xx[int(k-1)]+step
                    ddff[int(k-1)]=(opf_costfcn(xx,om)-f)/step
                if max(abs(ddff-df))>tol:
                    idx=find(abs(ddff-df)==max(abs(ddff-df)))
                    fprintf('\\nMismatch in gradient\\n')
                    fprintf('idx             df(num)         df              diff\\n')
                    fprintf('%4d%16g%16g%16g\\n',m_array([[arange(1,length(df)+1).reshape(1,-1)],[ddff.T],[df.T],[abs(ddff-df).T]]).reshape(1,-1))
                    fprintf('MAX\\n')
                    fprintf('%4d%16g%16g%16g\\n',m_array([[idx.T],[ddff[int(idx-1)].T],[df[int(idx-1)].T],[abs(ddff[int(idx-1)]-df[int(idx-1)]).T]]).reshape(1,-1))
                    fprintf('\\n')
        if nargout()>2:
            pcost=gencost[1-1:ng+1-1,:]
            if size(gencost,1)>ng:
                qcost=gencost[ng+1-1:2*ng+1-1,:]
            else:
                qcost=m_array()
            d2f_dPg2=sparse(ng,1)
            d2f_dQg2=sparse(ng,1)
            ipolp=find(pcost[:,MODEL-1]==POLYNOMIAL)
            d2f_dPg2[int(ipolp-1)]=baseMVA**2*polycost(pcost[ipolp-1,:],Pg[int(ipolp-1)]*baseMVA,2)
            if  not isempty(qcost):
                ipolq=find(qcost[:,MODEL-1]==POLYNOMIAL)
                d2f_dQg2[int(ipolq-1)]=baseMVA**2*polycost(qcost[ipolq-1,:],Qg[int(ipolq-1)]*baseMVA,2)
            i=m_array([iPg,iQg]).reshape(1,-1).T
            d2f=sparse(i,i,m_array([[d2f_dPg2],[d2f_dQg2]]).reshape(1,-1),nxyz,nxyz)
            if  not isempty(N):
                d2f=d2f+AA*H*AA.T+2*N.T*M*QQ*sparse(arange(1,nw+1).reshape(1,-1),arange(1,nw+1).reshape(1,-1),HwC,nw,nw)*N
    return f,df,d2f
def opf_execute(om,mpopt,**kwargs):
    mpopt=_copy(mpopt)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    dc=mpopt[int(10-1)]
    alg=mpopt[int(11-1)]
    verbose=mpopt[int(31-1)]
    om=build_cost_params(om)
    vv,ll,nn=get_idx(om,nargout=3)
    if verbose>0:
        v=mpver('all')
        fprintf('\\nMATPOWER Version %s, %s',v.Version,v.Date)
    if dc:
        if verbose>0:
            fprintf(' -- DC Optimal Power Flow\\n')
        results,success,raw=dcopf_solver(om,mpopt,nargout=3)
    else:
        if verbose>0:
            fprintf(' -- AC Optimal Power Flow\\n')
        if alg==0:
            if have_fcn('pdipmopf'):
                alg=540
            else:
                alg=560
        if alg==100 or alg==200:
            alg=300
        else:
            if alg==120 or alg==220:
                alg=320
            else:
                if alg==140 or alg==240:
                    alg=340
                else:
                    if alg==160 or alg==260:
                        alg=360
        mpopt[int(11-1)]=alg
        if alg==560 or alg==565:
            if have_fcn('anon_fcns'):
                solver=mipsopf_solver()
            else:
                solver=mips6opf_solver()
            results,success,raw=feval(solver,om,mpopt,nargout=3)
        else:
            if alg==580:
                if  not have_fcn('ipopt'):
                    error('opf_execute: OPF_ALG %d requires IPOPT (see https://projects.coin-or.org/Ipopt/)',alg)
                results,success,raw=ipoptopf_solver(om,mpopt,nargout=3)
            else:
                if alg==540 or alg==545 or alg==550:
                    if alg==540:
                        if  not have_fcn('pdipmopf'):
                            error('opf_execute: OPF_ALG %d requires PDIPMOPF (see http://www.pserc.cornell.edu/tspopf/)',alg)
                    else:
                        if alg==545:
                            if  not have_fcn('scpdipmopf'):
                                error('opf_execute: OPF_ALG %d requires SCPDIPMOPF (see http://www.pserc.cornell.edu/tspopf/)',alg)
                        else:
                            if alg==550:
                                if  not have_fcn('tralmopf'):
                                    error('opf_execute: OPF_ALG %d requires TRALM (see http://www.pserc.cornell.edu/tspopf/)',alg)
                    results,success,raw=tspopf_solver(om,mpopt,nargout=3)
                else:
                    if alg==500:
                        if  not have_fcn('minopf'):
                            error('opf_execute: OPF_ALG %d requires MINOPF (see http://www.pserc.cornell.edu/minopf/)',alg)
                        results,success,raw=mopf_solver(om,mpopt,nargout=3)
                    else:
                        if alg==520:
                            if  not have_fcn('fmincon'):
                                error('opf_execute: OPF_ALG %d requires FMINCON (Optimization Toolbox 2.x or later)',alg)
                            if have_fcn('anon_fcns'):
                                solver=fmincopf_solver()
                            else:
                                solver=fmincopf6_solver()
                            results,success,raw=feval(solver,om,mpopt,nargout=3)
                        else:
                            if alg==600:
                                if  not have_fcn('knitro'):
                                    error('opf_execute: OPF_ALG %d requires KNITRO (see http://www.ziena.com/)',alg)
                                results,success,raw=ktropf_solver(om,mpopt,nargout=3)
                            else:
                                if alg==300:
                                    if  not have_fcn('constr'):
                                        error('opf_execute: OPF_ALG %d requires CONSTR (Optimization Toolbox 1.x)',alg)
                                    results,success,raw=copf_solver(om,mpopt,nargout=3)
                                else:
                                    if alg==320 or alg==340 or alg==360:
                                        results,success,raw=lpopf_solver(om,mpopt,nargout=3)
                                    else:
                                        error('opf_execute: OPF_ALG %d is not a valid algorithm code',alg)
    if  not isfield(raw,'output') or  not isfield(raw.output,'alg') or isempty(raw.output.alg):
        raw.output.alg=alg
    if success:
        if  not dc:
            results.gen[:,VG-1]=results.bus[results.gen[:,GEN_BUS-1]-1,VM-1]
            if ll.N.PQh>0 or ll.N.PQl>0:
                mu_PQh=results.mu.lin.l[ll.i1.PQh-1:ll.iN.PQh+1-1]-results.mu.lin.u[ll.i1.PQh-1:ll.iN.PQh+1-1]
                mu_PQl=results.mu.lin.l[ll.i1.PQl-1:ll.iN.PQl+1-1]-results.mu.lin.u[ll.i1.PQl-1:ll.iN.PQl+1-1]
                Apqdata=userdata(om,'Apqdata')
                results.gen=update_mupq(results.baseMVA,results.gen,mu_PQh,mu_PQl,Apqdata)
            if mpopt[int(52-1)]:
                if isfield(results,'dg'):
                    raw.dg=results.dg
                    raw.g=results.g
                if  not isfield(raw,'dg'):
                    mpc=get_mpc(om)
                    Ybus,Yf,Yt=makeYbus(mpc.baseMVA,mpc.bus,mpc.branch,nargout=3)
                    g,geq,dg,dgeq=opf_consfcn(results.x,om,Ybus,Yf,Yt,mpopt,nargout=4)
                    raw.g=m_array([[geq],[g]]).reshape(1,-1)
                    raw.dg=m_array([[dgeq.T],[dg.T]]).reshape(1,-1)
                f,df,d2f=opf_costfcn(results.x,om,nargout=3)
                raw.df=df
                raw.d2f=d2f
        if isfield(results,'dg'):
            rmfield(results,'dg')
            rmfield(results,'g')
        if ll.N.ang>0:
            iang=userdata(om,'iang')
            results.branch[iang-1,MU_ANGMIN-1]=results.mu.lin.l[ll.i1.ang-1:ll.iN.ang+1-1]*pi()/180
            results.branch[iang-1,MU_ANGMAX-1]=results.mu.lin.u[ll.i1.ang-1:ll.iN.ang+1-1]*pi()/180
    else:
        if  not dc and mpopt[int(52-1)]:
            raw.dg=m_array()
            raw.g=m_array()
            raw.df=m_array()
            raw.d2f=m_array()
    om_var_order=get(om,'var','order')
    for k in arange(1,length(om_var_order)+1).reshape(1,-1).flat:
        name=om_var_order[k-1]
        if getN(om,'var',name):
            idx=arange(getfield(vv.i1,name),getfield(vv.iN,name)+1).reshape(1,-1)
            setfield(results.var.val,name,results.x[int(idx-1)])
            setfield(results.var.mu.l,name,results.mu.var.l[int(idx-1)])
            setfield(results.var.mu.u,name,results.mu.var.u[int(idx-1)])
    om_lin_order=get(om,'lin','order')
    for k in arange(1,length(om_lin_order)+1).reshape(1,-1).flat:
        name=om_lin_order[k-1]
        if getN(om,'lin',name):
            idx=arange(getfield(ll.i1,name),getfield(ll.iN,name)+1).reshape(1,-1)
            setfield(results.lin.mu.l,name,results.mu.lin.l[int(idx-1)])
            setfield(results.lin.mu.u,name,results.mu.lin.u[int(idx-1)])
    if  not dc:
        om_nln_order=get(om,'nln','order')
        for k in arange(1,length(om_nln_order)+1).reshape(1,-1).flat:
            name=om_nln_order[k-1]
            if getN(om,'nln',name):
                idx=arange(getfield(nn.i1,name),getfield(nn.iN,name)+1).reshape(1,-1)
                setfield(results.nln.mu.l,name,results.mu.nln.l[int(idx-1)])
                setfield(results.nln.mu.u,name,results.mu.nln.u[int(idx-1)])
    om_cost_order=get(om,'cost','order')
    for k in arange(1,length(om_cost_order)+1).reshape(1,-1).flat:
        name=om_cost_order[k-1]
        if getN(om,'cost',name):
            setfield(results.cost,name,compute_cost(om,results.x,name))
    pwl1=userdata(om,'pwl1')
    if  not isempty(pwl1) and alg!=545 and alg!=550:
        vv=get_idx(om)
        if dc:
            nx=vv.iN.Pg
        else:
            nx=vv.iN.Qg
        y=zeros(length(pwl1),1)
        raw.xr=m_array([[raw.xr[1-1:nx+1-1]],[y],[raw.xr[nx+1-1:raw.xr.shape[0]+1-1]]]).reshape(1,-1)
        results.x=m_array([[results.x[1-1:nx+1-1]],[y],[results.x[nx+1-1:results.x.shape[0]+1-1]]]).reshape(1,-1)
    return results,success,raw
def opf_hessfcn(x,lambda_,cost_mult,om,Ybus,Yf,Yt,mpopt,il,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    if isempty(cost_mult):
        cost_mult=1
    mpc=get_mpc(om)
    baseMVA,bus,gen,branch,gencost=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,mpc.gencost,nargout=5)
    cp=get_cost_params(om)
    N,Cw,H,dd,rh,kk,mm=deal(cp.N,cp.Cw,cp.H,cp.dd,cp.rh,cp.kk,cp.mm,nargout=7)
    vv=get_idx(om)
    nb=size(bus,1)
    nl=size(branch,1)
    ng=size(gen,1)
    nxyz=length(x)
    if nargin()<8:
        il=(arange(1,nl+1).reshape(1,-1))
    nl2=length(il)
    Pg=x[vv.i1.Pg-1:vv.iN.Pg+1-1]
    Qg=x[vv.i1.Qg-1:vv.iN.Qg+1-1]
    gen[:,PG-1]=Pg*baseMVA
    gen[:,QG-1]=Qg*baseMVA
    Va=zeros(nb,1)
    Va=x[vv.i1.Va-1:vv.iN.Va+1-1]
    Vm=x[vv.i1.Vm-1:vv.iN.Vm+1-1]
    V=Vm*exp(1j*Va)
    nxtra=nxyz-2*nb
    pcost=gencost[1-1:ng+1-1,:]
    if size(gencost,1)>ng:
        qcost=gencost[ng+1-1:2*ng+1-1,:]
    else:
        qcost=m_array()
    d2f_dPg2=sparse(ng,1)
    d2f_dQg2=sparse(ng,1)
    ipolp=find(pcost[:,MODEL-1]==POLYNOMIAL)
    d2f_dPg2[int(ipolp-1)]=baseMVA**2*polycost(pcost[ipolp-1,:],Pg[int(ipolp-1)]*baseMVA,2)
    if  not isempty(qcost):
        ipolq=find(qcost[:,MODEL-1]==POLYNOMIAL)
        d2f_dQg2[int(ipolq-1)]=baseMVA**2*polycost(qcost[ipolq-1,:],Qg[int(ipolq-1)]*baseMVA,2)
    i=m_array([arange(vv.i1.Pg,vv.iN.Pg+1).reshape(1,-1),arange(vv.i1.Qg,vv.iN.Qg+1).reshape(1,-1)]).reshape(1,-1).T
    d2f=sparse(i,i,m_array([[d2f_dPg2],[d2f_dQg2]]).reshape(1,-1),nxyz,nxyz)
    if  not isempty(N):
        nw=size(N,1)
        r=N*x-rh
        iLT=find(r<-kk)
        iEQ=find(r==0&kk==0)
        iGT=find(r>kk)
        iND=m_array([[iLT],[iEQ],[iGT]]).reshape(1,-1)
        iL=find(dd==1)
        iQ=find(dd==2)
        LL=sparse(iL,iL,1,nw,nw)
        QQ=sparse(iQ,iQ,1,nw,nw)
        kbar=sparse(iND,iND,m_array([[ones(length(iLT),1)],[zeros(length(iEQ),1)],[-ones(length(iGT),1)]]).reshape(1,-1),nw,nw)*kk
        rr=r+kbar
        M=sparse(iND,iND,mm[int(iND-1)],nw,nw)
        diagrr=sparse(arange(1,nw+1).reshape(1,-1),arange(1,nw+1).reshape(1,-1),rr,nw,nw)
        w=M*(LL+QQ*diagrr)*rr
        HwC=H*w+Cw
        AA=N.T*M*(LL+2*QQ*diagrr)
        d2f=d2f+AA*H*AA.T+2*N.T*M*QQ*sparse(arange(1,nw+1).reshape(1,-1),arange(1,nw+1).reshape(1,-1),HwC,nw,nw)*N
    d2f=d2f*cost_mult
    nlam=length(lambda_.eqnonlin)/2
    lamP=lambda_.eqnonlin[1-1:nlam+1-1]
    lamQ=lambda_.eqnonlin[int((arange(1,nlam+1).reshape(1,-1))+nlam-1)]
    Gpaa,Gpav,Gpva,Gpvv=d2Sbus_dV2(Ybus,V,lamP,nargout=4)
    Gqaa,Gqav,Gqva,Gqvv=d2Sbus_dV2(Ybus,V,lamQ,nargout=4)
    d2G=m_array([[real(m_array([[Gpaa,Gpav],[Gpva,Gpvv]]).reshape(1,-1))+imag(m_array([[Gqaa,Gqav],[Gqva,Gqvv]]).reshape(1,-1)),sparse(2*nb,nxtra)],[sparse(nxtra,2*nb+nxtra)]]).reshape(1,-1)
    nmu=length(lambda_.ineqnonlin)/2
    muF=lambda_.ineqnonlin[1-1:nmu+1-1]
    muT=lambda_.ineqnonlin[int((arange(1,nmu+1).reshape(1,-1))+nmu-1)]
    if mpopt[int(24-1)]==2:
        dIf_dVa,dIf_dVm,dIt_dVa,dIt_dVm,If,It=dIbr_dV(branch[il-1,:],Yf,Yt,V,nargout=6)
        Hfaa,Hfav,Hfva,Hfvv=d2AIbr_dV2(dIf_dVa,dIf_dVm,If,Yf,V,muF,nargout=4)
        Htaa,Htav,Htva,Htvv=d2AIbr_dV2(dIt_dVa,dIt_dVm,It,Yt,V,muT,nargout=4)
    else:
        f=branch[il-1,F_BUS-1]
        t=branch[il-1,T_BUS-1]
        Cf=sparse(arange(1,nl2+1).reshape(1,-1),f,ones(nl2,1),nl2,nb)
        Ct=sparse(arange(1,nl2+1).reshape(1,-1),t,ones(nl2,1),nl2,nb)
        dSf_dVa,dSf_dVm,dSt_dVa,dSt_dVm,Sf,St=dSbr_dV(branch[il-1,:],Yf,Yt,V,nargout=6)
        if mpopt[int(24-1)]==1:
            Hfaa,Hfav,Hfva,Hfvv=d2ASbr_dV2(real(dSf_dVa),real(dSf_dVm),real(Sf),Cf,Yf,V,muF,nargout=4)
            Htaa,Htav,Htva,Htvv=d2ASbr_dV2(real(dSt_dVa),real(dSt_dVm),real(St),Ct,Yt,V,muT,nargout=4)
        else:
            Hfaa,Hfav,Hfva,Hfvv=d2ASbr_dV2(dSf_dVa,dSf_dVm,Sf,Cf,Yf,V,muF,nargout=4)
            Htaa,Htav,Htva,Htvv=d2ASbr_dV2(dSt_dVa,dSt_dVm,St,Ct,Yt,V,muT,nargout=4)
    d2H=m_array([[m_array([[Hfaa,Hfav],[Hfva,Hfvv]]).reshape(1,-1)+m_array([[Htaa,Htav],[Htva,Htvv]]).reshape(1,-1),sparse(2*nb,nxtra)],[sparse(nxtra,2*nb+nxtra)]]).reshape(1,-1)
    if 0:
        nx=length(x)
        step=1e-05
        num_d2f=sparse(nx,nx)
        num_d2G=sparse(nx,nx)
        num_d2H=sparse(nx,nx)
        for i in arange(1,nx+1).reshape(1,-1).flat:
            xp=_copy(x)
            xm=_copy(x)
            xp[int(i-1)]=x[int(i-1)]+step/2
            xm[int(i-1)]=x[int(i-1)]-step/2
            fp,dfp=opf_costfcn(xp,om,nargout=2)
            fm,dfm=opf_costfcn(xm,om,nargout=2)
            Hp,Gp,dHp,dGp=opf_consfcn(xp,om,Ybus,Yf,Yt,mpopt,il,nargout=4)
            Hm,Gm,dHm,dGm=opf_consfcn(xm,om,Ybus,Yf,Yt,mpopt,il,nargout=4)
            num_d2f[:,i-1]=cost_mult*(dfp-dfm)/step
            num_d2G[:,i-1]=(dGp-dGm)*lambda_.eqnonlin/step
            num_d2H[:,i-1]=(dHp-dHm)*lambda_.ineqnonlin/step
        d2f_err=full(max(max(abs(d2f-num_d2f))))
        d2G_err=full(max(max(abs(d2G-num_d2G))))
        d2H_err=full(max(max(abs(d2H-num_d2H))))
        if d2f_err>1e-06:
            fprintf('Max difference in d2f: %g\\n',d2f_err)
        if d2G_err>1e-05:
            fprintf('Max difference in d2G: %g\\n',d2G_err)
        if d2H_err>1e-06:
            fprintf('Max difference in d2H: %g\\n',d2H_err)
    Lxx=d2f+d2G+d2H
    return Lxx
def opf(varargin,**kwargs):
    t0=clock()
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    mpc,mpopt=opf_args(varargin[:],nargout=2)
    nb=size(mpc.bus,1)
    nl=size(mpc.branch,1)
    ng=size(mpc.gen,1)
    if size(mpc.bus,2)<MU_VMIN:
        mpc.bus=m_array([mpc.bus,zeros(nb,MU_VMIN-size(mpc.bus,2))]).reshape(1,-1)
    if size(mpc.gen,2)<MU_QMIN:
        mpc.gen=m_array([mpc.gen,zeros(ng,MU_QMIN-size(mpc.gen,2))]).reshape(1,-1)
    if size(mpc.branch,2)<MU_ANGMAX:
        mpc.branch=m_array([mpc.branch,zeros(nl,MU_ANGMAX-size(mpc.branch,2))]).reshape(1,-1)
    mpc=ext2int(mpc)
    om=opf_setup(mpc,mpopt)
    if nargout()>7:
        mpopt[int(52-1)]=1
    results,success,raw=opf_execute(om,mpopt,nargout=3)
    results=int2ext(results)
    if  not isempty(results.order.gen.status.off):
        results.gen[results.order.gen.status.off-1,m_array([PG,QG,MU_PMAX,MU_PMIN]).reshape(1,-1)-1]=0
    if  not isempty(results.order.branch.status.off):
        results.branch[results.order.branch.status.off-1,m_array([PF,QF,PT,QT,MU_SF,MU_ST,MU_ANGMIN,MU_ANGMAX]).reshape(1,-1)-1]=0
    et=etime(clock(),t0)
    if nargout()>0:
        if nargout()<=2:
            results.et=et
            results.success=success
            results.raw=raw
            busout=results
            genout=success
        else:
            busout,genout,branchout,f,info,xr,pimul=deal(results.bus,results.gen,results.branch,results.f,raw.info,raw.xr,raw.pimul,nargout=7)
            if isfield(results,'g'):
                g=results.g
            if isfield(results,'dg'):
                jac=results.dg
    else:
        if success:
            results.et=et
            results.success=success
            printpf(results,1,mpopt)
    return busout,genout,branchout,f,success,info,et,g,jac,xr,pimul
def pfsoln(baseMVA,bus0,gen0,branch0,Ybus,Yf,Yt,V,ref,pv,pq,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    bus=_copy(bus0)
    gen=_copy(gen0)
    branch=_copy(branch0)
    bus[:,VM-1]=abs(V)
    bus[:,VA-1]=angle(V)*180/pi()
    on=find(gen[:,GEN_STATUS-1]>0)
    gbus=gen[on-1,GEN_BUS-1]
    Sbus=V[int(gbus-1)]*conj(Ybus[gbus-1,:]*V)
    gen[:,QG-1]=zeros(size(gen,1),1)
    gen[on-1,QG-1]=imag(Sbus)*baseMVA+bus[gbus-1,QD-1]
    if length(on)>1:
        nb=size(bus,1)
        ngon=size(on,1)
        Cg=sparse((arange(1,ngon+1).reshape(1,-1)).T,gbus,ones(ngon,1),ngon,nb)
        ngg=Cg*sum(Cg).T
        gen[on-1,QG-1]=gen[on-1,QG-1]/ngg
        Cmin=sparse((arange(1,ngon+1).reshape(1,-1)).T,gbus,gen[on-1,QMIN-1],ngon,nb)
        Cmax=sparse((arange(1,ngon+1).reshape(1,-1)).T,gbus,gen[on-1,QMAX-1],ngon,nb)
        Qg_tot=Cg.T*gen[on-1,QG-1]
        Qg_min=sum(Cmin).T
        Qg_max=sum(Cmax).T
        ig=find(Cg*Qg_min==Cg*Qg_max)
        Qg_save=gen[on[int(ig-1)]-1,QG-1]
        gen[on-1,QG-1]=gen[on-1,QMIN-1]+(Cg*((Qg_tot-Qg_min)/(Qg_max-Qg_min+eps())))*(gen[on-1,QMAX-1]-gen[on-1,QMIN-1])
        gen[on[int(ig-1)]-1,QG-1]=Qg_save
    for k in arange(1,length(ref)+1).reshape(1,-1).flat:
        refgen=find(gbus==ref[int(k-1)])
        gen[on[int(refgen[int(1-1)]-1)]-1,PG-1]=real(Sbus[int(refgen[int(1-1)]-1)])*baseMVA+bus[ref[int(k-1)]-1,PD-1]
        if length(refgen)>1:
            gen[on[int(refgen[int(1-1)]-1)]-1,PG-1]=gen[on[int(refgen[int(1-1)]-1)]-1,PG-1]-sum(gen[on[int(refgen[2-1:length(refgen)+1-1]-1)]-1,PG-1])
    out=find(branch[:,BR_STATUS-1]==0)
    br=find(branch[:,BR_STATUS-1])
    Sf=V[int(branch[br-1,F_BUS-1]-1)]*conj(Yf[br-1,:]*V)*baseMVA
    St=V[int(branch[br-1,T_BUS-1]-1)]*conj(Yt[br-1,:]*V)*baseMVA
    branch[br-1,m_array([PF,QF,PT,QT]).reshape(1,-1)-1]=m_array([real(Sf),imag(Sf),real(St),imag(St)]).reshape(1,-1)
    branch[out-1,m_array([PF,QF,PT,QT]).reshape(1,-1)-1]=zeros(length(out),4)
    return bus,gen,branch
def poly2pwl(polycost,Pmin,Pmax,npts,**kwargs):
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    pwlcost=_copy(polycost)
    m,n=size(polycost,nargout=2)
    pwlcost[:,MODEL-1]=PW_LINEAR*ones(m,1)
    pwlcost[:,COST-1:n+1-1]=zeros(size(pwlcost[:,COST-1:n+1-1]))
    pwlcost[:,NCOST-1]=npts*ones(m,1)
    for i in arange(1,m+1).reshape(1,-1).flat:
        if Pmin[int(i-1)]==0:
            step=(Pmax[int(i-1)]-Pmin[int(i-1)])/(npts-1)
            xx=(arange(Pmin[int(i-1)],Pmax[int(i-1)]+1,step).reshape(1,-1))
        else:
            if Pmin[int(i-1)]>0:
                step=(Pmax[int(i-1)]-Pmin[int(i-1)])/(npts-2)
                xx=m_array([0,arange(Pmin[int(i-1)],Pmax[int(i-1)]+1,step).reshape(1,-1)]).reshape(1,-1)
            else:
                if Pmin[int(i-1)]<0 and Pmax[int(i-1)]>0:
                    step=(Pmax[int(i-1)]-Pmin[int(i-1)])/(npts-1)
                    xx=(arange(Pmin[int(i-1)],Pmax[int(i-1)]+1,step).reshape(1,-1))
        yy=totcost(polycost[i-1,:],xx)
        pwlcost[i-1,COST-1:2:(COST+2*(npts-1))+1-1]=xx
        pwlcost[i-1,(COST+1)-1:2:(COST+2*(npts-1)+1)+1-1]=yy
    return pwlcost
def polycost(gencost,Pg,der,**kwargs):
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    if nargin()<3:
        der=0
    if any(gencost[:,MODEL-1]==PW_LINEAR):
        error('polycost: all costs must be polynomial')
    ng=length(Pg)
    maxN=max(gencost[:,NCOST-1])
    minN=min(gencost[:,NCOST-1])
    c=zeros(ng,maxN)
    for n in arange(minN,maxN+1).reshape(1,-1).flat:
        k=find(gencost[:,NCOST-1]==n)
        c[k-1,1-1:n+1-1]=gencost[k-1,(COST+n-1)-1:-1:COST+1-1]
    for d in arange(1,der+1).reshape(1,-1).flat:
        if size(c,2)>=2:
            c=c[:,2-1:maxN-d+1+1-1]
        else:
            c=zeros(ng,1)
            break
        for k in arange(2,maxN-d+1).reshape(1,-1).flat:
            c[:,k-1]=k*c[:,k-1]
    if isempty(c):
        f=zeros(size(Pg))
    else:
        f=c[:,1-1]
        for k in arange(2,size(c,2)+1).reshape(1,-1).flat:
            f=f+c[:,k-1]*Pg**(k-1)
    return f
def pqcost(gencost,ng,on,**kwargs):
    if nargin()<3:
        on=(arange(1,ng+1).reshape(1,-1)).T
    if size(gencost,1)==ng:
        pcost=gencost[on-1,:]
        qcost=m_array()
    else:
        if size(gencost,1)==2*ng:
            pcost=gencost[on-1,:]
            qcost=gencost[on+ng-1,:]
        else:
            error('pqcost: gencost has wrong number of rows')
    return pcost,qcost
def printpf(baseMVA,bus,gen,branch,f,success,et,fd,mpopt,**kwargs):
    bus=_copy(bus)
    gen=_copy(gen)
    branch=_copy(branch)
    if isstruct(baseMVA):
        have_results_struct=1
        results=baseMVA
        if nargin()<3 or isempty(gen):
            mpopt=mpoption()
        else:
            mpopt=gen
        if mpopt[int(32-1)]==0:
            return 
        if nargin()<2 or isempty(bus):
            fd=1
        else:
            fd=bus
        baseMVA,bus,gen,branch,success,et=deal(results.baseMVA,results.bus,results.gen,results.branch,results.success,results.et,nargout=6)
        if isfield(results,'f') and  not isempty(results.f):
            f=results.f
        else:
            f=m_array()
    else:
        have_results_struct=0
        if nargin()<9:
            mpopt=mpoption()
            if nargin()<8:
                fd=1
        if mpopt[int(32-1)]==0:
            return 
    isOPF= not isempty(f)
    isDC=mpopt[int(10-1)]
    OUT_ALL=mpopt[int(32-1)]
    OUT_ANY=OUT_ALL==1
    OUT_SYS_SUM=OUT_ALL==1 or (OUT_ALL==-1 and mpopt[int(33-1)])
    OUT_AREA_SUM=OUT_ALL==1 or (OUT_ALL==-1 and mpopt[int(34-1)])
    OUT_BUS=OUT_ALL==1 or (OUT_ALL==-1 and mpopt[int(35-1)])
    OUT_BRANCH=OUT_ALL==1 or (OUT_ALL==-1 and mpopt[int(36-1)])
    OUT_GEN=OUT_ALL==1 or (OUT_ALL==-1 and mpopt[int(37-1)])
    OUT_ANY=OUT_ANY or (OUT_ALL==-1 and (OUT_SYS_SUM or OUT_AREA_SUM or OUT_BUS or OUT_BRANCH or OUT_GEN))
    if OUT_ALL==-1:
        OUT_ALL_LIM=mpopt[int(38-1)]
    else:
        if OUT_ALL==1:
            OUT_ALL_LIM=2
        else:
            OUT_ALL_LIM=0
    OUT_ANY=OUT_ANY or OUT_ALL_LIM>=1
    if OUT_ALL_LIM==-1:
        OUT_V_LIM=mpopt[int(39-1)]
        OUT_LINE_LIM=mpopt[int(40-1)]
        OUT_PG_LIM=mpopt[int(41-1)]
        OUT_QG_LIM=mpopt[int(42-1)]
    else:
        OUT_V_LIM=OUT_ALL_LIM
        OUT_LINE_LIM=OUT_ALL_LIM
        OUT_PG_LIM=OUT_ALL_LIM
        OUT_QG_LIM=OUT_ALL_LIM
    OUT_ANY=OUT_ANY or (OUT_ALL_LIM==-1 and (OUT_V_LIM or OUT_LINE_LIM or OUT_PG_LIM or OUT_QG_LIM))
    ptol=0.0001
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    i2e=bus[:,BUS_I-1]
    e2i=sparse(max(i2e),1)
    e2i[int(i2e-1)]=(arange(1,size(bus,1)+1).reshape(1,-1)).T
    nb=size(bus,1)
    nl=size(branch,1)
    ng=size(gen,1)
    if isDC:
        bus[:,m_array([QD,BS]).reshape(1,-1)-1]=zeros(nb,2)
        gen[:,m_array([QG,QMAX,QMIN]).reshape(1,-1)-1]=zeros(ng,3)
        branch[:,m_array([BR_R,BR_B]).reshape(1,-1)-1]=zeros(nl,2)
    ties=find(bus[e2i[int(branch[:,F_BUS-1]-1)]-1,BUS_AREA-1]!=bus[e2i[int(branch[:,T_BUS-1]-1)]-1,BUS_AREA-1])
    tap=ones(nl,1)
    xfmr=find(branch[:,TAP-1])
    tap[int(xfmr-1)]=branch[xfmr-1,TAP-1]
    tap=tap*exp(1j*pi()/180*branch[:,SHIFT-1])
    nzld=find(bus[:,PD-1]|bus[:,QD-1])
    sorted_areas=sort(bus[:,BUS_AREA-1])
    s_areas=sorted_areas[int(m_array([[1],[find(diff(sorted_areas))+1]]).reshape(1,-1)-1)]
    nzsh=find(bus[:,GS-1]|bus[:,BS-1])
    allg=find( not isload(gen))
    ong=find(gen[:,GEN_STATUS-1]>0& not isload(gen))
    onld=find(gen[:,GEN_STATUS-1]>0&isload(gen))
    V=bus[:,VM-1]*exp(sqrt(-1)*pi()/180*bus[:,VA-1])
    out=find(branch[:,BR_STATUS-1]==0)
    nout=length(out)
    if isDC:
        loss=zeros(nl,1)
    else:
        loss=baseMVA*abs(V[int(e2i[int(branch[:,F_BUS-1]-1)]-1)]/tap-V[int(e2i[int(branch[:,T_BUS-1]-1)]-1)])**2/(branch[:,BR_R-1]-1j*branch[:,BR_X-1])
    fchg=abs(V[int(e2i[int(branch[:,F_BUS-1]-1)]-1)]/tap)**2*branch[:,BR_B-1]*baseMVA/2
    tchg=abs(V[int(e2i[int(branch[:,T_BUS-1]-1)]-1)])**2*branch[:,BR_B-1]*baseMVA/2
    loss[int(out-1)]=zeros(nout,1)
    fchg[int(out-1)]=zeros(nout,1)
    tchg[int(out-1)]=zeros(nout,1)
    if OUT_ANY:
        if success:
            fprintf(fd,'\\nConverged in %.2f seconds',et)
        else:
            fprintf(fd,'\\nDid not converge (%.2f seconds)\\n',et)
        if isOPF:
            fprintf(fd,'\\nObjective Function Value = %.2f $/hr',f)
    if OUT_SYS_SUM:
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     System Summary                                                           |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n\\nHow many?                How much?              P (MW)            Q (MVAr)')
        fprintf(fd,'\\n---------------------    -------------------  -------------  -----------------')
        fprintf(fd,'\\nBuses         %6d     Total Gen Capacity   %7.1f       %7.1f to %.1f',nb,sum(gen[allg-1,PMAX-1]),sum(gen[allg-1,QMIN-1]),sum(gen[allg-1,QMAX-1]))
        fprintf(fd,'\\nGenerators     %5d     On-line Capacity     %7.1f       %7.1f to %.1f',length(allg),sum(gen[ong-1,PMAX-1]),sum(gen[ong-1,QMIN-1]),sum(gen[ong-1,QMAX-1]))
        fprintf(fd,'\\nCommitted Gens %5d     Generation (actual)  %7.1f           %7.1f',length(ong),sum(gen[ong-1,PG-1]),sum(gen[ong-1,QG-1]))
        fprintf(fd,'\\nLoads          %5d     Load                 %7.1f           %7.1f',length(nzld)+length(onld),sum(bus[nzld-1,PD-1])-sum(gen[onld-1,PG-1]),sum(bus[nzld-1,QD-1])-sum(gen[onld-1,QG-1]))
        fprintf(fd,'\\n  Fixed        %5d       Fixed              %7.1f           %7.1f',length(nzld),sum(bus[nzld-1,PD-1]),sum(bus[nzld-1,QD-1]))
        fprintf(fd,'\\n  Dispatchable %5d       Dispatchable       %7.1f of %-7.1f%7.1f',length(onld),-sum(gen[onld-1,PG-1]),-sum(gen[onld-1,PMIN-1]),-sum(gen[onld-1,QG-1]))
        fprintf(fd,'\\nShunts         %5d     Shunt (inj)          %7.1f           %7.1f',length(nzsh),-sum(bus[nzsh-1,VM-1]**2*bus[nzsh-1,GS-1]),sum(bus[nzsh-1,VM-1]**2*bus[nzsh-1,BS-1]))
        fprintf(fd,'\\nBranches       %5d     Losses (I^2 * Z)     %8.2f          %8.2f',nl,sum(real(loss)),sum(imag(loss)))
        fprintf(fd,'\\nTransformers   %5d     Branch Charging (inj)     -            %7.1f',length(xfmr),sum(fchg)+sum(tchg))
        fprintf(fd,'\\nInter-ties     %5d     Total Inter-tie Flow %7.1f           %7.1f',length(ties),sum(abs(branch[ties-1,PF-1]-branch[ties-1,PT-1]))/2,sum(abs(branch[ties-1,QF-1]-branch[ties-1,QT-1]))/2)
        fprintf(fd,'\\nAreas          %5d',length(s_areas))
        fprintf(fd,'\\n')
        fprintf(fd,'\\n                          Minimum                      Maximum')
        fprintf(fd,'\\n                 -------------------------  --------------------------------')
        minv,mini=min(bus[:,VM-1],nargout=2)
        maxv,maxi=max(bus[:,VM-1],nargout=2)
        fprintf(fd,'\\nVoltage Magnitude %7.3f p.u. @ bus %-4d     %7.3f p.u. @ bus %-4d',minv,bus[mini-1,BUS_I-1],maxv,bus[maxi-1,BUS_I-1])
        minv,mini=min(bus[:,VA-1],nargout=2)
        maxv,maxi=max(bus[:,VA-1],nargout=2)
        fprintf(fd,'\\nVoltage Angle   %8.2f deg   @ bus %-4d   %8.2f deg   @ bus %-4d',minv,bus[mini-1,BUS_I-1],maxv,bus[maxi-1,BUS_I-1])
        if  not isDC:
            maxv,maxi=max(real(loss),nargout=2)
            fprintf(fd,'\\nP Losses (I^2*R)             -              %8.2f MW    @ line %d-%d',maxv,branch[maxi-1,F_BUS-1],branch[maxi-1,T_BUS-1])
            maxv,maxi=max(imag(loss),nargout=2)
            fprintf(fd,'\\nQ Losses (I^2*X)             -              %8.2f MVAr  @ line %d-%d',maxv,branch[maxi-1,F_BUS-1],branch[maxi-1,T_BUS-1])
        if isOPF:
            minv,mini=min(bus[:,LAM_P-1],nargout=2)
            maxv,maxi=max(bus[:,LAM_P-1],nargout=2)
            fprintf(fd,'\\nLambda P        %8.2f $/MWh @ bus %-4d   %8.2f $/MWh @ bus %-4d',minv,bus[mini-1,BUS_I-1],maxv,bus[maxi-1,BUS_I-1])
            minv,mini=min(bus[:,LAM_Q-1],nargout=2)
            maxv,maxi=max(bus[:,LAM_Q-1],nargout=2)
            fprintf(fd,'\\nLambda Q        %8.2f $/MWh @ bus %-4d   %8.2f $/MWh @ bus %-4d',minv,bus[mini-1,BUS_I-1],maxv,bus[maxi-1,BUS_I-1])
        fprintf(fd,'\\n')
    if OUT_AREA_SUM:
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     Area Summary                                                             |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\nArea  # of      # of Gens        # of Loads         # of    # of   # of   # of')
        fprintf(fd,'\\n Num  Buses   Total  Online   Total  Fixed  Disp    Shunt   Brchs  Xfmrs   Ties')
        fprintf(fd,'\\n----  -----   -----  ------   -----  -----  -----   -----   -----  -----  -----')
        for i in arange(1,length(s_areas)+1).reshape(1,-1).flat:
            a=s_areas[int(i-1)]
            ib=find(bus[:,BUS_AREA-1]==a)
            ig=find(bus[e2i[int(gen[:,GEN_BUS-1]-1)]-1,BUS_AREA-1]==a& not isload(gen))
            igon=find(bus[e2i[int(gen[:,GEN_BUS-1]-1)]-1,BUS_AREA-1]==a&gen[:,GEN_STATUS-1]>0& not isload(gen))
            ildon=find(bus[e2i[int(gen[:,GEN_BUS-1]-1)]-1,BUS_AREA-1]==a&gen[:,GEN_STATUS-1]>0&isload(gen))
            inzld=find(bus[:,BUS_AREA-1]==a&(bus[:,PD-1]|bus[:,QD-1]))
            inzsh=find(bus[:,BUS_AREA-1]==a&(bus[:,GS-1]|bus[:,BS-1]))
            ibrch=find(bus[e2i[int(branch[:,F_BUS-1]-1)]-1,BUS_AREA-1]==a&bus[e2i[int(branch[:,T_BUS-1]-1)]-1,BUS_AREA-1]==a)
            in_tie=find(bus[e2i[int(branch[:,F_BUS-1]-1)]-1,BUS_AREA-1]==a&bus[e2i[int(branch[:,T_BUS-1]-1)]-1,BUS_AREA-1]!=a)
            out_tie=find(bus[e2i[int(branch[:,F_BUS-1]-1)]-1,BUS_AREA-1]!=a&bus[e2i[int(branch[:,T_BUS-1]-1)]-1,BUS_AREA-1]==a)
            if isempty(xfmr):
                nxfmr=0
            else:
                nxfmr=length(find(bus[e2i[int(branch[xfmr-1,F_BUS-1]-1)]-1,BUS_AREA-1]==a&bus[e2i[int(branch[xfmr-1,T_BUS-1]-1)]-1,BUS_AREA-1]==a))
            fprintf(fd,'\\n%3d  %6d   %5d  %5d   %5d  %5d  %5d   %5d   %5d  %5d  %5d',a,length(ib),length(ig),length(igon),length(inzld)+length(ildon),length(inzld),length(ildon),length(inzsh),length(ibrch),nxfmr,length(in_tie)+length(out_tie))
        fprintf(fd,'\\n----  -----   -----  ------   -----  -----  -----   -----   -----  -----  -----')
        fprintf(fd,'\\nTot: %6d   %5d  %5d   %5d  %5d  %5d   %5d   %5d  %5d  %5d',nb,length(allg),length(ong),length(nzld)+length(onld),length(nzld),length(onld),length(nzsh),nl,length(xfmr),length(ties))
        fprintf(fd,'\\n')
        fprintf(fd,'\\nArea      Total Gen Capacity           On-line Gen Capacity         Generation')
        fprintf(fd,'\\n Num     MW           MVAr            MW           MVAr             MW    MVAr')
        fprintf(fd,'\\n----   ------  ------------------   ------  ------------------    ------  ------')
        for i in arange(1,length(s_areas)+1).reshape(1,-1).flat:
            a=s_areas[int(i-1)]
            ig=find(bus[e2i[int(gen[:,GEN_BUS-1]-1)]-1,BUS_AREA-1]==a& not isload(gen))
            igon=find(bus[e2i[int(gen[:,GEN_BUS-1]-1)]-1,BUS_AREA-1]==a&gen[:,GEN_STATUS-1]>0& not isload(gen))
            fprintf(fd,'\\n%3d   %7.1f  %7.1f to %-7.1f  %7.1f  %7.1f to %-7.1f   %7.1f %7.1f',a,sum(gen[ig-1,PMAX-1]),sum(gen[ig-1,QMIN-1]),sum(gen[ig-1,QMAX-1]),sum(gen[igon-1,PMAX-1]),sum(gen[igon-1,QMIN-1]),sum(gen[igon-1,QMAX-1]),sum(gen[igon-1,PG-1]),sum(gen[igon-1,QG-1]))
        fprintf(fd,'\\n----   ------  ------------------   ------  ------------------    ------  ------')
        fprintf(fd,'\\nTot:  %7.1f  %7.1f to %-7.1f  %7.1f  %7.1f to %-7.1f   %7.1f %7.1f',sum(gen[allg-1,PMAX-1]),sum(gen[allg-1,QMIN-1]),sum(gen[allg-1,QMAX-1]),sum(gen[ong-1,PMAX-1]),sum(gen[ong-1,QMIN-1]),sum(gen[ong-1,QMAX-1]),sum(gen[ong-1,PG-1]),sum(gen[ong-1,QG-1]))
        fprintf(fd,'\\n')
        fprintf(fd,'\\nArea    Disp Load Cap       Disp Load         Fixed Load        Total Load')
        fprintf(fd,'\\n Num      MW     MVAr       MW     MVAr       MW     MVAr       MW     MVAr')
        fprintf(fd,'\\n----    ------  ------    ------  ------    ------  ------    ------  ------')
        Qlim=(gen[:,QMIN-1]==0)*gen[:,QMAX-1]+(gen[:,QMAX-1]==0)*gen[:,QMIN-1]
        for i in arange(1,length(s_areas)+1).reshape(1,-1).flat:
            a=s_areas[int(i-1)]
            ildon=find(bus[e2i[int(gen[:,GEN_BUS-1]-1)]-1,BUS_AREA-1]==a&gen[:,GEN_STATUS-1]>0&isload(gen))
            inzld=find(bus[:,BUS_AREA-1]==a&(bus[:,PD-1]|bus[:,QD-1]))
            fprintf(fd,'\\n%3d    %7.1f %7.1f   %7.1f %7.1f   %7.1f %7.1f   %7.1f %7.1f',a,-sum(gen[ildon-1,PMIN-1]),-sum(Qlim[int(ildon-1)]),-sum(gen[ildon-1,PG-1]),-sum(gen[ildon-1,QG-1]),sum(bus[inzld-1,PD-1]),sum(bus[inzld-1,QD-1]),-sum(gen[ildon-1,PG-1])+sum(bus[inzld-1,PD-1]),-sum(gen[ildon-1,QG-1])+sum(bus[inzld-1,QD-1]))
        fprintf(fd,'\\n----    ------  ------    ------  ------    ------  ------    ------  ------')
        fprintf(fd,'\\nTot:   %7.1f %7.1f   %7.1f %7.1f   %7.1f %7.1f   %7.1f %7.1f',-sum(gen[onld-1,PMIN-1]),-sum(Qlim[int(onld-1)]),-sum(gen[onld-1,PG-1]),-sum(gen[onld-1,QG-1]),sum(bus[nzld-1,PD-1]),sum(bus[nzld-1,QD-1]),-sum(gen[onld-1,PG-1])+sum(bus[nzld-1,PD-1]),-sum(gen[onld-1,QG-1])+sum(bus[nzld-1,QD-1]))
        fprintf(fd,'\\n')
        fprintf(fd,'\\nArea      Shunt Inj        Branch      Series Losses      Net Export')
        fprintf(fd,'\\n Num      MW     MVAr     Charging      MW     MVAr       MW     MVAr')
        fprintf(fd,'\\n----    ------  ------    --------    ------  ------    ------  ------')
        for i in arange(1,length(s_areas)+1).reshape(1,-1).flat:
            a=s_areas[int(i-1)]
            inzsh=find(bus[:,BUS_AREA-1]==a&(bus[:,GS-1]|bus[:,BS-1]))
            ibrch=find(bus[e2i[int(branch[:,F_BUS-1]-1)]-1,BUS_AREA-1]==a&bus[e2i[int(branch[:,T_BUS-1]-1)]-1,BUS_AREA-1]==a&branch[:,BR_STATUS-1])
            in_tie=find(bus[e2i[int(branch[:,F_BUS-1]-1)]-1,BUS_AREA-1]!=a&bus[e2i[int(branch[:,T_BUS-1]-1)]-1,BUS_AREA-1]==a&branch[:,BR_STATUS-1])
            out_tie=find(bus[e2i[int(branch[:,F_BUS-1]-1)]-1,BUS_AREA-1]==a&bus[e2i[int(branch[:,T_BUS-1]-1)]-1,BUS_AREA-1]!=a&branch[:,BR_STATUS-1])
            fprintf(fd,'\\n%3d    %7.1f %7.1f    %7.1f    %7.2f %7.2f   %7.1f %7.1f',a,-sum(bus[inzsh-1,VM-1]**2*bus[inzsh-1,GS-1]),sum(bus[inzsh-1,VM-1]**2*bus[inzsh-1,BS-1]),sum(fchg[int(ibrch-1)])+sum(tchg[int(ibrch-1)])+sum(fchg[int(out_tie-1)])+sum(tchg[int(in_tie-1)]),sum(real(loss[int(ibrch-1)]))+sum(real(loss[int(m_array([[in_tie],[out_tie]]).reshape(1,-1)-1)]))/2,sum(imag(loss[int(ibrch-1)]))+sum(imag(loss[int(m_array([[in_tie],[out_tie]]).reshape(1,-1)-1)]))/2,sum(branch[in_tie-1,PT-1])+sum(branch[out_tie-1,PF-1])-sum(real(loss[int(m_array([[in_tie],[out_tie]]).reshape(1,-1)-1)]))/2,sum(branch[in_tie-1,QT-1])+sum(branch[out_tie-1,QF-1])-sum(imag(loss[int(m_array([[in_tie],[out_tie]]).reshape(1,-1)-1)]))/2)
        fprintf(fd,'\\n----    ------  ------    --------    ------  ------    ------  ------')
        fprintf(fd,'\\nTot:   %7.1f %7.1f    %7.1f    %7.2f %7.2f       -       -',-sum(bus[nzsh-1,VM-1]**2*bus[nzsh-1,GS-1]),sum(bus[nzsh-1,VM-1]**2*bus[nzsh-1,BS-1]),sum(fchg)+sum(tchg),sum(real(loss)),sum(imag(loss)))
        fprintf(fd,'\\n')
    if OUT_GEN:
        if isOPF:
            genlamP=bus[e2i[int(gen[:,GEN_BUS-1]-1)]-1,LAM_P-1]
            genlamQ=bus[e2i[int(gen[:,GEN_BUS-1]-1)]-1,LAM_Q-1]
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     Generator Data                                                           |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n Gen   Bus   Status     Pg        Qg   ')
        if isOPF:
            fprintf(fd,'   Lambda ($/MVA-hr)')
        fprintf(fd,'\\n  #     #              (MW)     (MVAr) ')
        if isOPF:
            fprintf(fd,'     P         Q    ')
        fprintf(fd,'\\n----  -----  ------  --------  --------')
        if isOPF:
            fprintf(fd,'  --------  --------')
        for k in arange(1,length(ong)+1).reshape(1,-1).flat:
            i=ong[int(k-1)]
            fprintf(fd,'\\n%3d %6d     %2d ',i,gen[i-1,GEN_BUS-1],gen[i-1,GEN_STATUS-1])
            if gen[i-1,GEN_STATUS-1]>0 and (gen[i-1,PG-1] or gen[i-1,QG-1]):
                fprintf(fd,'%10.2f%10.2f',gen[i-1,PG-1],gen[i-1,QG-1])
            else:
                fprintf(fd,'       -         -  ')
            if isOPF:
                fprintf(fd,'%10.2f%10.2f',genlamP[int(i-1)],genlamQ[int(i-1)])
        fprintf(fd,'\\n                     --------  --------')
        fprintf(fd,'\\n            Total: %9.2f%10.2f',sum(gen[ong-1,PG-1]),sum(gen[ong-1,QG-1]))
        fprintf(fd,'\\n')
        if  not isempty(onld):
            fprintf(fd,'\\n================================================================================')
            fprintf(fd,'\\n|     Dispatchable Load Data                                                   |')
            fprintf(fd,'\\n================================================================================')
            fprintf(fd,'\\n Gen   Bus   Status     Pd        Qd   ')
            if isOPF:
                fprintf(fd,'   Lambda ($/MVA-hr)')
            fprintf(fd,'\\n  #     #              (MW)     (MVAr) ')
            if isOPF:
                fprintf(fd,'     P         Q    ')
            fprintf(fd,'\\n----  -----  ------  --------  --------')
            if isOPF:
                fprintf(fd,'  --------  --------')
            for k in arange(1,length(onld)+1).reshape(1,-1).flat:
                i=onld[int(k-1)]
                fprintf(fd,'\\n%3d %6d     %2d ',i,gen[i-1,GEN_BUS-1],gen[i-1,GEN_STATUS-1])
                if gen[i-1,GEN_STATUS-1]>0 and (gen[i-1,PG-1] or gen[i-1,QG-1]):
                    fprintf(fd,'%10.2f%10.2f',-gen[i-1,PG-1],-gen[i-1,QG-1])
                else:
                    fprintf(fd,'       -         -  ')
                if isOPF:
                    fprintf(fd,'%10.2f%10.2f',genlamP[int(i-1)],genlamQ[int(i-1)])
            fprintf(fd,'\\n                     --------  --------')
            fprintf(fd,'\\n            Total: %9.2f%10.2f',-sum(gen[onld-1,PG-1]),-sum(gen[onld-1,QG-1]))
            fprintf(fd,'\\n')
    if OUT_BUS:
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     Bus Data                                                                 |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n Bus      Voltage          Generation             Load        ')
        if isOPF:
            fprintf(fd,'  Lambda($/MVA-hr)')
        fprintf(fd,'\\n  #   Mag(pu) Ang(deg)   P (MW)   Q (MVAr)   P (MW)   Q (MVAr)')
        if isOPF:
            fprintf(fd,'     P        Q   ')
        fprintf(fd,'\\n----- ------- --------  --------  --------  --------  --------')
        if isOPF:
            fprintf(fd,'  -------  -------')
        for i in arange(1,nb+1).reshape(1,-1).flat:
            fprintf(fd,'\\n%5d%7.3f%9.3f',bus[i-1,m_array([BUS_I,VM,VA]).reshape(1,-1)-1])
            if bus[i-1,BUS_TYPE-1]==REF:
                fprintf(fd,'*')
            else:
                fprintf(fd,' ')
            g=find(gen[:,GEN_STATUS-1]>0&gen[:,GEN_BUS-1]==bus[i-1,BUS_I-1]& not isload(gen))
            ld=find(gen[:,GEN_STATUS-1]>0&gen[:,GEN_BUS-1]==bus[i-1,BUS_I-1]&isload(gen))
            if  not isempty(g):
                fprintf(fd,'%9.2f%10.2f',sum(gen[g-1,PG-1]),sum(gen[g-1,QG-1]))
            else:
                fprintf(fd,'      -         -  ')
            if bus[i-1,PD-1] or bus[i-1,QD-1] or  not isempty(ld):
                if  not isempty(ld):
                    fprintf(fd,'%10.2f*%9.2f*',bus[i-1,PD-1]-sum(gen[ld-1,PG-1]),bus[i-1,QD-1]-sum(gen[ld-1,QG-1]))
                else:
                    fprintf(fd,'%10.2f%10.2f ',bus[i-1,m_array([PD,QD]).reshape(1,-1)-1])
            else:
                fprintf(fd,'       -         -   ')
            if isOPF:
                fprintf(fd,'%9.3f',bus[i-1,LAM_P-1])
                if abs(bus[i-1,LAM_Q-1])>ptol:
                    fprintf(fd,'%8.3f',bus[i-1,LAM_Q-1])
                else:
                    fprintf(fd,'     -')
        fprintf(fd,'\\n                        --------  --------  --------  --------')
        fprintf(fd,'\\n               Total: %9.2f %9.2f %9.2f %9.2f',sum(gen[ong-1,PG-1]),sum(gen[ong-1,QG-1]),sum(bus[nzld-1,PD-1])-sum(gen[onld-1,PG-1]),sum(bus[nzld-1,QD-1])-sum(gen[onld-1,QG-1]))
        fprintf(fd,'\\n')
    if OUT_BRANCH:
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     Branch Data                                                              |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\nBrnch   From   To    From Bus Injection   To Bus Injection     Loss (I^2 * Z)  ')
        fprintf(fd,'\\n  #     Bus    Bus    P (MW)   Q (MVAr)   P (MW)   Q (MVAr)   P (MW)   Q (MVAr)')
        fprintf(fd,'\\n-----  -----  -----  --------  --------  --------  --------  --------  --------')
        fprintf(fd,'\\n%4d%7d%7d%10.2f%10.2f%10.2f%10.2f%10.3f%10.2f',m_array([(arange(1,nl+1).reshape(1,-1)).T,branch[:,m_array([F_BUS,T_BUS]).reshape(1,-1)-1],branch[:,m_array([PF,QF]).reshape(1,-1)-1],branch[:,m_array([PT,QT]).reshape(1,-1)-1],real(loss),imag(loss)]).reshape(1,-1).T)
        fprintf(fd,'\\n                                                             --------  --------')
        fprintf(fd,'\\n                                                    Total:%10.3f%10.2f',sum(real(loss)),sum(imag(loss)))
        fprintf(fd,'\\n')
    if isOPF:
        ctol=mpopt[int(16-1)]
        if  not isDC and (OUT_V_LIM==2 or (OUT_V_LIM==1 and (any(bus[:,VM-1]<bus[:,VMIN-1]+ctol) or any(bus[:,VM-1]>bus[:,VMAX-1]-ctol) or any(bus[:,MU_VMIN-1]>ptol) or any(bus[:,MU_VMAX-1]>ptol)))):
            fprintf(fd,'\\n================================================================================')
            fprintf(fd,'\\n|     Voltage Constraints                                                      |')
            fprintf(fd,'\\n================================================================================')
            fprintf(fd,'\\nBus #  Vmin mu    Vmin    |V|   Vmax    Vmax mu')
            fprintf(fd,'\\n-----  --------   -----  -----  -----   --------')
            for i in arange(1,nb+1).reshape(1,-1).flat:
                if OUT_V_LIM==2 or (OUT_V_LIM==1 and (bus[i-1,VM-1]<bus[i-1,VMIN-1]+ctol or bus[i-1,VM-1]>bus[i-1,VMAX-1]-ctol or bus[i-1,MU_VMIN-1]>ptol or bus[i-1,MU_VMAX-1]>ptol)):
                    fprintf(fd,'\\n%5d',bus[i-1,BUS_I-1])
                    if bus[i-1,VM-1]<bus[i-1,VMIN-1]+ctol or bus[i-1,MU_VMIN-1]>ptol:
                        fprintf(fd,'%10.3f',bus[i-1,MU_VMIN-1])
                    else:
                        fprintf(fd,'      -   ')
                    fprintf(fd,'%8.3f%7.3f%7.3f',bus[i-1,m_array([VMIN,VM,VMAX]).reshape(1,-1)-1])
                    if bus[i-1,VM-1]>bus[i-1,VMAX-1]-ctol or bus[i-1,MU_VMAX-1]>ptol:
                        fprintf(fd,'%10.3f',bus[i-1,MU_VMAX-1])
                    else:
                        fprintf(fd,'      -    ')
            fprintf(fd,'\\n')
        if OUT_PG_LIM==2 or (OUT_PG_LIM==1 and (any(gen[ong-1,PG-1]<gen[ong-1,PMIN-1]+ctol) or any(gen[ong-1,PG-1]>gen[ong-1,PMAX-1]-ctol) or any(gen[ong-1,MU_PMIN-1]>ptol) or any(gen[ong-1,MU_PMAX-1]>ptol))) or ( not isDC and (OUT_QG_LIM==2 or (OUT_QG_LIM==1 and (any(gen[ong-1,QG-1]<gen[ong-1,QMIN-1]+ctol) or any(gen[ong-1,QG-1]>gen[ong-1,QMAX-1]-ctol) or any(gen[ong-1,MU_QMIN-1]>ptol) or any(gen[ong-1,MU_QMAX-1]>ptol))))):
            fprintf(fd,'\\n================================================================================')
            fprintf(fd,'\\n|     Generation Constraints                                                   |')
            fprintf(fd,'\\n================================================================================')
        if OUT_PG_LIM==2 or (OUT_PG_LIM==1 and (any(gen[ong-1,PG-1]<gen[ong-1,PMIN-1]+ctol) or any(gen[ong-1,PG-1]>gen[ong-1,PMAX-1]-ctol) or any(gen[ong-1,MU_PMIN-1]>ptol) or any(gen[ong-1,MU_PMAX-1]>ptol))):
            fprintf(fd,'\\n Gen   Bus                Active Power Limits')
            fprintf(fd,'\\n  #     #    Pmin mu    Pmin       Pg       Pmax    Pmax mu')
            fprintf(fd,'\\n----  -----  -------  --------  --------  --------  -------')
            for k in arange(1,length(ong)+1).reshape(1,-1).flat:
                i=ong[int(k-1)]
                if OUT_PG_LIM==2 or (OUT_PG_LIM==1 and (gen[i-1,PG-1]<gen[i-1,PMIN-1]+ctol or gen[i-1,PG-1]>gen[i-1,PMAX-1]-ctol or gen[i-1,MU_PMIN-1]>ptol or gen[i-1,MU_PMAX-1]>ptol)):
                    fprintf(fd,'\\n%4d%6d ',i,gen[i-1,GEN_BUS-1])
                    if gen[i-1,PG-1]<gen[i-1,PMIN-1]+ctol or gen[i-1,MU_PMIN-1]>ptol:
                        fprintf(fd,'%8.3f',gen[i-1,MU_PMIN-1])
                    else:
                        fprintf(fd,'     -  ')
                    if gen[i-1,PG-1]:
                        fprintf(fd,'%10.2f%10.2f%10.2f',gen[i-1,m_array([PMIN,PG,PMAX]).reshape(1,-1)-1])
                    else:
                        fprintf(fd,'%10.2f       -  %10.2f',gen[i-1,m_array([PMIN,PMAX]).reshape(1,-1)-1])
                    if gen[i-1,PG-1]>gen[i-1,PMAX-1]-ctol or gen[i-1,MU_PMAX-1]>ptol:
                        fprintf(fd,'%9.3f',gen[i-1,MU_PMAX-1])
                    else:
                        fprintf(fd,'      -  ')
            fprintf(fd,'\\n')
        if  not isDC and (OUT_QG_LIM==2 or (OUT_QG_LIM==1 and (any(gen[ong-1,QG-1]<gen[ong-1,QMIN-1]+ctol) or any(gen[ong-1,QG-1]>gen[ong-1,QMAX-1]-ctol) or any(gen[ong-1,MU_QMIN-1]>ptol) or any(gen[ong-1,MU_QMAX-1]>ptol)))):
            fprintf(fd,'\\nGen  Bus              Reactive Power Limits')
            fprintf(fd,'\\n #    #   Qmin mu    Qmin       Qg       Qmax    Qmax mu')
            fprintf(fd,'\\n---  ---  -------  --------  --------  --------  -------')
            for k in arange(1,length(ong)+1).reshape(1,-1).flat:
                i=ong[int(k-1)]
                if OUT_QG_LIM==2 or (OUT_QG_LIM==1 and (gen[i-1,QG-1]<gen[i-1,QMIN-1]+ctol or gen[i-1,QG-1]>gen[i-1,QMAX-1]-ctol or gen[i-1,MU_QMIN-1]>ptol or gen[i-1,MU_QMAX-1]>ptol)):
                    fprintf(fd,'\\n%3d%5d',i,gen[i-1,GEN_BUS-1])
                    if gen[i-1,QG-1]<gen[i-1,QMIN-1]+ctol or gen[i-1,MU_QMIN-1]>ptol:
                        fprintf(fd,'%8.3f',gen[i-1,MU_QMIN-1])
                    else:
                        fprintf(fd,'     -  ')
                    if gen[i-1,QG-1]:
                        fprintf(fd,'%10.2f%10.2f%10.2f',gen[i-1,m_array([QMIN,QG,QMAX]).reshape(1,-1)-1])
                    else:
                        fprintf(fd,'%10.2f       -  %10.2f',gen[i-1,m_array([QMIN,QMAX]).reshape(1,-1)-1])
                    if gen[i-1,QG-1]>gen[i-1,QMAX-1]-ctol or gen[i-1,MU_QMAX-1]>ptol:
                        fprintf(fd,'%9.3f',gen[i-1,MU_QMAX-1])
                    else:
                        fprintf(fd,'      -  ')
            fprintf(fd,'\\n')
        if OUT_PG_LIM==2 or OUT_QG_LIM==2 or (OUT_PG_LIM==1 and (any(gen[onld-1,PG-1]<gen[onld-1,PMIN-1]+ctol) or any(gen[onld-1,PG-1]>gen[onld-1,PMAX-1]-ctol) or any(gen[onld-1,MU_PMIN-1]>ptol) or any(gen[onld-1,MU_PMAX-1]>ptol))) or (OUT_QG_LIM==1 and (any(gen[onld-1,QG-1]<gen[onld-1,QMIN-1]+ctol) or any(gen[onld-1,QG-1]>gen[onld-1,QMAX-1]-ctol) or any(gen[onld-1,MU_QMIN-1]>ptol) or any(gen[onld-1,MU_QMAX-1]>ptol))):
            fprintf(fd,'\\n================================================================================')
            fprintf(fd,'\\n|     Dispatchable Load Constraints                                            |')
            fprintf(fd,'\\n================================================================================')
        if OUT_PG_LIM==2 or (OUT_PG_LIM==1 and (any(gen[onld-1,PG-1]<gen[onld-1,PMIN-1]+ctol) or any(gen[onld-1,PG-1]>gen[onld-1,PMAX-1]-ctol) or any(gen[onld-1,MU_PMIN-1]>ptol) or any(gen[onld-1,MU_PMAX-1]>ptol))):
            fprintf(fd,'\\nGen  Bus               Active Power Limits')
            fprintf(fd,'\\n #    #   Pmin mu    Pmin       Pg       Pmax    Pmax mu')
            fprintf(fd,'\\n---  ---  -------  --------  --------  --------  -------')
            for k in arange(1,length(onld)+1).reshape(1,-1).flat:
                i=onld[int(k-1)]
                if OUT_PG_LIM==2 or (OUT_PG_LIM==1 and (gen[i-1,PG-1]<gen[i-1,PMIN-1]+ctol or gen[i-1,PG-1]>gen[i-1,PMAX-1]-ctol or gen[i-1,MU_PMIN-1]>ptol or gen[i-1,MU_PMAX-1]>ptol)):
                    fprintf(fd,'\\n%3d%5d',i,gen[i-1,GEN_BUS-1])
                    if gen[i-1,PG-1]<gen[i-1,PMIN-1]+ctol or gen[i-1,MU_PMIN-1]>ptol:
                        fprintf(fd,'%8.3f',gen[i-1,MU_PMIN-1])
                    else:
                        fprintf(fd,'     -  ')
                    if gen[i-1,PG-1]:
                        fprintf(fd,'%10.2f%10.2f%10.2f',gen[i-1,m_array([PMIN,PG,PMAX]).reshape(1,-1)-1])
                    else:
                        fprintf(fd,'%10.2f       -  %10.2f',gen[i-1,m_array([PMIN,PMAX]).reshape(1,-1)-1])
                    if gen[i-1,PG-1]>gen[i-1,PMAX-1]-ctol or gen[i-1,MU_PMAX-1]>ptol:
                        fprintf(fd,'%9.3f',gen[i-1,MU_PMAX-1])
                    else:
                        fprintf(fd,'      -  ')
            fprintf(fd,'\\n')
        if  not isDC and (OUT_QG_LIM==2 or (OUT_QG_LIM==1 and (any(gen[onld-1,QG-1]<gen[onld-1,QMIN-1]+ctol) or any(gen[onld-1,QG-1]>gen[onld-1,QMAX-1]-ctol) or any(gen[onld-1,MU_QMIN-1]>ptol) or any(gen[onld-1,MU_QMAX-1]>ptol)))):
            fprintf(fd,'\\nGen  Bus              Reactive Power Limits')
            fprintf(fd,'\\n #    #   Qmin mu    Qmin       Qg       Qmax    Qmax mu')
            fprintf(fd,'\\n---  ---  -------  --------  --------  --------  -------')
            for k in arange(1,length(onld)+1).reshape(1,-1).flat:
                i=onld[int(k-1)]
                if OUT_QG_LIM==2 or (OUT_QG_LIM==1 and (gen[i-1,QG-1]<gen[i-1,QMIN-1]+ctol or gen[i-1,QG-1]>gen[i-1,QMAX-1]-ctol or gen[i-1,MU_QMIN-1]>ptol or gen[i-1,MU_QMAX-1]>ptol)):
                    fprintf(fd,'\\n%3d%5d',i,gen[i-1,GEN_BUS-1])
                    if gen[i-1,QG-1]<gen[i-1,QMIN-1]+ctol or gen[i-1,MU_QMIN-1]>ptol:
                        fprintf(fd,'%8.3f',gen[i-1,MU_QMIN-1])
                    else:
                        fprintf(fd,'     -  ')
                    if gen[i-1,QG-1]:
                        fprintf(fd,'%10.2f%10.2f%10.2f',gen[i-1,m_array([QMIN,QG,QMAX]).reshape(1,-1)-1])
                    else:
                        fprintf(fd,'%10.2f       -  %10.2f',gen[i-1,m_array([QMIN,QMAX]).reshape(1,-1)-1])
                    if gen[i-1,QG-1]>gen[i-1,QMAX-1]-ctol or gen[i-1,MU_QMAX-1]>ptol:
                        fprintf(fd,'%9.3f',gen[i-1,MU_QMAX-1])
                    else:
                        fprintf(fd,'      -  ')
            fprintf(fd,'\\n')
        if mpopt[int(24-1)]==1 or isDC:
            Ff=branch[:,PF-1]
            Ft=branch[:,PT-1]
            str='\\n  #     Bus    Pf  mu     Pf      |Pmax|      Pt      Pt  mu   Bus'
        else:
            if mpopt[int(24-1)]==2:
                Ff=abs((branch[:,PF-1]+1j*branch[:,QF-1])/V[int(e2i[int(branch[:,F_BUS-1]-1)]-1)])
                Ft=abs((branch[:,PT-1]+1j*branch[:,QT-1])/V[int(e2i[int(branch[:,T_BUS-1]-1)]-1)])
                str='\\n  #     Bus   |If| mu    |If|     |Imax|     |It|    |It| mu   Bus'
            else:
                Ff=abs(branch[:,PF-1]+1j*branch[:,QF-1])
                Ft=abs(branch[:,PT-1]+1j*branch[:,QT-1])
                str='\\n  #     Bus   |Sf| mu    |Sf|     |Smax|     |St|    |St| mu   Bus'
        if OUT_LINE_LIM==2 or (OUT_LINE_LIM==1 and (any(branch[:,RATE_A-1]!=0&abs(Ff)>branch[:,RATE_A-1]-ctol) or any(branch[:,RATE_A-1]!=0&abs(Ft)>branch[:,RATE_A-1]-ctol) or any(branch[:,MU_SF-1]>ptol) or any(branch[:,MU_ST-1]>ptol))):
            fprintf(fd,'\\n================================================================================')
            fprintf(fd,'\\n|     Branch Flow Constraints                                                  |')
            fprintf(fd,'\\n================================================================================')
            fprintf(fd,'\\nBrnch   From     "From" End        Limit       "To" End        To')
            fprintf(fd,str)
            fprintf(fd,'\\n-----  -----  -------  --------  --------  --------  -------  -----')
            for i in arange(1,nl+1).reshape(1,-1).flat:
                if OUT_LINE_LIM==2 or (OUT_LINE_LIM==1 and ((branch[i-1,RATE_A-1]!=0 and abs(Ff[int(i-1)])>branch[i-1,RATE_A-1]-ctol) or (branch[i-1,RATE_A-1]!=0 and abs(Ft[int(i-1)])>branch[i-1,RATE_A-1]-ctol) or branch[i-1,MU_SF-1]>ptol or branch[i-1,MU_ST-1]>ptol)):
                    fprintf(fd,'\\n%4d%7d',i,branch[i-1,F_BUS-1])
                    if Ff[int(i-1)]>branch[i-1,RATE_A-1]-ctol or branch[i-1,MU_SF-1]>ptol:
                        fprintf(fd,'%10.3f',branch[i-1,MU_SF-1])
                    else:
                        fprintf(fd,'      -   ')
                    fprintf(fd,'%9.2f%10.2f%10.2f',m_array([Ff[int(i-1)],branch[i-1,RATE_A-1],Ft[int(i-1)]]).reshape(1,-1))
                    if Ft[int(i-1)]>branch[i-1,RATE_A-1]-ctol or branch[i-1,MU_ST-1]>ptol:
                        fprintf(fd,'%10.3f',branch[i-1,MU_ST-1])
                    else:
                        fprintf(fd,'      -   ')
                    fprintf(fd,'%6d',branch[i-1,T_BUS-1])
            fprintf(fd,'\\n')
    if have_results_struct and isfield(results,'userfcn'):
        if  not isOPF:
            mpopt=mpoption(mpopt,'OUT_ALL_LIM',0)
        run_userfcn(results.userfcn,'printpf',results,fd,mpopt)
    return 
def qps_cplex(H,c,A,l,u,xmin,xmax,x0,opt,**kwargs):
    if nargin()==1 and isstruct(H):
        p=H
        if isfield(p,'opt'):
            opt=p.opt
        else:
            opt=m_array()
        if isfield(p,'x0'):
            x0=p.x0
        else:
            x0=m_array()
        if isfield(p,'xmax'):
            xmax=p.xmax
        else:
            xmax=m_array()
        if isfield(p,'xmin'):
            xmin=p.xmin
        else:
            xmin=m_array()
        if isfield(p,'u'):
            u=p.u
        else:
            u=m_array()
        if isfield(p,'l'):
            l=p.l
        else:
            l=m_array()
        if isfield(p,'A'):
            A=p.A
        else:
            A=m_array()
        if isfield(p,'c'):
            c=p.c
        else:
            c=m_array()
        if isfield(p,'H'):
            H=p.H
        else:
            H=m_array()
    else:
        if nargin()<9:
            opt=m_array()
            if nargin()<8:
                x0=m_array()
                if nargin()<7:
                    xmax=m_array()
                    if nargin()<6:
                        xmin=m_array()
    if isempty(H) or  not any(any(H)):
        if isempty(A) and isempty(xmin) and isempty(xmax):
            error('qps_cplex: LP problem must include constraints or variable bounds')
        else:
            if  not isempty(A):
                nx=size(A,2)
            else:
                if  not isempty(xmin):
                    nx=length(xmin)
                else:
                    nx=length(xmax)
    else:
        nx=size(H,1)
    if isempty(c):
        c=zeros(nx,1)
    if  not isempty(A) and (isempty(l) or all(l==-Inf())) and (isempty(u) or all(u==Inf())):
        A=sparse(0,nx)
    nA=size(A,1)
    if isempty(u):
        u=Inf()*ones(nA,1)
    if isempty(l):
        l=-Inf()*ones(nA,1)
    if isempty(xmin):
        xmin=-Inf()*ones(nx,1)
    if isempty(xmax):
        xmax=Inf()*ones(nx,1)
    if isempty(x0):
        x0=zeros(nx,1)
    if  not isempty(opt) and isfield(opt,'verbose') and  not isempty(opt.verbose):
        verbose=opt.verbose
    else:
        verbose=0
    ieq=find(abs(u-l)<=eps())
    igt=find(u>=10000000000.0&l>-10000000000.0)
    ilt=find(l<=-10000000000.0&u<10000000000.0)
    ibx=find((abs(u-l)>eps())&(u<10000000000.0)&(l>-10000000000.0))
    Ae=A[ieq-1,:]
    be=u[int(ieq-1)]
    Ai=m_array([[A[ilt-1,:]],[-A[igt-1,:]],[A[ibx-1,:]],[-A[ibx-1,:]]]).reshape(1,-1)
    bi=m_array([[u[int(ilt-1)]],[-l[int(igt-1)]],[u[int(ibx-1)]],[-l[int(ibx-1)]]]).reshape(1,-1)
    nlt=length(ilt)
    ngt=length(igt)
    nbx=length(ibx)
    if  not isempty(opt) and isfield(opt,'cplex_opt') and  not isempty(opt.cplex_opt):
        cplex_opt=cplex_options(opt.cplex_opt)
    else:
        cplex_opt=cplex_options()
    cplex=Cplex('null')
    vstr=cplex.getVersion
    s,e,tE,m,t=regexp(vstr,'(\\d+\\.\\d+)\\.',nargout=5)
    vnum=str2num(t[1-1][1-1])
    vrb=max(m_array([0,verbose-1]).reshape(1,-1))
    cplex_opt.barrier.display=vrb
    cplex_opt.conflict.display=vrb
    cplex_opt.mip.display=vrb
    cplex_opt.sifting.display=vrb
    cplex_opt.simplex.display=vrb
    cplex_opt.tune.display=vrb
    if vrb and vnum>12.2:
        cplex_opt.diagnostics='on'
    if isempty(Ai) and isempty(Ae):
        unconstrained=1
        Ae=sparse(1,nx)
        be=0
    else:
        unconstrained=0
    if verbose:
        methods=['default','primal simplex','dual simplex','network simplex','barrier','sifting','concurrent']
    if isempty(H) or  not any(any(H)):
        if verbose:
            fprintf('CPLEX Version %s -- %s LP solver\\n',vstr,methods[cplex_opt.lpmethod+1-1])
        x,f,eflag,output,lam=cplexlp(c,Ai,bi,Ae,be,xmin,xmax,x0,cplex_opt,nargout=5)
    else:
        if verbose:
            fprintf('CPLEX Version %s --  %s QP solver\\n',vstr,methods[cplex_opt.qpmethod+1-1])
        if  not isequal(H,H.T):
            H=(H+H.T)/2
        x,f,eflag,output,lam=cplexqp(H,c,Ai,bi,Ae,be,xmin,xmax,x0,cplex_opt,nargout=5)
    if isempty(x):
        x=NaN(nx,1)
    if isempty(f):
        f=NaN()
    if isempty(lam):
        lam.ineqlin=NaN(length(bi),1)
        lam.eqlin=NaN(length(be),1)
        lam.lower=NaN(nx,1)
        lam.upper=NaN(nx,1)
        mu_l=NaN(nA,1)
        mu_u=NaN(nA,1)
    else:
        mu_l=zeros(nA,1)
        mu_u=zeros(nA,1)
    if unconstrained:
        lam.eqlin=m_array()
    if vnum<12.3:
        lam.eqlin=-lam.eqlin
        lam.ineqlin=-lam.ineqlin
    kl=find(lam.eqlin<0)
    ku=find(lam.eqlin>0)
    mu_l[int(ieq[int(kl-1)]-1)]=-lam.eqlin[int(kl-1)]
    mu_l[int(igt-1)]=lam.ineqlin[int(nlt+(arange(1,ngt+1).reshape(1,-1))-1)]
    mu_l[int(ibx-1)]=lam.ineqlin[int(nlt+ngt+nbx+(arange(1,nbx+1).reshape(1,-1))-1)]
    mu_u[int(ieq[int(ku-1)]-1)]=lam.eqlin[int(ku-1)]
    mu_u[int(ilt-1)]=lam.ineqlin[1-1:nlt+1-1]
    mu_u[int(ibx-1)]=lam.ineqlin[int(nlt+ngt+(arange(1,nbx+1).reshape(1,-1))-1)]
    lambda_=struct('mu_l',mu_l,'mu_u',mu_u,'lower',lam.lower,'upper',lam.upper)
    return x,f,eflag,output,lambda_
def qps_matpower(H,c,A,l,u,xmin,xmax,x0,opt,**kwargs):
    opt=_copy(opt)
    if nargin()==1 and isstruct(H):
        p=H
        if isfield(p,'opt'):
            opt=p.opt
        else:
            opt=m_array()
        if isfield(p,'x0'):
            x0=p.x0
        else:
            x0=m_array()
        if isfield(p,'xmax'):
            xmax=p.xmax
        else:
            xmax=m_array()
        if isfield(p,'xmin'):
            xmin=p.xmin
        else:
            xmin=m_array()
        if isfield(p,'u'):
            u=p.u
        else:
            u=m_array()
        if isfield(p,'l'):
            l=p.l
        else:
            l=m_array()
        if isfield(p,'A'):
            A=p.A
        else:
            A=m_array()
        if isfield(p,'c'):
            c=p.c
        else:
            c=m_array()
        if isfield(p,'H'):
            H=p.H
        else:
            H=m_array()
    else:
        if nargin()<9:
            opt=m_array()
            if nargin()<8:
                x0=m_array()
                if nargin()<7:
                    xmax=m_array()
                    if nargin()<6:
                        xmin=m_array()
    if  not isempty(opt) and isfield(opt,'alg') and  not isempty(opt.alg):
        alg=opt.alg
    else:
        alg=0
    if  not isempty(opt) and isfield(opt,'verbose') and  not isempty(opt.verbose):
        verbose=opt.verbose
    else:
        verbose=0
    if alg==0:
        if have_fcn('cplex'):
            alg=500
        else:
            if have_fcn('mosek'):
                alg=600
            else:
                if have_fcn('gurobi'):
                    alg=700
                else:
                    if have_fcn('bpmpd'):
                        alg=100
                    else:
                        if have_fcn('quadprog'):
                            alg=300
                        else:
                            alg=200
    if 100==alg:
        x,f,eflag,output,lambda_=qps_bpmpd(H,c,A,l,u,xmin,xmax,x0,opt,nargout=5)
        if eflag==-99:
            if verbose:
                fprintf('         Retrying with QPS_MIPS solver ...\\n\\n')
            bpmpd=struct('x',x,'f',f,'eflag',eflag,'output',output,'lambda',lambda_)
            opt.alg=200
            x,f,eflag,output,lambda_=qps_matpower(H,c,A,l,u,xmin,xmax,x0,opt,nargout=5)
            output.bpmpd=bpmpd
    else:
        if [200,250]==alg:
            if  not isempty(opt) and isfield(opt,'mips_opt') and  not isempty(opt.mips_opt):
                mips_opt=opt.mips_opt
            else:
                mips_opt=m_array()
            if  not isempty(opt) and isfield(opt,'max_it') and  not isempty(opt.max_it):
                mips_opt.max_it=opt.max_it
            if alg==200:
                mips_opt.step_control=0
            else:
                mips_opt.step_control=1
            mips_opt.verbose=verbose
            if have_fcn('anon_fcns'):
                solver='qps_mips'
            else:
                solver='qps_mips6'
            x,f,eflag,output,lambda_=feval(solver,H,c,A,l,u,xmin,xmax,x0,mips_opt,nargout=5)
        else:
            if 300==alg:
                x,f,eflag,output,lambda_=qps_ot(H,c,A,l,u,xmin,xmax,x0,opt,nargout=5)
            else:
                if 400==alg:
                    x,f,eflag,output,lambda_=qps_ipopt(H,c,A,l,u,xmin,xmax,x0,opt,nargout=5)
                else:
                    if 500==alg:
                        x,f,eflag,output,lambda_=qps_cplex(H,c,A,l,u,xmin,xmax,x0,opt,nargout=5)
                    else:
                        if 600==alg:
                            x,f,eflag,output,lambda_=qps_mosek(H,c,A,l,u,xmin,xmax,x0,opt,nargout=5)
                        else:
                            if 700==alg:
                                x,f,eflag,output,lambda_=qps_gurobi(H,c,A,l,u,xmin,xmax,x0,opt,nargout=5)
                            else:
                                error('qps_matpower: %d is not a valid algorithm code',alg)
    if  not isfield(output,'alg') or isempty(output.alg):
        output.alg=alg
    return x,f,eflag,output,lambda_
def qps_mips6(H,c,A,l,u,xmin,xmax,x0,opt,**kwargs):
    if nargin()==1 and isstruct(H):
        p=_copy(H)
    else:
        p=struct('H',H,'c',c,'A',A,'l',l,'u',u)
        if nargin()>5:
            p.xmin=xmin
            if nargin()>6:
                p.xmax=xmax
                if nargin()>7:
                    p.x0=x0
                    if nargin()>8:
                        p.opt=opt
    if  not isfield(p,'H') or isempty(p.H) or  not any(any(p.H)):
        if ( not isfield(p,'A') or isempty(p.A)) and ( not isfield(p,'xmin') or isempty(p.xmin)) and ( not isfield(p,'xmax') or isempty(p.xmax)):
            error('qps_mips6: LP problem must include constraints or variable bounds')
        else:
            if isfield(p,'A') and  not isempty(p.A):
                nx=size(p.A,2)
            else:
                if isfield(p,'xmin') and  not isempty(p.xmin):
                    nx=length(p.xmin)
                else:
                    nx=length(p.xmax)
        p.H=sparse(nx,nx)
    else:
        nx=size(p.H,1)
    if  not isfield(p,'c') or isempty(p.c):
        p.c=zeros(nx,1)
    if  not isfield(p,'x0') or isempty(p.x0):
        p.x0=zeros(nx,1)
    p.f_fcn=qp_f()
    x,f,eflag,output,lambda_=mips6(p,nargout=5)
    return x,f,eflag,output,lambda_
def qp_f(x,p,**kwargs):
    f=0.5*x.T*p.H*x+p.c.T*x
    if nargout()>1:
        df=p.H*x+p.c
        if nargout()>2:
            d2f=p.H
    return f,df,d2f
def qps_mips(H,c,A,l,u,xmin,xmax,x0,opt,**kwargs):
    if nargin()==1 and isstruct(H):
        p=_copy(H)
    else:
        p=struct('H',H,'c',c,'A',A,'l',l,'u',u)
        if nargin()>5:
            p.xmin=xmin
            if nargin()>6:
                p.xmax=xmax
                if nargin()>7:
                    p.x0=x0
                    if nargin()>8:
                        p.opt=opt
    if  not isfield(p,'H') or isempty(p.H) or  not any(any(p.H)):
        if ( not isfield(p,'A') or isempty(p.A)) and ( not isfield(p,'xmin') or isempty(p.xmin)) and ( not isfield(p,'xmax') or isempty(p.xmax)):
            error('qps_mips: LP problem must include constraints or variable bounds')
        else:
            if isfield(p,'A') and  not isempty(p.A):
                nx=size(p.A,2)
            else:
                if isfield(p,'xmin') and  not isempty(p.xmin):
                    nx=length(p.xmin)
                else:
                    nx=length(p.xmax)
        p.H=sparse(nx,nx)
    else:
        nx=size(p.H,1)
    if  not isfield(p,'c') or isempty(p.c):
        p.c=zeros(nx,1)
    if  not isfield(p,'x0') or isempty(p.x0):
        p.x0=zeros(nx,1)
    p.f_fcn=lambda x: qp_f(x(),p.H,p.c)
    x,f,eflag,output,lambda_=mips(p,nargout=5)
    return x,f,eflag,output,lambda_
def qp_f(x,H,c,**kwargs):
    f=0.5*x.T*H*x+c.T*x
    if nargout()>1:
        df=H*x+c
        if nargout()>2:
            d2f=H
    return f,df,d2f
def qps_ot(H,c,A,l,u,xmin,xmax,x0,opt,**kwargs):
    if nargin()==1 and isstruct(H):
        p=H
        if isfield(p,'opt'):
            opt=p.opt
        else:
            opt=m_array()
        if isfield(p,'x0'):
            x0=p.x0
        else:
            x0=m_array()
        if isfield(p,'xmax'):
            xmax=p.xmax
        else:
            xmax=m_array()
        if isfield(p,'xmin'):
            xmin=p.xmin
        else:
            xmin=m_array()
        if isfield(p,'u'):
            u=p.u
        else:
            u=m_array()
        if isfield(p,'l'):
            l=p.l
        else:
            l=m_array()
        if isfield(p,'A'):
            A=p.A
        else:
            A=m_array()
        if isfield(p,'c'):
            c=p.c
        else:
            c=m_array()
        if isfield(p,'H'):
            H=p.H
        else:
            H=m_array()
    else:
        if nargin()<9:
            opt=m_array()
            if nargin()<8:
                x0=m_array()
                if nargin()<7:
                    xmax=m_array()
                    if nargin()<6:
                        xmin=m_array()
    if isempty(H) or  not any(any(H)):
        if isempty(A) and isempty(xmin) and isempty(xmax):
            error('qps_ot: LP problem must include constraints or variable bounds')
        else:
            if  not isempty(A):
                nx=size(A,2)
            else:
                if  not isempty(xmin):
                    nx=length(xmin)
                else:
                    nx=length(xmax)
    else:
        nx=size(H,1)
    if isempty(c):
        c=zeros(nx,1)
    if  not isempty(A) and (isempty(l) or all(l==-Inf())) and (isempty(u) or all(u==Inf())):
        A=sparse(0,nx)
    nA=size(A,1)
    if isempty(u):
        u=Inf()*ones(nA,1)
    if isempty(l):
        l=-Inf()*ones(nA,1)
    if isempty(xmin):
        xmin=-Inf()*ones(nx,1)
    if isempty(xmax):
        xmax=Inf()*ones(nx,1)
    if isempty(x0):
        x0=zeros(nx,1)
    if  not isempty(opt) and isfield(opt,'verbose') and  not isempty(opt.verbose):
        verbose=opt.verbose
    else:
        verbose=0
    if  not isempty(opt) and isfield(opt,'max_it') and  not isempty(opt.max_it):
        max_it=opt.max_it
    else:
        max_it=0
    ieq=find(abs(u-l)<=eps())
    igt=find(u>=10000000000.0&l>-10000000000.0)
    ilt=find(l<=-10000000000.0&u<10000000000.0)
    ibx=find((abs(u-l)>eps())&(u<10000000000.0)&(l>-10000000000.0))
    Ae=A[ieq-1,:]
    be=u[int(ieq-1)]
    Ai=m_array([[A[ilt-1,:]],[-A[igt-1,:]],[A[ibx-1,:]],[-A[ibx-1,:]]]).reshape(1,-1)
    bi=m_array([[u[int(ilt-1)]],[-l[int(igt-1)]],[u[int(ibx-1)]],[-l[int(ibx-1)]]]).reshape(1,-1)
    nlt=length(ilt)
    ngt=length(igt)
    nbx=length(ibx)
    if  not isempty(opt) and isfield(opt,'ot_opt') and  not isempty(opt.ot_opt):
        ot_opt=opt.ot_opt
    else:
        if isempty(H) or  not any(any(H)):
            ot_opt=optimset('linprog')
        else:
            ot_opt=optimset('quadprog')
            if have_fcn('quadprog_ls'):
                ot_opt=optimset(ot_opt,'Algorithm','interior-point-convex')
            else:
                ot_opt=optimset(ot_opt,'LargeScale','off')
    if max_it:
        ot_opt=optimset(ot_opt,'MaxIter',max_it)
    if verbose>1:
        ot_opt=optimset(ot_opt,'Display','iter')
    else:
        if verbose==1:
            ot_opt=optimset(ot_opt,'Display','final')
        else:
            ot_opt=optimset(ot_opt,'Display','off')
    if isempty(H) or  not any(any(H)):
        x,f,eflag,output,lam=linprog(c,Ai,bi,Ae,be,xmin,xmax,x0,ot_opt,nargout=5)
    else:
        x,f,eflag,output,lam=quadprog(H,c,Ai,bi,Ae,be,xmin,xmax,x0,ot_opt,nargout=5)
    kl=find(lam.eqlin<0)
    ku=find(lam.eqlin>0)
    mu_l=zeros(nA,1)
    mu_l[int(ieq[int(kl-1)]-1)]=-lam.eqlin[int(kl-1)]
    mu_l[int(igt-1)]=lam.ineqlin[int(nlt+(arange(1,ngt+1).reshape(1,-1))-1)]
    mu_l[int(ibx-1)]=lam.ineqlin[int(nlt+ngt+nbx+(arange(1,nbx+1).reshape(1,-1))-1)]
    mu_u=zeros(nA,1)
    mu_u[int(ieq[int(ku-1)]-1)]=lam.eqlin[int(ku-1)]
    mu_u[int(ilt-1)]=lam.ineqlin[1-1:nlt+1-1]
    mu_u[int(ibx-1)]=lam.ineqlin[int(nlt+ngt+(arange(1,nbx+1).reshape(1,-1))-1)]
    lambda_=struct('mu_l',mu_l,'mu_u',mu_u,'lower',lam.lower[1-1:nx+1-1],'upper',lam.upper[1-1:nx+1-1])
    return x,f,eflag,output,lambda_
def runopf(casedata,mpopt,fname,solvedcase,**kwargs):
    if nargin()<4:
        solvedcase=''
        if nargin()<3:
            fname=''
            if nargin()<2:
                mpopt=mpoption()
                if nargin()<1:
                    casedata='case9'
    r,success=opf(casedata,mpopt,nargout=2)
    if fname:
        fd,msg=fopen(fname,'at',nargout=2)
        if fd==-1:
            error(msg)
        else:
            printpf(r,fd,mpopt)
            fclose(fd)
    printpf(r,1,mpopt)
    if solvedcase:
        savecase(solvedcase,r)
    if nargout()==1 or nargout()==2:
        MVAbase=r
        bus=success
    else:
        if nargout()>2:
            MVAbase,bus,gen,gencost,branch,f,et=deal(r.baseMVA,r.bus,r.gen,r.gencost,r.branch,r.f,r.et,nargout=7)
    return MVAbase,bus,gen,gencost,branch,f,success,et
def runpf(casedata,mpopt,fname,solvedcase,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    if nargin()<4:
        solvedcase=''
        if nargin()<3:
            fname=''
            if nargin()<2:
                mpopt=mpoption()
                if nargin()<1:
                    casedata='case9'
    verbose=mpopt[int(31-1)]
    qlim=mpopt[int(6-1)]
    dc=mpopt[int(10-1)]
    mpc=loadcase(casedata)
    if size(mpc.branch,2)<QT:
        mpc.branch=m_array([mpc.branch,zeros(size(mpc.branch,1),QT-size(mpc.branch,2))]).reshape(1,-1)
    mpc=ext2int(mpc)
    baseMVA,bus,gen,branch=deal(mpc.baseMVA,mpc.bus,mpc.gen,mpc.branch,nargout=4)
    ref,pv,pq=bustypes(bus,gen,nargout=3)
    on=find(gen[:,GEN_STATUS-1]>0)
    gbus=gen[on-1,GEN_BUS-1]
    t0=clock()
    if verbose>0:
        v=mpver('all')
        fprintf('\\nMATPOWER Version %s, %s',v.Version,v.Date)
    if dc:
        if verbose>0:
            fprintf(' -- DC Power Flow\\n')
        Va0=bus[:,VA-1]*(pi()/180)
        B,Bf,Pbusinj,Pfinj=makeBdc(baseMVA,bus,branch,nargout=4)
        Pbus=real(makeSbus(baseMVA,bus,gen))-Pbusinj-bus[:,GS-1]/baseMVA
        Va=dcpf(B,Pbus,Va0,ref,pv,pq)
        branch[:,m_array([QF,QT]).reshape(1,-1)-1]=zeros(size(branch,1),2)
        branch[:,PF-1]=(Bf*Va+Pfinj)*baseMVA
        branch[:,PT-1]=-branch[:,PF-1]
        bus[:,VM-1]=ones(size(bus,1),1)
        bus[:,VA-1]=Va*(180/pi())
        refgen=zeros(size(ref))
        for k in arange(1,length(ref)+1).reshape(1,-1).flat:
            temp=find(gbus==ref[int(k-1)])
            refgen[int(k-1)]=on[int(temp[int(1-1)]-1)]
        gen[refgen-1,PG-1]=gen[refgen-1,PG-1]+(B[ref-1,:]*Va-Pbus[int(ref-1)])*baseMVA
        success=1
    else:
        alg=mpopt[int(1-1)]
        if verbose>0:
            if alg==1:
                solver='Newton'
            else:
                if alg==2:
                    solver='fast-decoupled, XB'
                else:
                    if alg==3:
                        solver='fast-decoupled, BX'
                    else:
                        if alg==4:
                            solver='Gauss-Seidel'
                        else:
                            solver='unknown'
            fprintf(' -- AC Power Flow (%s)\\n',solver)
        V0=bus[:,VM-1]*exp(sqrt(-1)*pi()/180*bus[:,VA-1])
        V0[int(gbus-1)]=gen[on-1,VG-1]/abs(V0[int(gbus-1)])*V0[int(gbus-1)]
        if qlim:
            ref0=ref
            Varef0=bus[ref0-1,VA-1]
            limited=m_array()
            fixedQg=zeros(size(gen,1),1)
        repeat=1
        while (repeat):
            Ybus,Yf,Yt=makeYbus(baseMVA,bus,branch,nargout=3)
            Sbus=makeSbus(baseMVA,bus,gen)
            alg=mpopt[int(1-1)]
            if alg==1:
                V,success,iterations=newtonpf(Ybus,Sbus,V0,ref,pv,pq,mpopt,nargout=3)
            else:
                if alg==2 or alg==3:
                    Bp,Bpp=makeB(baseMVA,bus,branch,alg,nargout=2)
                    V,success,iterations=fdpf(Ybus,Sbus,V0,Bp,Bpp,ref,pv,pq,mpopt,nargout=3)
                else:
                    if alg==4:
                        V,success,iterations=gausspf(Ybus,Sbus,V0,ref,pv,pq,mpopt,nargout=3)
                    else:
                        error("Only Newton's method, fast-decoupled, and Gauss-Seidel power flow algorithms currently implemented.")
            bus,gen,branch=pfsoln(baseMVA,bus,gen,branch,Ybus,Yf,Yt,V,ref,pv,pq,nargout=3)
            if qlim:
                mx=find(gen[:,GEN_STATUS-1]>0&gen[:,QG-1]>gen[:,QMAX-1])
                mn=find(gen[:,GEN_STATUS-1]>0&gen[:,QG-1]<gen[:,QMIN-1])
                if  not isempty(mx) or  not isempty(mn):
                    if isempty(pv):
                        if verbose:
                            if  not isempty(mx):
                                fprintf('Gen %d (only one left) exceeds upper Q limit : INFEASIBLE PROBLEM\\n',mx)
                            else:
                                fprintf('Gen %d (only one left) exceeds lower Q limit : INFEASIBLE PROBLEM\\n',mn)
                        success=0
                        break
                    if qlim==2:
                        junk,k=max(m_array([[gen[mx-1,QG-1]-gen[mx-1,QMAX-1]],[gen[mn-1,QMIN-1]-gen[mn-1,QG-1]]]).reshape(1,-1),nargout=2)
                        if k>length(mx):
                            mn=mn[int(k-length(mx)-1)]
                            mx=m_array()
                        else:
                            mx=mx[int(k-1)]
                            mn=m_array()
                    if verbose and  not isempty(mx):
                        fprintf('Gen %d at upper Q limit, converting to PQ bus\\n',mx)
                    if verbose and  not isempty(mn):
                        fprintf('Gen %d at lower Q limit, converting to PQ bus\\n',mn)
                    fixedQg[int(mx-1)]=gen[mx-1,QMAX-1]
                    fixedQg[int(mn-1)]=gen[mn-1,QMIN-1]
                    mx=m_array([[mx],[mn]]).reshape(1,-1)
                    gen[mx-1,QG-1]=fixedQg[int(mx-1)]
                    gen[mx-1,GEN_STATUS-1]=0
                    for i in arange(1,length(mx)+1).reshape(1,-1).flat:
                        bi=gen[mx[int(i-1)]-1,GEN_BUS-1]
                        bus[bi-1,m_array([PD,QD]).reshape(1,-1)-1]=bus[bi-1,m_array([PD,QD]).reshape(1,-1)-1]-gen[mx[int(i-1)]-1,m_array([PG,QG]).reshape(1,-1)-1]
                    if length(ref)>1 and any(bus[gen[mx-1,GEN_BUS-1]-1,BUS_TYPE-1]==REF):
                        error('Sorry, MATPOWER cannot enforce Q limits for slack buses in systems with multiple slacks.')
                    bus[gen[mx-1,GEN_BUS-1]-1,BUS_TYPE-1]=PQ
                    ref_temp=ref
                    ref,pv,pq=bustypes(bus,gen,nargout=3)
                    if verbose and ref!=ref_temp:
                        fprintf('Bus %d is new slack bus\\n',ref)
                    limited=m_array([[limited],[mx]]).reshape(1,-1)
                else:
                    repeat=0
            else:
                repeat=0
        if qlim and  not isempty(limited):
            gen[limited-1,QG-1]=fixedQg[int(limited-1)]
            for i in arange(1,length(limited)+1).reshape(1,-1).flat:
                bi=gen[limited[int(i-1)]-1,GEN_BUS-1]
                bus[bi-1,m_array([PD,QD]).reshape(1,-1)-1]=bus[bi-1,m_array([PD,QD]).reshape(1,-1)-1]+gen[limited[int(i-1)]-1,m_array([PG,QG]).reshape(1,-1)-1]
            gen[limited-1,GEN_STATUS-1]=1
            if ref!=ref0:
                bus[:,VA-1]=bus[:,VA-1]-bus[ref0-1,VA-1]+Varef0
    mpc.et=etime(clock(),t0)
    mpc.success=success
    mpc.bus,mpc.gen,mpc.branch=deal(bus,gen,branch,nargout=3)
    results=int2ext(mpc)
    if  not isempty(results.order.gen.status.off):
        results.gen[results.order.gen.status.off-1,m_array([PG,QG]).reshape(1,-1)-1]=0
    if  not isempty(results.order.branch.status.off):
        results.branch[results.order.branch.status.off-1,m_array([PF,QF,PT,QT]).reshape(1,-1)-1]=0
    if fname:
        fd,msg=fopen(fname,'at',nargout=2)
        if fd==-1:
            error(msg)
        else:
            printpf(results,fd,mpopt)
            fclose(fd)
    printpf(results,1,mpopt)
    if solvedcase:
        savecase(solvedcase,results)
    if nargout()==1 or nargout()==2:
        MVAbase=results
        bus=success
    else:
        if nargout()>2:
            MVAbase,bus,gen,branch,et=deal(results.baseMVA,results.bus,results.gen,results.branch,results.et,nargout=5)
    return MVAbase,bus,gen,branch,success,et
def runuopf(casedata,mpopt,fname,solvedcase,**kwargs):
    if nargin()<4:
        solvedcase=''
        if nargin()<3:
            fname=''
            if nargin()<2:
                mpopt=mpoption()
                if nargin()<1:
                    casedata='case9'
    r,success=uopf(casedata,mpopt,nargout=2)
    if fname:
        fd,msg=fopen(fname,'at',nargout=2)
        if fd==-1:
            error(msg)
        else:
            printpf(r,fd,mpopt)
            fclose(fd)
    printpf(r,1,mpopt)
    if solvedcase:
        savecase(solvedcase,r)
    if nargout()==1 or nargout()==2:
        MVAbase=r
        bus=success
    else:
        if nargout()>2:
            MVAbase,bus,gen,gencost,branch,f,et=deal(r.baseMVA,r.bus,r.gen,r.gencost,r.branch,r.f,r.et,nargout=7)
    return MVAbase,bus,gen,gencost,branch,f,success,et
def run_userfcn(userfcn,stage,varargin,**kwargs):
    rv=varargin[1-1]
    if  not isempty(userfcn) and isfield(userfcn,stage):
        for k in arange(1,length(getfield(userfcn,stage))+1).reshape(1,-1).flat:
            if isfield(getfield(userfcn,stage)[int(k-1)],'args'):
                args=getfield(userfcn,stage)[int(k-1)].args
            else:
                args=m_array()
            if ['ext2int','formulation','int2ext']==stage:
                rv=feval(getfield(userfcn,stage)[int(k-1)].fcn,rv,args)
            else:
                if ['printpf','savecase']==stage:
                    rv=feval(getfield(userfcn,stage)[int(k-1)].fcn,rv,varargin[2-1],varargin[3-1],args)
    return rv
def print_sparse(fd,varname,A,**kwargs):
    i,j,s=find(A,nargout=3)
    m,n=size(A,nargout=2)
    if isempty(s):
        fprintf(fd,'%s = sparse(%d, %d);\\n',varname,m,n)
    else:
        fprintf(fd,'ijs = [\\n')
        if m==1:
            fprintf(fd,'\\t%d\\t%d\\t%.9g;\\n',m_array([[i],[j],[s]]).reshape(1,-1))
        else:
            fprintf(fd,'\\t%d\\t%d\\t%.9g;\\n',m_array([i,j,s]).reshape(1,-1).T)
        fprintf(fd,'];\\n')
        fprintf(fd,'%s = sparse(ijs(:, 1), ijs(:, 2), ijs(:, 3), %d, %d);\\n',varname,m,n)
    return 
def scale_load(load,bus,gen,load_zone,opt,**kwargs):
    bus=_copy(bus)
    gen=_copy(gen)
    opt=_copy(opt)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN=idx_gen(nargout=14)
    nb=size(bus,1)
    if nargin()<5:
        opt=struct()
        if nargin()<4:
            load_zone=m_array()
            if nargin()<3:
                gen=m_array()
    if isempty(gen):
        opt.which='FIXED'
    if  not isfield(opt,'pq'):
        opt.pq='PQ'
    if  not isfield(opt,'which'):
        opt.which='BOTH'
    if  not isfield(opt,'scale'):
        opt.scale='FACTOR'
    if  not strcmp(opt.pq,'P') and  not strcmp(opt.pq,'PQ'):
        error("scale_load: opt.pq must equal 'PQ' or 'P'")
    if opt.which[int(1-1)]!='F' and opt.which[int(1-1)]!='D' and opt.which[int(1-1)]!='B':
        error("scale_load: opt.which should be 'FIXED', 'DISPATCHABLE' or 'BOTH'")
    if opt.scale[int(1-1)]!='F' and opt.scale[int(1-1)]!='Q':
        error("scale_load: opt.scale should be 'FACTOR' or 'QUANTITY'")
    if isempty(gen) and opt.which[int(1-1)]!='F':
        error('scale_load: need gen matrix to scale dispatchable loads')
    if  not isempty(gen):
        ng=size(gen,1)
        is_ld=isload(gen)&gen[:,GEN_STATUS-1]>0
        ld=find(is_ld)
        i2e=bus[:,BUS_I-1]
        e2i=sparse(max(i2e),1)
        e2i[int(i2e-1)]=(arange(1,nb+1).reshape(1,-1)).T
        Cld=sparse(e2i[int(gen[:,GEN_BUS-1]-1)],(arange(1,ng+1).reshape(1,-1)).T,is_ld,nb,ng)
    else:
        ng=m_array()
        ld=m_array()
    if isempty(load_zone):
        if length(load)==1:
            load_zone=zeros(nb,1)
            load_zone[int(bus[:,PD-1]!=0|bus[:,QD-1]!=0)]=1
            if  not isempty(gen):
                load_zone[int(e2i[int(gen[ld-1,GEN_BUS-1]-1)]-1)]=1
        else:
            load_zone=bus[:,BUS_AREA-1]
    if max(load_zone)>length(load):
        error('scale_load: load vector must have a value for each load zone specified')
    scale=_copy(load)
    Pdd=zeros(nb,1)
    if opt.scale[int(1-1)]=='Q':
        if  not isempty(gen):
            Pdd=-Cld*gen[:,PMIN-1]
        for k in arange(1,length(load)+1).reshape(1,-1).flat:
            idx=find(load_zone==k)
            fixed=sum(bus[idx-1,PD-1])
            dispatchable=sum(Pdd[int(idx-1)])
            total=fixed+dispatchable
            if opt.which[int(1-1)]=='B':
                if total!=0:
                    scale[int(k-1)]=load[int(k-1)]/total
                else:
                    if load[int(k-1)]==total:
                        scale[int(k-1)]=1
                    else:
                        error('scale_load: impossible to make zone %d load equal %g by scaling non-existent loads',k,load[int(k-1)])
            else:
                if opt.which[int(1-1)]=='F':
                    if fixed!=0:
                        scale[int(k-1)]=(load[int(k-1)]-dispatchable)/fixed
                    else:
                        if load[int(k-1)]==dispatchable:
                            scale[int(k-1)]=1
                        else:
                            error('scale_load: impossible to make zone %d load equal %g by scaling non-existent fixed load',k,load[int(k-1)])
                else:
                    if opt.which[int(1-1)]=='D':
                        if dispatchable!=0:
                            scale[int(k-1)]=(load[int(k-1)]-fixed)/dispatchable
                        else:
                            if load[int(k-1)]==fixed:
                                scale[int(k-1)]=1
                            else:
                                error('scale_load: impossible to make zone %d load equal %g by scaling non-existent dispatchable load',k,load[int(k-1)])
    if opt.which[int(1-1)]!='D':
        for k in arange(1,length(scale)+1).reshape(1,-1).flat:
            idx=find(load_zone==k)
            bus[idx-1,PD-1]=bus[idx-1,PD-1]*scale[int(k-1)]
            if strcmp(opt.pq,'PQ'):
                bus[idx-1,QD-1]=bus[idx-1,QD-1]*scale[int(k-1)]
    if opt.which[int(1-1)]!='F':
        for k in arange(1,length(scale)+1).reshape(1,-1).flat:
            idx=find(load_zone==k)
            junk,i,junk2=intersect(e2i[int(gen[ld-1,GEN_BUS-1]-1)],idx,nargout=3)
            ig=ld[int(i-1)]
            gen[ig-1,m_array([PG,PMIN]).reshape(1,-1)-1]=gen[ig-1,m_array([PG,PMIN]).reshape(1,-1)-1]*scale[int(k-1)]
            if strcmp(opt.pq,'PQ'):
                gen[ig-1,m_array([QG,QMIN,QMAX]).reshape(1,-1)-1]=gen[ig-1,m_array([QG,QMIN,QMAX]).reshape(1,-1)-1]*scale[int(k-1)]
    return bus,gen
def toggle_dcline(mpc,on_off,**kwargs):
    if strcmp(on_off,'on'):
        c=idx_dcline()
        if  not isfield(mpc,'dcline') or size(mpc.dcline,2)<c.LOSS1:
            error("toggle_dcline: case must contain a 'dcline' field, an ndc x %d matrix.",c.LOSS1)
        if isfield(mpc,'dclinecost') and size(mpc.dcline,1)!=size(mpc.dclinecost,1):
            error("toggle_dcline: number of rows in 'dcline' field (%d) and 'dclinecost' field (%d) do not match.",size(mpc.dcline,1),size(mpc.dclinecost,1))
        mpc=add_userfcn(mpc,'ext2int',userfcn_dcline_ext2int())
        mpc=add_userfcn(mpc,'formulation',userfcn_dcline_formulation())
        mpc=add_userfcn(mpc,'int2ext',userfcn_dcline_int2ext())
        mpc=add_userfcn(mpc,'printpf',userfcn_dcline_printpf())
        mpc=add_userfcn(mpc,'savecase',userfcn_dcline_savecase())
    else:
        if strcmp(on_off,'off'):
            mpc=remove_userfcn(mpc,'savecase',userfcn_dcline_savecase())
            mpc=remove_userfcn(mpc,'printpf',userfcn_dcline_printpf())
            mpc=remove_userfcn(mpc,'int2ext',userfcn_dcline_int2ext())
            mpc=remove_userfcn(mpc,'formulation',userfcn_dcline_formulation())
            mpc=remove_userfcn(mpc,'ext2int',userfcn_dcline_ext2int())
        else:
            error("toggle_dcline: 2nd argument must be either 'on' or 'off'")
    return mpc
def userfcn_dcline_ext2int(mpc,args,**kwargs):
    mpc=_copy(mpc)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    c=idx_dcline()
    if isfield(mpc,'dclinecost'):
        havecost=1
    else:
        havecost=0
    mpc.order.ext.dcline=mpc.dcline
    if havecost:
        mpc.order.ext.dclinecost=mpc.dclinecost
    mpc.order.dcline.status.on=find(mpc.dcline[:,c.BR_STATUS-1]>0)
    mpc.order.dcline.status.off=find(mpc.dcline[:,c.BR_STATUS-1]<=0)
    dc=mpc.dcline[mpc.order.dcline.status.on-1,:]
    if havecost:
        dcc=mpc.dclinecost[mpc.order.dcline.status.on-1,:]
        mpc.dclinecost=dcc
    ndc=size(dc,1)
    o=mpc.order
    dc[:,c.F_BUS-1]=o.bus.e2i[int(dc[:,c.F_BUS-1]-1)]
    dc[:,c.T_BUS-1]=o.bus.e2i[int(dc[:,c.T_BUS-1]-1)]
    mpc.dcline=dc
    dc[:,c.PT-1]=dc[:,c.PF-1]-(dc[:,c.LOSS0-1]+dc[:,c.LOSS1-1]*dc[:,c.PF-1])
    fg=zeros(ndc,size(mpc.gen,2))
    fg[:,MBASE-1]=100
    fg[:,GEN_STATUS-1]=dc[:,c.BR_STATUS-1]
    fg[:,PMIN-1]=-Inf()
    fg[:,PMAX-1]=Inf()
    tg=_copy(fg)
    fg[:,GEN_BUS-1]=dc[:,c.F_BUS-1]
    tg[:,GEN_BUS-1]=dc[:,c.T_BUS-1]
    fg[:,PG-1]=-dc[:,c.PF-1]
    tg[:,PG-1]=dc[:,c.PT-1]
    fg[:,QG-1]=dc[:,c.QF-1]
    tg[:,QG-1]=dc[:,c.QT-1]
    fg[:,VG-1]=dc[:,c.VF-1]
    tg[:,VG-1]=dc[:,c.VT-1]
    k=find(dc[:,c.PMIN-1]>=0)
    if  not isempty(k):
        fg[k-1,PMAX-1]=-dc[k-1,c.PMIN-1]
    k=find(dc[:,c.PMAX-1]>=0)
    if  not isempty(k):
        fg[k-1,PMIN-1]=-dc[k-1,c.PMAX-1]
    k=find(dc[:,c.PMIN-1]<0)
    if  not isempty(k):
        tg[k-1,PMIN-1]=dc[k-1,c.PMIN-1]
    k=find(dc[:,c.PMAX-1]<0)
    if  not isempty(k):
        tg[k-1,PMAX-1]=dc[k-1,c.PMAX-1]
    fg[:,QMIN-1]=dc[:,c.QMINF-1]
    fg[:,QMAX-1]=dc[:,c.QMAXF-1]
    tg[:,QMIN-1]=dc[:,c.QMINT-1]
    tg[:,QMAX-1]=dc[:,c.QMAXT-1]
    fg[isload(fg)-1,PMAX-1]=-1e-06
    tg[isload(tg)-1,PMAX-1]=-1e-06
    refbus=find(mpc.bus[:,BUS_TYPE-1]==REF)
    mpc.bus[dc[:,c.F_BUS-1]-1,BUS_TYPE-1]=PV
    mpc.bus[dc[:,c.T_BUS-1]-1,BUS_TYPE-1]=PV
    mpc.bus[refbus-1,BUS_TYPE-1]=REF
    mpc.gen=m_array([[mpc.gen],[fg],[tg]]).reshape(1,-1)
    if isfield(mpc,'gencost') and  not isempty(mpc.gencost):
        ngcr,ngcc=size(mpc.gencost,nargout=2)
        if havecost:
            ndccc=size(dcc,2)
            ccc=max(m_array([[ngcc],[ndccc]]).reshape(1,-1))
            if ccc>ngcc:
                mpc.gencost=m_array([mpc.gencost,zeros(ngcr,ccc-ngcc)]).reshape(1,-1)
            for k in arange(1,ndc+1).reshape(1,-1).flat:
                if dcc[k-1,MODEL-1]==POLYNOMIAL:
                    nc=dcc[k-1,NCOST-1]
                    temp=dcc[k-1,NCOST+(arange(1,nc+1).reshape(1,-1))-1]
                    temp[(nc-1)-1:-2:1+1-1]=-temp[(nc-1)-1:-2:1+1-1]
                else:
                    nc=dcc[k-1,NCOST-1]
                    temp=dcc[k-1,NCOST+(arange(1,2*nc+1).reshape(1,-1))-1]
                    xx=-temp[1-1:2:2*nc+1-1]
                    yy=temp[2-1:2:2*nc+1-1]
                    temp[1-1:2:2*nc+1-1]=xx[xx.shape[0]-1:-1:1+1-1]
                    temp[2-1:2:2*nc+1-1]=yy[yy.shape[0]-1:-1:1+1-1]
                padding=zeros(1,ccc-NCOST-length(temp))
                gck=m_array([dcc[k-1,1-1:NCOST+1-1],temp,padding]).reshape(1,-1)
                mpc.gencost=m_array([[mpc.gencost],[gck]]).reshape(1,-1)
            tgc=ones(ndc,1)*m_array([2,0,0,2,zeros(1,ccc-4)]).reshape(1,-1)
            mpc.gencost=m_array([[mpc.gencost],[tgc]]).reshape(1,-1)
        else:
            dcgc=ones(2*ndc,1)*m_array([2,0,0,2,zeros(1,ngcc-4)]).reshape(1,-1)
            mpc.gencost=m_array([[mpc.gencost],[dcgc]]).reshape(1,-1)
    return mpc
def userfcn_dcline_formulation(om,args,**kwargs):
    c=idx_dcline()
    mpc=get_mpc(om)
    dc=mpc.dcline
    ndc=size(dc,1)
    ng=size(mpc.gen,1)-2*ndc
    nL0=-dc[:,c.LOSS0-1]/mpc.baseMVA
    L1=dc[:,c.LOSS1-1]
    Adc=m_array([sparse(ndc,ng),spdiags(1-L1,0,ndc,ndc),speye(ndc,ndc)]).reshape(1,-1)
    om=add_constraints(om,'dcline',Adc,nL0,nL0,['Pg'])
    return om
def userfcn_dcline_int2ext(results,args,**kwargs):
    results=_copy(results)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    c=idx_dcline()
    o=results.order
    k=find(o.ext.dcline[:,c.BR_STATUS-1])
    ndc=length(k)
    ng=size(results.gen,1)-2*ndc
    fg=results.gen[ng+(arange(1,ndc+1).reshape(1,-1))-1,:]
    tg=results.gen[ng+ndc+(arange(1,ndc+1).reshape(1,-1))-1,:]
    results.gen=results.gen[1-1:ng+1-1,:]
    results.gencost=results.gencost[1-1:ng+1-1,:]
    results.dcline[:,c.PF-1]=-fg[:,PG-1]
    results.dcline[:,c.PT-1]=tg[:,PG-1]
    results.dcline[:,c.QF-1]=fg[:,QG-1]
    results.dcline[:,c.QT-1]=tg[:,QG-1]
    results.dcline[:,c.VF-1]=fg[:,VG-1]
    results.dcline[:,c.VT-1]=tg[:,VG-1]
    if size(fg,2)>=MU_QMIN:
        results.dcline[:,c.MU_PMIN-1]=fg[:,MU_PMAX-1]+tg[:,MU_PMIN-1]
        results.dcline[:,c.MU_PMAX-1]=fg[:,MU_PMIN-1]+tg[:,MU_PMAX-1]
        results.dcline[:,c.MU_QMINF-1]=fg[:,MU_QMIN-1]
        results.dcline[:,c.MU_QMAXF-1]=fg[:,MU_QMAX-1]
        results.dcline[:,c.MU_QMINT-1]=tg[:,MU_QMIN-1]
        results.dcline[:,c.MU_QMAXT-1]=tg[:,MU_QMAX-1]
    results.order.int.dcline=results.dcline
    o.ext.dcline[k-1,c.PF-1:c.VT+1-1]=results.dcline[:,c.PF-1:c.VT+1-1]
    if size(results.dcline,2)==c.MU_QMAXT:
        o.ext.dcline[k-1,c.MU_PMIN-1:c.MU_QMAXT+1-1]=results.dcline[:,c.MU_PMIN-1:c.MU_QMAXT+1-1]
    results.dcline=o.ext.dcline
    return results
def userfcn_dcline_printpf(results,fd,mpopt,args,**kwargs):
    c=idx_dcline()
    OUT_ALL=mpopt[int(32-1)]
    OUT_BRANCH=OUT_ALL==1 or (OUT_ALL==-1 and mpopt[int(36-1)])
    if OUT_ALL==-1:
        OUT_ALL_LIM=mpopt[int(38-1)]
    else:
        if OUT_ALL==1:
            OUT_ALL_LIM=2
        else:
            OUT_ALL_LIM=0
    if OUT_ALL_LIM==-1:
        OUT_LINE_LIM=mpopt[int(40-1)]
    else:
        OUT_LINE_LIM=OUT_ALL_LIM
    ctol=mpopt[int(16-1)]
    ptol=0.0001
    dc=results.dcline
    ndc=size(dc,1)
    kk=find(dc[:,c.BR_STATUS-1]!=0)
    if OUT_BRANCH:
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     DC Line Data                                                             |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n Line    From     To        Power Flow           Loss     Reactive Inj (MVAr)')
        fprintf(fd,'\\n   #      Bus     Bus   From (MW)   To (MW)      (MW)       From        To   ')
        fprintf(fd,'\\n------  ------  ------  ---------  ---------  ---------  ---------  ---------')
        loss=0
        for k in arange(1,ndc+1).reshape(1,-1).flat:
            if dc[k-1,c.BR_STATUS-1]:
                fprintf(fd,'\\n%5d%8d%8d%11.2f%11.2f%11.2f%11.2f%11.2f',k,dc[k-1,c.F_BUS-1:c.T_BUS+1-1],dc[k-1,c.PF-1:c.PT+1-1],dc[k-1,c.PF-1]-dc[k-1,c.PT-1],dc[k-1,c.QF-1:c.QT+1-1])
                loss=loss+dc[k-1,c.PF-1]-dc[k-1,c.PT-1]
            else:
                fprintf(fd,'\\n%5d%8d%8d%11s%11s%11s%11s%11s',k,dc[k-1,c.F_BUS-1:c.T_BUS+1-1],'-  ','-  ','-  ','-  ','-  ')
        fprintf(fd,'\\n                                              ---------')
        fprintf(fd,'\\n                                     Total:%11.2f\\n',loss)
    if OUT_LINE_LIM==2 or (OUT_LINE_LIM==1 and (any(dc[kk-1,c.PF-1]>dc[kk-1,c.PMAX-1]-ctol) or any(dc[kk-1,c.MU_PMIN-1]>ptol) or any(dc[kk-1,c.MU_PMAX-1]>ptol))):
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     DC Line Constraints                                                      |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n Line    From     To          Minimum        Actual Flow       Maximum')
        fprintf(fd,'\\n   #      Bus     Bus    Pmin mu     Pmin       (MW)       Pmax      Pmax mu ')
        fprintf(fd,'\\n------  ------  ------  ---------  ---------  ---------  ---------  ---------')
        for k in arange(1,ndc+1).reshape(1,-1).flat:
            if OUT_LINE_LIM==2 or (OUT_LINE_LIM==1 and (dc[k-1,c.PF-1]>dc[k-1,c.PMAX-1]-ctol or dc[k-1,c.MU_PMIN-1]>ptol or dc[k-1,c.MU_PMAX-1]>ptol)):
                if dc[k-1,c.BR_STATUS-1]:
                    fprintf(fd,'\\n%5d%8d%8d',k,dc[k-1,c.F_BUS-1:c.T_BUS+1-1])
                    if dc[k-1,c.MU_PMIN-1]>ptol:
                        fprintf(fd,'%11.3f',dc[k-1,c.MU_PMIN-1])
                    else:
                        fprintf(fd,'%11s','-  ')
                    fprintf(fd,'%11.2f%11.2f%11.2f',dc[k-1,c.PMIN-1],dc[k-1,c.PF-1],dc[k-1,c.PMAX-1])
                    if dc[k-1,c.MU_PMAX-1]>ptol:
                        fprintf(fd,'%11.3f',dc[k-1,c.MU_PMAX-1])
                    else:
                        fprintf(fd,'%11s','-  ')
                else:
                    fprintf(fd,'\\n%5d%8d%8d%11s%11s%11s%11s%11s',k,dc[k-1,c.F_BUS-1:c.T_BUS+1-1],'-  ','-  ','-  ','-  ','-  ')
        fprintf(fd,'\\n')
    return results
def userfcn_dcline_savecase(mpc,fd,prefix,args,**kwargs):
    c=idx_dcline()
    ncols=size(mpc.dcline,2)
    fprintf(fd,'\\n%%%%-----  DC Line Data  -----%%%%\\n')
    if ncols<c.MU_QMAXT:
        fprintf(fd,'%%\\tfbus\\ttbus\\tstatus\\tPf\\tPt\\tQf\\tQt\\tVf\\tVt\\tPmin\\tPmax\\tQminF\\tQmaxF\\tQminT\\tQmaxT\\tloss0\\tloss1\\n')
    else:
        fprintf(fd,'%%\\tfbus\\ttbus\\tstatus\\tPf\\tPt\\tQf\\tQt\\tVf\\tVt\\tPmin\\tPmax\\tQminF\\tQmaxF\\tQminT\\tQmaxT\\tloss0\\tloss1\\tmuPmin\\tmuPmax\\tmuQminF\\tmuQmaxF\\tmuQminT\\tmuQmaxT\\n')
    template='\\t%d\\t%d\\t%d\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g\\t%.9g'
    if ncols==c.MU_QMAXT:
        template=m_array([template,'\\t%.4f\\t%.4f\\t%.4f\\t%.4f\\t%.4f\\t%.4f']).reshape(1,-1)
    template=m_array([template,';\\n']).reshape(1,-1)
    fprintf(fd,'%sdcline = [\\n',prefix)
    fprintf(fd,template,mpc.dcline.T)
    fprintf(fd,'];\\n')
    return mpc
def toggle_iflims(mpc,on_off,**kwargs):
    if strcmp(on_off,'on'):
        if  not isfield(mpc,'if') or  not isstruct(mpc.if) or  not isfield(mpc.if,'map') or  not isfield(mpc.if,'lims'):
            error("toggle_iflims: case must contain an 'if' field, a struct defining 'map' and 'lims'")
        mpc=add_userfcn(mpc,'ext2int',userfcn_iflims_ext2int())
        mpc=add_userfcn(mpc,'formulation',userfcn_iflims_formulation())
        mpc=add_userfcn(mpc,'int2ext',userfcn_iflims_int2ext())
        mpc=add_userfcn(mpc,'printpf',userfcn_iflims_printpf())
        mpc=add_userfcn(mpc,'savecase',userfcn_iflims_savecase())
    else:
        if strcmp(on_off,'off'):
            mpc=remove_userfcn(mpc,'savecase',userfcn_iflims_savecase())
            mpc=remove_userfcn(mpc,'printpf',userfcn_iflims_printpf())
            mpc=remove_userfcn(mpc,'int2ext',userfcn_iflims_int2ext())
            mpc=remove_userfcn(mpc,'formulation',userfcn_iflims_formulation())
            mpc=remove_userfcn(mpc,'ext2int',userfcn_iflims_ext2int())
        else:
            error("toggle_iflims: 2nd argument must be either 'on' or 'off'")
    return mpc
def userfcn_iflims_ext2int(mpc,args,**kwargs):
    mpc=_copy(mpc)
    ifmap=mpc.if.map_
    o=mpc.order
    nl0=size(o.ext.branch,1)
    nl=size(mpc.branch,1)
    mpc.order.ext.ifmap=ifmap
    e2i=zeros(nl0,1)
    e2i[int(o.branch.status.on-1)]=(arange(1,nl+1).reshape(1,-1)).T
    d=sign(ifmap[:,2-1])
    br=abs(ifmap[:,2-1])
    ifmap[:,2-1]=d*e2i[int(br-1)]
    ifmap[ifmap[:,2-1]==0,:]=m_array()
    mpc.if.map_=ifmap
    return mpc
def userfcn_iflims_formulation(om,args,**kwargs):
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    mpc=get_mpc(om)
    baseMVA,bus,branch=deal(mpc.baseMVA,mpc.bus,mpc.branch,nargout=3)
    ifmap=mpc.if.map_
    iflims=mpc.if.lims
    B,Bf,Pbusinj,Pfinj=makeBdc(baseMVA,bus,branch,nargout=4)
    n=size(Bf,2)
    ifidx=unique(iflims[:,1-1])
    nifs=length(ifidx)
    Aif=sparse(nifs,n)
    lif=zeros(nifs,1)
    uif=zeros(nifs,1)
    for k in arange(1,nifs+1).reshape(1,-1).flat:
        br=ifmap[ifmap[:,1-1]==ifidx[int(k-1)],2-1]
        if isempty(br):
            error('userfcn_iflims_formulation: interface %d has no in-service branches',k)
        d=sign(br)
        br=abs(br)
        Ak=sparse(1,n)
        bk=0
        for i in arange(1,length(br)+1).reshape(1,-1).flat:
            Ak=Ak+d[int(i-1)]*Bf[br[int(i-1)]-1,:]
            bk=bk+d[int(i-1)]*Pfinj[int(br[int(i-1)]-1)]
        Aif[k-1,:]=Ak
        lif[int(k-1)]=iflims[k-1,2-1]/baseMVA-bk
        uif[int(k-1)]=iflims[k-1,3-1]/baseMVA-bk
    om=add_constraints(om,'iflims',Aif,lif,uif,['Va'])
    return om
def userfcn_iflims_int2ext(results,args,**kwargs):
    results=_copy(results)
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    ifmap=results.if.map_
    iflims=results.if.lims
    results.if.map_=results.order.ext.ifmap
    ifidx=unique(iflims[:,1-1])
    nifs=length(ifidx)
    results.if.P=zeros(nifs,1)
    for k in arange(1,nifs+1).reshape(1,-1).flat:
        br=ifmap[ifmap[:,1-1]==ifidx[int(k-1)],2-1]
        d=sign(br)
        br=abs(br)
        results.if.P[int(k-1)]=sum(d*results.branch[br-1,PF-1])
    results.if.mu.l=results.lin.mu.l.iflims
    results.if.mu.u=results.lin.mu.u.iflims
    return results
def userfcn_iflims_printpf(results,fd,mpopt,args,**kwargs):
    F_BUS,T_BUS,BR_R,BR_X,BR_B,RATE_A,RATE_B,RATE_C,TAP,SHIFT,BR_STATUS,PF,QF,PT,QT,MU_SF,MU_ST,ANGMIN,ANGMAX,MU_ANGMIN,MU_ANGMAX=idx_brch(nargout=21)
    OUT_ALL=mpopt[int(32-1)]
    ptol=1e-06
    if OUT_ALL!=0:
        iflims=results.if.lims
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     Interface Flow Limits                                                    |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n Interface  Shadow Prc  Lower Lim      Flow      Upper Lim   Shadow Prc')
        fprintf(fd,'\\n     #        ($/MW)       (MW)        (MW)        (MW)       ($/MW)   ')
        fprintf(fd,'\\n----------  ----------  ----------  ----------  ----------  -----------')
        ifidx=unique(iflims[:,1-1])
        nifs=length(ifidx)
        for k in arange(1,nifs+1).reshape(1,-1).flat:
            fprintf(fd,'\\n%6d ',iflims[k-1,1-1])
            if results.if.mu.l[int(k-1)]>ptol:
                fprintf(fd,'%14.3f',results.if.mu.l[int(k-1)])
            else:
                fprintf(fd,'          -   ')
            fprintf(fd,'%12.2f%12.2f%12.2f',iflims[k-1,2-1],results.if.P[int(k-1)],iflims[k-1,3-1])
            if results.if.mu.u[int(k-1)]>ptol:
                fprintf(fd,'%13.3f',results.if.mu.u[int(k-1)])
            else:
                fprintf(fd,'         -     ')
        fprintf(fd,'\\n')
    return results
def userfcn_iflims_savecase(mpc,fd,prefix,args,**kwargs):
    ifmap=mpc.if.map_
    iflims=mpc.if.lims
    fprintf(fd,'\\n%%%%-----  Interface Flow Limit Data  -----%%%%\\n')
    fprintf(fd,'%%%% interface<->branch map data\\n')
    fprintf(fd,'%%\\tifnum\\tbranchidx (negative defines opposite direction)\\n')
    fprintf(fd,'%sif.map = [\\n',prefix)
    fprintf(fd,'\\t%d\\t%d;\\n',ifmap.T)
    fprintf(fd,'];\\n')
    fprintf(fd,'\\n%%%% interface flow limit data (based on DC model)\\n')
    fprintf(fd,'%%%% (lower limit should be negative for opposite direction)\\n')
    fprintf(fd,'%%\\tifnum\\tlower\\tupper\\n')
    fprintf(fd,'%sif.lims = [\\n',prefix)
    fprintf(fd,'\\t%d\\t%g\\t%g;\\n',iflims.T)
    fprintf(fd,'];\\n')
    if isfield(mpc.if,'P'):
        if exist('serialize','file')==2:
            fprintf(fd,'\\n%%%% solved values\\n')
            fprintf(fd,'%sif.P = %s\\n',prefix,serialize(mpc.if.P))
            fprintf(fd,'%sif.mu.l = %s\\n',prefix,serialize(mpc.if.mu.l))
            fprintf(fd,'%sif.mu.u = %s\\n',prefix,serialize(mpc.if.mu.u))
        else:
            url='http://www.mathworks.com/matlabcentral/fileexchange/12063'
            warning('MATPOWER:serialize',"userfcn_iflims_savecase: Cannot save the 'iflims' output fields without the 'serialize' function, which is available as a free download from:\\n<%s>\\n\\n",url)
    return mpc
def toggle_reserves(mpc,on_off,**kwargs):
    if strcmp(on_off,'on'):
        if  not isfield(mpc,'reserves') or  not isstruct(mpc.reserves) or  not isfield(mpc.reserves,'zones') or  not isfield(mpc.reserves,'req') or  not isfield(mpc.reserves,'cost'):
            error("toggle_reserves: case must contain a 'reserves' field, a struct defining 'zones', 'req' and 'cost'")
        mpc=add_userfcn(mpc,'ext2int',userfcn_reserves_ext2int())
        mpc=add_userfcn(mpc,'formulation',userfcn_reserves_formulation())
        mpc=add_userfcn(mpc,'int2ext',userfcn_reserves_int2ext())
        mpc=add_userfcn(mpc,'printpf',userfcn_reserves_printpf())
        mpc=add_userfcn(mpc,'savecase',userfcn_reserves_savecase())
    else:
        if strcmp(on_off,'off'):
            mpc=remove_userfcn(mpc,'savecase',userfcn_reserves_savecase())
            mpc=remove_userfcn(mpc,'printpf',userfcn_reserves_printpf())
            mpc=remove_userfcn(mpc,'int2ext',userfcn_reserves_int2ext())
            mpc=remove_userfcn(mpc,'formulation',userfcn_reserves_formulation())
            mpc=remove_userfcn(mpc,'ext2int',userfcn_reserves_ext2int())
        else:
            error("toggle_reserves: 2nd argument must be either 'on' or 'off'")
    return mpc
def userfcn_reserves_ext2int(mpc,args,**kwargs):
    mpc=_copy(mpc)
    r=mpc.reserves
    o=mpc.order
    ng0=size(o.ext.gen,1)
    nrz=size(r.req,1)
    if nrz>1:
        mpc.reserves.rgens=any(r.zones)
    else:
        mpc.reserves.rgens=r.zones
    igr=find(mpc.reserves.rgens)
    ngr=length(igr)
    if size(r.zones,1)!=nrz:
        error('userfcn_reserves_ext2int: the number of rows in mpc.reserves.req (%d) and mpc.reserves.zones (%d) must match',nrz,size(r.zones,1))
    if size(r.cost,1)!=ng0 and size(r.cost,1)!=ngr:
        error('userfcn_reserves_ext2int: the number of rows in mpc.reserves.cost (%d) must equal the total number of generators (%d) or the number of generators able to provide reserves (%d)',size(r.cost,1),ng0,ngr)
    if isfield(r,'qty') and size(r.qty,1)!=size(r.cost,1):
        error('userfcn_reserves_ext2int: mpc.reserves.cost (%d x 1) and mpc.reserves.qty (%d x 1) must be the same dimension',size(r.cost,1),size(r.qty,1))
    if size(r.cost,1)<ng0:
        mpc.reserves.original.cost=r.cost
        cost=zeros(ng0,1)
        cost[int(igr-1)]=r.cost
        mpc.reserves.cost=cost
        if isfield(r,'qty'):
            mpc.reserves.original.qty=r.qty
            qty=zeros(ng0,1)
            qty[int(igr-1)]=r.qty
            mpc.reserves.qty=qty
    if isfield(r,'qty'):
        mpc=e2i_field(mpc,['reserves','qty'],'gen')
    mpc=e2i_field(mpc,['reserves','cost'],'gen')
    mpc=e2i_field(mpc,['reserves','zones'],'gen',2)
    mpc=e2i_field(mpc,['reserves','rgens'],'gen',2)
    mpc.order.ext.reserves.igr=igr
    mpc.reserves.igr=find(mpc.reserves.rgens)
    return mpc
def userfcn_reserves_formulation(om,args,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    mpc=get_mpc(om)
    r=mpc.reserves
    igr=r.igr
    ngr=length(igr)
    ng=size(mpc.gen,1)
    Rmin=zeros(ngr,1)
    Rmax=Inf()*ones(ngr,1)
    k=find(mpc.gen[igr-1,RAMP_10-1])
    Rmax[int(k-1)]=mpc.gen[igr[int(k-1)]-1,RAMP_10-1]
    if isfield(r,'qty'):
        k=find(r.qty[int(igr-1)]<Rmax)
        Rmax[int(k-1)]=r.qty[int(igr[int(k-1)]-1)]
    Rmax=Rmax/mpc.baseMVA
    I=speye(ngr)
    Ar=m_array([sparse(arange(1,ngr+1).reshape(1,-1),igr,1,ngr,ng),I]).reshape(1,-1)
    ur=mpc.gen[igr-1,PMAX-1]/mpc.baseMVA
    lreq=r.req/mpc.baseMVA
    Cw=r.cost[int(igr-1)]*mpc.baseMVA
    om=add_vars(om,'R',ngr,m_array(),Rmin,Rmax)
    om=add_constraints(om,'Pg_plus_R',Ar,m_array(),ur,['Pg','R'])
    om=add_constraints(om,'Rreq',r.zones[:,igr-1],lreq,m_array(),['R'])
    om=add_costs(om,'Rcost',struct('N',I,'Cw',Cw),['R'])
    return om
def userfcn_reserves_int2ext(results,args,**kwargs):
    r=results.reserves
    igr=r.igr
    ng=size(results.gen,1)
    if isfield(r,'qty'):
        results=i2e_field(results,['reserves','qty'],'gen')
    results=i2e_field(results,['reserves','cost'],'gen')
    results=i2e_field(results,['reserves','zones'],'gen',2)
    results=i2e_field(results,['reserves','rgens'],'gen',2)
    results.order.int.reserves.igr=results.reserves.igr
    results.reserves.igr=results.order.ext.reserves.igr
    r=results.reserves
    o=results.order
    igr0=r.igr
    ng0=size(o.ext.gen,1)
    R0,Rl,Ru=getv(results.om,'R',nargout=3)
    R=zeros(ng,1)
    Rmin=zeros(ng,1)
    Rmax=zeros(ng,1)
    mu_l=zeros(ng,1)
    mu_u=zeros(ng,1)
    mu_Pmax=zeros(ng,1)
    R[int(igr-1)]=results.var.val.R*results.baseMVA
    Rmin[int(igr-1)]=Rl*results.baseMVA
    Rmax[int(igr-1)]=Ru*results.baseMVA
    mu_l[int(igr-1)]=results.var.mu.l.R/results.baseMVA
    mu_u[int(igr-1)]=results.var.mu.u.R/results.baseMVA
    mu_Pmax[int(igr-1)]=results.lin.mu.u.Pg_plus_R/results.baseMVA
    z=zeros(ng0,1)
    results.reserves.R=i2e_data(results,R,z,'gen')
    results.reserves.Rmin=i2e_data(results,Rmin,z,'gen')
    results.reserves.Rmax=i2e_data(results,Rmax,z,'gen')
    results.reserves.mu.l=i2e_data(results,mu_l,z,'gen')
    results.reserves.mu.u=i2e_data(results,mu_u,z,'gen')
    results.reserves.mu.Pmax=i2e_data(results,mu_Pmax,z,'gen')
    results.reserves.prc=z
    for k in igr0.flat:
        iz=find(r.zones[:,k-1])
        results.reserves.prc[int(k-1)]=sum(results.lin.mu.l.Rreq[int(iz-1)])/results.baseMVA
    results.reserves.totalcost=results.cost.Rcost
    if isfield(r,'original'):
        if isfield(r,'qty'):
            results.reserves.qty=r.original.qty
        results.reserves.cost=r.original.cost
        results.reserves=rmfield(results.reserves,'original')
    return results
def userfcn_reserves_printpf(results,fd,mpopt,args,**kwargs):
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    r=results.reserves
    nrz=size(r.req,1)
    OUT_ALL=mpopt[int(32-1)]
    if OUT_ALL!=0:
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     Reserves                                                                 |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n Gen   Bus   Status  Reserves   Price')
        fprintf(fd,'\\n  #     #              (MW)     ($/MW)     Included in Zones ...')
        fprintf(fd,'\\n----  -----  ------  --------  --------   ------------------------')
        for k in r.igr.flat:
            iz=find(r.zones[:,k-1])
            fprintf(fd,'\\n%3d %6d     %2d ',k,results.gen[k-1,GEN_BUS-1],results.gen[k-1,GEN_STATUS-1])
            if results.gen[k-1,GEN_STATUS-1]>0 and abs(results.reserves.R[int(k-1)])>1e-06:
                fprintf(fd,'%10.2f',results.reserves.R[int(k-1)])
            else:
                fprintf(fd,'       -  ')
            fprintf(fd,'%10.2f     ',results.reserves.prc[int(k-1)])
            for i in arange(1,length(iz)+1).reshape(1,-1).flat:
                if i!=1:
                    fprintf(fd,', ')
                fprintf(fd,'%d',iz[int(i-1)])
        fprintf(fd,'\\n                     --------')
        fprintf(fd,'\\n            Total:%10.2f              Total Cost: $%.2f',sum(results.reserves.R[int(r.igr-1)]),results.reserves.totalcost)
        fprintf(fd,'\\n')
        fprintf(fd,'\\nZone  Reserves   Price  ')
        fprintf(fd,'\\n  #     (MW)     ($/MW) ')
        fprintf(fd,'\\n----  --------  --------')
        for k in arange(1,nrz+1).reshape(1,-1).flat:
            iz=find(r.zones[k-1,:])
            fprintf(fd,'\\n%3d%10.2f%10.2f',k,sum(results.reserves.R[int(iz-1)]),results.lin.mu.l.Rreq[int(k-1)]/results.baseMVA)
        fprintf(fd,'\\n')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n|     Reserve Limits                                                           |')
        fprintf(fd,'\\n================================================================================')
        fprintf(fd,'\\n Gen   Bus   Status  Rmin mu     Rmin    Reserves    Rmax    Rmax mu   Pmax mu ')
        fprintf(fd,'\\n  #     #             ($/MW)     (MW)      (MW)      (MW)     ($/MW)    ($/MW) ')
        fprintf(fd,'\\n----  -----  ------  --------  --------  --------  --------  --------  --------')
        for k in r.igr.flat:
            fprintf(fd,'\\n%3d %6d     %2d ',k,results.gen[k-1,GEN_BUS-1],results.gen[k-1,GEN_STATUS-1])
            if results.gen[k-1,GEN_STATUS-1]>0 and results.reserves.mu.l[int(k-1)]>1e-06:
                fprintf(fd,'%10.2f',results.reserves.mu.l[int(k-1)])
            else:
                fprintf(fd,'       -  ')
            fprintf(fd,'%10.2f',results.reserves.Rmin[int(k-1)])
            if results.gen[k-1,GEN_STATUS-1]>0 and abs(results.reserves.R[int(k-1)])>1e-06:
                fprintf(fd,'%10.2f',results.reserves.R[int(k-1)])
            else:
                fprintf(fd,'       -  ')
            fprintf(fd,'%10.2f',results.reserves.Rmax[int(k-1)])
            if results.gen[k-1,GEN_STATUS-1]>0 and results.reserves.mu.u[int(k-1)]>1e-06:
                fprintf(fd,'%10.2f',results.reserves.mu.u[int(k-1)])
            else:
                fprintf(fd,'       -  ')
            if results.gen[k-1,GEN_STATUS-1]>0 and results.reserves.mu.Pmax[int(k-1)]>1e-06:
                fprintf(fd,'%10.2f',results.reserves.mu.Pmax[int(k-1)])
            else:
                fprintf(fd,'       -  ')
        fprintf(fd,'\\n                                         --------')
        fprintf(fd,'\\n                                Total:%10.2f',sum(results.reserves.R[int(r.igr-1)]))
        fprintf(fd,'\\n')
    return results
def userfcn_reserves_savecase(mpc,fd,prefix,args,**kwargs):
    r=mpc.reserves
    fprintf(fd,'\\n%%%%-----  Reserve Data  -----%%%%\\n')
    fprintf(fd,'%%%% reserve zones, element i, j is 1 if gen j is in zone i, 0 otherwise\\n')
    fprintf(fd,'%sreserves.zones = [\\n',prefix)
    template=''
    for i in arange(1,size(r.zones,2)+1).reshape(1,-1).flat:
        template=m_array([template,'\\t%d']).reshape(1,-1)
    template=m_array([template,';\\n']).reshape(1,-1)
    fprintf(fd,template,r.zones.T)
    fprintf(fd,'];\\n')
    fprintf(fd,'\\n%%%% reserve requirements for each zone in MW\\n')
    fprintf(fd,'%sreserves.req = [\\t%g',prefix,r.req[int(1-1)])
    if length(r.req)>1:
        fprintf(fd,';\\t%g',r.req[2-1:r.req.shape[0]+1-1])
    fprintf(fd,'\\t];\\n')
    fprintf(fd,'\\n%%%% reserve costs in $/MW for each gen that belongs to at least 1 zone\\n')
    fprintf(fd,'%%%% (same order as gens, but skipping any gen that does not belong to any zone)\\n')
    fprintf(fd,'%sreserves.cost = [\\t%g',prefix,r.cost[int(1-1)])
    if length(r.cost)>1:
        fprintf(fd,';\\t%g',r.cost[2-1:r.cost.shape[0]+1-1])
    fprintf(fd,'\\t];\\n')
    if isfield(r,'qty'):
        fprintf(fd,'\\n%%%% OPTIONAL max reserve quantities for each gen that belongs to at least 1 zone\\n')
        fprintf(fd,'%%%% (same order as gens, but skipping any gen that does not belong to any zone)\\n')
        fprintf(fd,'%sreserves.qty = [\\t%g',prefix,r.qty[int(1-1)])
        if length(r.qty)>1:
            fprintf(fd,';\\t%g',r.qty[2-1:r.qty.shape[0]+1-1])
        fprintf(fd,'\\t];\\n')
    if isfield(r,'R'):
        if exist('serialize','file')==2:
            fprintf(fd,'\\n%%%% solved values\\n')
            fprintf(fd,'%sreserves.R = %s\\n',prefix,serialize(r.R))
            fprintf(fd,'%sreserves.Rmin = %s\\n',prefix,serialize(r.Rmin))
            fprintf(fd,'%sreserves.Rmax = %s\\n',prefix,serialize(r.Rmax))
            fprintf(fd,'%sreserves.mu.l = %s\\n',prefix,serialize(r.mu.l))
            fprintf(fd,'%sreserves.mu.u = %s\\n',prefix,serialize(r.mu.u))
            fprintf(fd,'%sreserves.prc = %s\\n',prefix,serialize(r.prc))
            fprintf(fd,'%sreserves.totalcost = %s\\n',prefix,serialize(r.totalcost))
        else:
            url='http://www.mathworks.com/matlabcentral/fileexchange/12063'
            warning('MATPOWER:serialize',"userfcn_reserves_savecase: Cannot save the 'reserves' output fields without the 'serialize' function, which is available as a free download from:\\n<%s>\\n\\n",url)
    return mpc
def total_load(bus,gen,load_zone,which_type,**kwargs):
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN=idx_gen(nargout=14)
    nb=size(bus,1)
    if nargin()<4:
        which_type=m_array()
        if nargin()<3:
            load_zone=m_array()
            if nargin()<2:
                gen=m_array()
    if isempty(gen):
        which_type='FIXED'
    if isempty(which_type) and  not isempty(gen):
        which_type='BOTH'
    if which_type[int(1-1)]!='F' and which_type[int(1-1)]!='D' and which_type[int(1-1)]!='B':
        error("total_load: which_type should be 'FIXED', 'DISPATCHABLE' or 'BOTH'")
    want_Q=(nargout()>1)
    want_fixed=(which_type[int(1-1)]=='B' or which_type[int(1-1)]=='F')
    want_disp=(which_type[int(1-1)]=='B' or which_type[int(1-1)]=='D')
    if ischar(load_zone) and strcmp(load_zone,'all'):
        load_zone=ones(nb,1)
    else:
        if isempty(load_zone):
            load_zone=bus[:,BUS_AREA-1]
    nz=max(load_zone)
    if want_fixed:
        Pdf=bus[:,PD-1]
        if want_Q:
            Qdf=bus[:,QD-1]
    else:
        Pdf=zeros(nb,1)
        if want_Q:
            Qdf=zeros(nb,1)
    if want_disp:
        ng=size(gen,1)
        is_ld=isload(gen)&gen[:,GEN_STATUS-1]>0
        ld=find(is_ld)
        i2e=bus[:,BUS_I-1]
        e2i=sparse(max(i2e),1)
        e2i[int(i2e-1)]=(arange(1,nb+1).reshape(1,-1)).T
        Cld=sparse(e2i[int(gen[:,GEN_BUS-1]-1)],(arange(1,ng+1).reshape(1,-1)).T,is_ld,nb,ng)
        Pdd=-Cld*gen[:,PMIN-1]
        if want_Q:
            Q=zeros(ng,1)
            Q[int(ld-1)]=(gen[ld-1,QMIN-1]==0)*gen[ld-1,QMAX-1]+(gen[ld-1,QMAX-1]==0)*gen[ld-1,QMIN-1]
            Qdd=-Cld*Q
    else:
        Pdd=zeros(nb,1)
        if want_Q:
            Qdd=zeros(nb,1)
    Pd=zeros(nz,1)
    if want_Q:
        Qd=zeros(nz,1)
    for k in arange(1,nz+1).reshape(1,-1).flat:
        idx=find(load_zone==k)
        Pd[int(k-1)]=sum(Pdf[int(idx-1)])+sum(Pdd[int(idx-1)])
        if want_Q:
            Qd[int(k-1)]=sum(Qdf[int(idx-1)])+sum(Qdd[int(idx-1)])
    return Pd,Qd
def totcost(gencost,Pg,**kwargs):
    PW_LINEAR,POLYNOMIAL,MODEL,STARTUP,SHUTDOWN,NCOST,COST=idx_cost(nargout=7)
    ng,m=size(gencost,nargout=2)
    totalcost=zeros(ng,size(Pg,2))
    if  not isempty(gencost):
        ipwl=find(gencost[:,MODEL-1]==PW_LINEAR)
        ipol=find(gencost[:,MODEL-1]==POLYNOMIAL)
        if  not isempty(ipwl):
            x=gencost[:,COST-1:2:(m-1)+1-1]
            y=gencost[:,(COST+1)-1:2:m+1-1]
            for i in ipwl.T.flat:
                if gencost[i-1,NCOST-1]>0:
                    j1=arange(1,(gencost[i-1,NCOST-1]-1)+1).reshape(1,-1)
                    j2=arange(2,gencost[i-1,NCOST-1]+1).reshape(1,-1)
                    pp=mkpp(x[i-1,1-1:gencost[i-1,NCOST-1]+1-1].T,m_array([[(y[i-1,j2-1]-y[i-1,j1-1])/(x[i-1,j2-1]-x[i-1,j1-1])],[y[i-1,j1-1]]]).reshape(1,-1).T)
                    totalcost[i-1,:]=ppval(pp,Pg[i-1,:])
        for i in arange(1,size(totalcost,2)+1).reshape(1,-1).flat:
            totalcost[ipol-1,i-1]=polycost(gencost[ipol-1,:],Pg[ipol-1,i-1])
    return totalcost
def uopf(varargin,**kwargs):
    t0=clock()
    mpc,mpopt=opf_args(varargin[:],nargout=2)
    verbose=mpopt[int(31-1)]
    if verbose:
        mpopt=mpoption(mpopt,'VERBOSE',verbose-1)
    PQ,PV,REF,NONE,BUS_I,BUS_TYPE,PD,QD,GS,BS,BUS_AREA,VM,VA,BASE_KV,ZONE,VMAX,VMIN,LAM_P,LAM_Q,MU_VMAX,MU_VMIN=idx_bus(nargout=21)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    on=find(mpc.gen[:,GEN_STATUS-1]>0& not isload(mpc.gen))
    onld=find(mpc.gen[:,GEN_STATUS-1]>0&isload(mpc.gen))
    load_capacity=sum(mpc.bus[:,PD-1])-sum(mpc.gen[onld-1,PMIN-1])
    Pmin=mpc.gen[on-1,PMIN-1]
    while sum(Pmin)>load_capacity:
        avgPmincost=totcost(mpc.gencost[on-1,:],Pmin)/Pmin
        junk,i=fairmax(avgPmincost,nargout=2)
        i=on[int(i-1)]
        if verbose:
            fprintf('Shutting down generator %d so all Pmin limits can be satisfied.\\n',i)
        mpc.gen[i-1,m_array([PG,QG,GEN_STATUS]).reshape(1,-1)-1]=0
        on=find(mpc.gen[:,GEN_STATUS-1]>0& not isload(mpc.gen))
        Pmin=mpc.gen[on-1,PMIN-1]
    results,success=opf(mpc,mpopt,nargout=2)
    results1=results
    results0=_copy(results1)
    mpc.bus=results0.bus
    while 1:
        candidates=find(results0.gen[:,MU_PMIN-1]>0&results0.gen[:,PMIN-1]>0)
        if isempty(candidates):
            break
        done=1
        for i in arange(1,length(candidates)+1).reshape(1,-1).flat:
            k=candidates[int(i-1)]
            mpc.gen=results0.gen
            mpc.gen[k-1,m_array([PG,QG,GEN_STATUS]).reshape(1,-1)-1]=0
            results,success=opf(mpc,mpopt,nargout=2)
            if success and results.f<results1.f:
                results1=results
                k1=k
                done=0
        if done:
            break
        else:
            if verbose:
                fprintf('Shutting down generator %d.\\n',k1)
            results0=_copy(results1)
            mpc.bus=results0.bus
    et=etime(clock(),t0)
    if nargout()>0:
        success=results0.success
        if nargout()<=2:
            results0.et=et
            bus=results0
            gen=success
        else:
            bus,gen,branch,f,info,xr,pimul=deal(results0.bus,results0.gen,results0.branch,results0.f,results0.raw.info,results0.raw.xr,results0.raw.pimul,nargout=7)
            if isfield(results0,'g'):
                g=results0.g
            if isfield(results0,'dg'):
                jac=results0.dg
    else:
        if results0.success:
            results0.et=et
            printpf(results0,1,mpopt)
    return bus,gen,branch,f,success,info,et,g,jac,xr,pimul
def update_mupq(baseMVA,gen,mu_PQh,mu_PQl,data,**kwargs):
    gen=_copy(gen)
    ipqh,ipql,Apqhdata,Apqldata=deal(data.ipqh,data.ipql,data.h,data.l,nargout=4)
    GEN_BUS,PG,QG,QMAX,QMIN,VG,MBASE,GEN_STATUS,PMAX,PMIN,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN,PC1,PC2,QC1MIN,QC1MAX,QC2MIN,QC2MAX,RAMP_AGC,RAMP_10,RAMP_30,RAMP_Q,APF=idx_gen(nargout=25)
    muP=gen[:,MU_PMAX-1]-gen[:,MU_PMIN-1]
    muQ=gen[:,MU_QMAX-1]-gen[:,MU_QMIN-1]
    muP[int(ipqh-1)]=muP[int(ipqh-1)]-mu_PQh*Apqhdata[:,1-1]/baseMVA
    muQ[int(ipqh-1)]=muQ[int(ipqh-1)]-mu_PQh*Apqhdata[:,2-1]/baseMVA
    muP[int(ipql-1)]=muP[int(ipql-1)]-mu_PQl*Apqldata[:,1-1]/baseMVA
    muQ[int(ipql-1)]=muQ[int(ipql-1)]-mu_PQl*Apqldata[:,2-1]/baseMVA
    gen[:,MU_PMAX-1]=(muP>0)*muP
    gen[:,MU_PMIN-1]=(muP<0)*-muP
    gen[:,MU_QMAX-1]=(muQ>0)*muQ
    gen[:,MU_QMIN-1]=(muQ<0)*-muQ
    return gen
